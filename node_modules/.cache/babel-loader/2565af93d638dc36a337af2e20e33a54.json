{"ast":null,"code":"import { isMatrix, isNumeric, Matrix } from \"./computable\";\nimport { ArgumentError } from \"./errors\";\n/**\n * takes rref and stores into matrix\n * @param node\n */\n\nexport function rref(node) {\n  let matrix = node.eval();\n\n  if (isMatrix(matrix) && matrix.matrix) {\n    var lead = 0;\n\n    for (var k = 0; k < matrix.dimR; k++) {\n      if (matrix.dimC <= lead) return matrix;\n      var i = k;\n\n      while (matrix.matrix[i][lead] === 0) {\n        i++;\n\n        if (matrix.dimR === i) {\n          i = k;\n          lead++;\n          if (matrix.dimC === lead) return matrix;\n        }\n      }\n\n      var irow = matrix.matrix[i],\n          krow = matrix.matrix[k];\n      matrix.matrix[i] = krow;\n      matrix.matrix[k] = irow;\n      var val = matrix.matrix[k][lead];\n\n      for (var j = 0; j < matrix.dimC; j++) {\n        matrix.matrix[k][j] /= val;\n      }\n\n      for (var i = 0; i < matrix.dimR; i++) {\n        if (i === k) continue;\n        val = matrix.matrix[i][lead];\n\n        for (var j = 0; j < matrix.dimC; j++) {\n          matrix.matrix[i][j] -= val * matrix.matrix[k][j];\n        }\n      }\n\n      lead++;\n    }\n\n    return matrix;\n  } else {\n    throw new ArgumentError(\"expected a matrix.\");\n  }\n}\n/**\n * takes transpose and stores into matrix\n * @param node\n */\n\nexport function transpose(node) {\n  let matrix = node.eval();\n\n  if (isMatrix(matrix)) {\n    return matrix.transpose(true).result;\n  } else {\n    throw new ArgumentError(\"expected a matrix\");\n  }\n}\n/**\n * takes determinant\n * @param node\n */\n\nexport function det(node) {\n  let matrix = node.eval();\n\n  if (isMatrix(matrix)) {\n    return matrix.determinant();\n  } else {\n    throw new ArgumentError(\"expected a matrix\");\n  }\n}\nexport function sqrt(node) {\n  let num = node.eval();\n\n  if (isNumeric(num)) {\n    return Math.sqrt(num.value);\n  } else {\n    throw new ArgumentError(\"expected a number\");\n  }\n}\nexport function identity(node) {\n  let num = node.eval();\n\n  if (isNumeric(num)) {\n    let arr = [];\n\n    for (let i = 0; i < num.value; i++) {\n      arr.push([]);\n\n      for (let j = 0; j < num.value; j++) {\n        arr[i].push(i == j ? 1 : 0);\n      }\n    }\n\n    return new Matrix(arr);\n  } else {\n    throw new ArgumentError(\"expected a number\");\n  }\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/functions.ts"],"names":["isMatrix","isNumeric","Matrix","ArgumentError","rref","node","matrix","eval","lead","k","dimR","dimC","i","irow","krow","val","j","transpose","result","det","determinant","sqrt","num","Math","value","identity","arr","push"],"mappings":"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","sourcesContent":["import { AST } from \"./ast\";\nimport { isMatrix, isNumeric, Matrix } from \"./computable\";\nimport { ArgumentError } from \"./errors\";\n\n/**\n * takes rref and stores into matrix\n * @param node\n */\nexport function rref(node: AST) {\n  let matrix = node.eval();\n  if (isMatrix(matrix) && matrix.matrix) {\n    var lead = 0;\n    for (var k = 0; k < matrix.dimR; k++) {\n      if (matrix.dimC <= lead) return matrix;\n\n      var i = k;\n      while (matrix.matrix[i][lead] === 0) {\n        i++;\n        if (matrix.dimR === i) {\n          i = k;\n          lead++;\n          if (matrix.dimC === lead) return matrix;\n        }\n      }\n      var irow = matrix.matrix[i],\n        krow = matrix.matrix[k];\n      matrix.matrix[i] = krow;\n      matrix.matrix[k] = irow;\n\n      var val = matrix.matrix[k][lead];\n      for (var j = 0; j < matrix.dimC; j++) {\n        matrix.matrix[k][j] /= val;\n      }\n\n      for (var i = 0; i < matrix.dimR; i++) {\n        if (i === k) continue;\n        val = matrix.matrix[i][lead];\n        for (var j = 0; j < matrix.dimC; j++) {\n          matrix.matrix[i][j] -= val * matrix.matrix[k][j];\n        }\n      }\n      lead++;\n    }\n    return matrix;\n  } else {\n    throw new ArgumentError(\"expected a matrix.\");\n  }\n}\n\n/**\n * takes transpose and stores into matrix\n * @param node\n */\nexport function transpose(node: AST) {\n  let matrix = node.eval();\n  if (isMatrix(matrix)) {\n    return matrix.transpose(true).result;\n  } else {\n    throw new ArgumentError(\"expected a matrix\");\n  }\n}\n\n/**\n * takes determinant\n * @param node\n */\nexport function det(node: AST) {\n  let matrix = node.eval();\n  if (isMatrix(matrix)) {\n    return matrix.determinant();\n  } else {\n    throw new ArgumentError(\"expected a matrix\");\n  }\n}\n\nexport function sqrt(node: AST) {\n  let num = node.eval();\n  if (isNumeric(num)) {\n    return Math.sqrt(num.value);\n  } else {\n    throw new ArgumentError(\"expected a number\");\n  }\n}\n\nexport function identity(node: AST): Matrix {\n  let num = node.eval();\n  if (isNumeric(num)) {\n    let arr: number[][] = [];\n    for (let i = 0; i < num.value; i++) {\n      arr.push([]);\n      for (let j = 0; j < num.value; j++) {\n        arr[i].push(i == j ? 1 : 0);\n      }\n    }\n    return new Matrix(arr);\n  } else {\n    throw new ArgumentError(\"expected a number\");\n  }\n}\n"]},"metadata":{},"sourceType":"module"}