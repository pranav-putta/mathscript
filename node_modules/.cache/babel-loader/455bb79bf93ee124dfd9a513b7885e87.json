{"ast":null,"code":"import { ArithmeticError } from \"../errors\";\nimport { TokenType } from \"../token\";\nimport { isMatrix } from \"./matrix\";\nexport class Computable {\n  static compute(a, b, operator) {\n    switch (operator) {\n      case TokenType.plus:\n        return a.add(b);\n\n      case TokenType.minus:\n        return a.sub(b);\n\n      case TokenType.mul:\n        return a.mul(b);\n\n      case TokenType.div:\n        return a.div(b);\n\n      case TokenType.rdiv:\n        return a.rdiv(b);\n\n      default:\n        throw new ArithmeticError(\"unsupported operation: \" + operator);\n    }\n  }\n\n}\n/**\n * checks if given element is of type computable\n * @param el any element\n */\n\nexport function isComputable(el) {\n  return el instanceof Computable;\n}\nexport class Numeric extends Computable {\n  constructor(val) {\n    super();\n    this.value = void 0;\n    this.value = val;\n  }\n\n  error() {\n    throw new ArithmeticError(\"cannot add numeric with non-numeric\");\n  }\n\n  add(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value + other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.add(this);\n    }\n\n    this.error();\n  }\n\n  sub(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value - other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.sub(this);\n    }\n\n    this.error();\n  }\n\n  mul(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value * other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.mul(this);\n    }\n\n    this.error();\n  }\n\n  div(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value / other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.div(this);\n    }\n\n    this.error();\n  }\n\n  rdiv(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(Math.floor(this.value / other.value))\n      };\n    } else if (isMatrix(other)) {\n      return other.rdiv(this);\n    }\n\n    this.error();\n  }\n\n  pow(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(Math.pow(this.value, other.value))\n      };\n    }\n\n    this.error();\n  }\n\n}\nexport function isNumeric(el) {\n  return el instanceof Numeric;\n}\n\n/**\n * boolean computable value\n */\nexport class Logical extends Numeric {\n  constructor(value) {\n    super(value ? 1 : 0);\n    this.boolVal = void 0;\n    this.boolVal = value;\n  }\n\n  add(other) {\n    return other.add(new Numeric(this.value));\n  }\n\n  sub(other) {\n    return other.add(new Numeric(this.value * -1));\n  }\n\n  mul(other) {\n    return other.mul(new Numeric(this.value));\n  }\n\n  div(other) {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  rdiv(other) {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  pow(other) {\n    throw new ArithmeticError(\"boolean powers not supported\");\n  }\n\n  or(other) {\n    return {\n      result: new Logical(this.boolVal || other.boolVal)\n    };\n  }\n\n  and(other) {\n    return {\n      result: new Logical(this.boolVal && other.boolVal)\n    };\n  }\n\n  xor(other) {\n    return {\n      result: new Logical(this.boolVal !== other.boolVal)\n    };\n  }\n\n  nand(other) {\n    return {\n      result: new Logical(this.boolVal == other.boolVal && !this.boolVal)\n    };\n  }\n\n}\nexport function isLogical(el) {\n  return el instanceof Logical;\n}\nexport { UnevaluatedMatrix, Matrix } from \"./matrix\";","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/computable/index.ts"],"names":["ArithmeticError","TokenType","isMatrix","Computable","compute","a","b","operator","plus","add","minus","sub","mul","div","rdiv","isComputable","el","Numeric","constructor","val","value","error","other","isNumeric","result","Math","floor","pow","Logical","boolVal","or","and","xor","nand","isLogical","UnevaluatedMatrix","Matrix"],"mappings":"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","sourcesContent":["import { ComputableNode } from \"../ast\";\nimport { ArithmeticError, MatrixError } from \"../errors\";\nimport { TokenType } from \"../token\";\nimport { isMatrix } from \"./matrix\";\n\nexport interface Result {\n  result: Computable;\n  message?: string;\n}\n\nexport abstract class Computable {\n  public abstract add(other: Computable): Result;\n  public abstract sub(other: Computable): Result;\n  public abstract mul(other: Computable): Result;\n  public abstract div(other: Computable): Result;\n  public abstract rdiv(other: Computable): Result;\n  public abstract pow(other: Computable): Result;\n\n  public static compute(\n    a: Computable,\n    b: Computable,\n    operator: TokenType\n  ): Result {\n    switch (operator) {\n      case TokenType.plus:\n        return a.add(b);\n      case TokenType.minus:\n        return a.sub(b);\n      case TokenType.mul:\n        return a.mul(b);\n      case TokenType.div:\n        return a.div(b);\n      case TokenType.rdiv:\n        return a.rdiv(b);\n      default:\n        throw new ArithmeticError(\"unsupported operation: \" + operator);\n    }\n  }\n}\n\n/**\n * checks if given element is of type computable\n * @param el any element\n */\nexport function isComputable(el: any): el is Computable {\n  return el instanceof Computable;\n}\n\nexport class Numeric extends Computable {\n  value: number;\n\n  constructor(val: number) {\n    super();\n    this.value = val;\n  }\n\n  private error(): never {\n    throw new ArithmeticError(\"cannot add numeric with non-numeric\");\n  }\n\n  public add(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value + other.value) };\n    } else if (isMatrix(other)) {\n      return other.add(this);\n    }\n    this.error();\n  }\n\n  public sub(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value - other.value) };\n    } else if (isMatrix(other)) {\n      return other.sub(this);\n    }\n    this.error();\n  }\n\n  public mul(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value * other.value) };\n    } else if (isMatrix(other)) {\n      return other.mul(this);\n    }\n    this.error();\n  }\n\n  public div(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value / other.value) };\n    } else if (isMatrix(other)) {\n      return other.div(this);\n    }\n    this.error();\n  }\n\n  public rdiv(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(Math.floor(this.value / other.value)) };\n    } else if (isMatrix(other)) {\n      return other.rdiv(this);\n    }\n    this.error();\n  }\n\n  public pow(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(Math.pow(this.value, other.value)) };\n    }\n    this.error();\n  }\n}\n\nexport function isNumeric(el: any): el is Numeric {\n  return el instanceof Numeric;\n}\n\nexport interface LogicalResult extends Result {\n  result: Logical;\n}\n/**\n * boolean computable value\n */\nexport class Logical extends Numeric {\n  private boolVal: boolean;\n\n  constructor(value: boolean) {\n    super(value ? 1 : 0);\n    this.boolVal = value;\n  }\n\n  public add(other: Computable): Result {\n    return other.add(new Numeric(this.value));\n  }\n  public sub(other: Computable): Result {\n    return other.add(new Numeric(this.value * -1));\n  }\n  public mul(other: Computable): Result {\n    return other.mul(new Numeric(this.value));\n  }\n  public div(other: Computable): Result {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  public rdiv(other: Computable): Result {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n  public pow(other: Computable): Result {\n    throw new ArithmeticError(\"boolean powers not supported\");\n  }\n\n  public or(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal || other.boolVal) };\n  }\n\n  public and(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal && other.boolVal) };\n  }\n\n  public xor(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal !== other.boolVal) };\n  }\n\n  public nand(other: Logical): LogicalResult {\n    return {\n      result: new Logical(this.boolVal == other.boolVal && !this.boolVal),\n    };\n  }\n}\n\nexport function isLogical(el: any): el is Logical {\n  return el instanceof Logical;\n}\n\nexport { UnevaluatedMatrix, Matrix } from \"./matrix\";\n"]},"metadata":{},"sourceType":"module"}