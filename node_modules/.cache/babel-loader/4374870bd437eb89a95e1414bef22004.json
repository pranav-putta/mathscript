{"ast":null,"code":"import { SymbolError } from \"./errors\";\nimport { TokenType, plus_token, minus_token, mul_token, div_token, lparen_token, rparen_token, lbracket_token, rbracket_token, semicolon_token, comma_token, bar_token, assign_token, dot_token, endl_token, rdiv_token, larrow_token, rarrow_token, pow_token } from \"./token\";\nimport { isspace, isdigit, isalnum } from \"./util\";\n\n/**\n * Lexer tokenizes raw input into @class{Token} objects\n */\nexport class Lexer {\n  /**\n   * raw input text\n   */\n\n  /**\n   * current tokenizing position\n   */\n\n  /**\n   * current character at position\n   */\n  constructor(text) {\n    this.reserved_keywords = {};\n    this.text = void 0;\n    this.position = void 0;\n    this.current_char = void 0;\n    this.text = text;\n    this.position = -1;\n  }\n\n  _id() {\n    let result = \"\";\n\n    while (this.current_char && isalnum(this.current_char)) {\n      result += this.current_char;\n      let next = this.peek();\n\n      if (next && isalnum(next)) {\n        this.advance();\n      } else {\n        break;\n      }\n      /**\n      // allow spaces in identifier names\n      if (this.current_char && isspace(this.current_char)) {\n        // ignore whitespace until next token\n        this.ignore_whitespace(false);\n        // check if next token is also alphanumeric\n        let next = this.peek();\n        if (next && isalnum(next)) {\n          // if true, set next token\n          this.advance()\n        }\n      }*/\n\n    }\n\n    return this.reserved_keywords[result] || {\n      type: TokenType.id,\n      value: result\n    };\n  }\n  /**\n   * increments position and updates current_char\n   * sets current_char to undefined if position is out of bounds\n   */\n\n\n  advance() {\n    this.position++;\n\n    if (this.position < this.text.length) {\n      this.current_char = this.text.charAt(this.position);\n    } else {\n      this.current_char = undefined;\n    }\n  }\n  /**\n   * retrieves next token without advancing position\n   */\n\n\n  peek(steps = 1) {\n    if (this.position + steps >= this.text.length) {\n      return undefined;\n    } else {\n      return this.text.charAt(this.position + steps);\n    }\n  }\n\n  peekToken() {\n    let pos = this.position + 1;\n\n    while (pos < this.text.length && isspace(this.text.charAt(pos))) {\n      pos += 1;\n    }\n\n    return this.text.charAt(pos);\n  }\n  /**\n   * skips all whitepsace in sequence\n   */\n\n\n  ignore_whitespace(advance = true) {\n    if (advance) {\n      // stop at next token\n      while (this.current_char && isspace(this.current_char)) {\n        this.advance();\n      }\n    } else {\n      // stop before next token\n      let current = this.peek();\n\n      while (current && isspace(current)) {\n        this.advance();\n      }\n    }\n  }\n  /**\n   * converts numeric character sequence into a token\n   */\n\n\n  tokenize_number() {\n    let result = this.current_char || \"\";\n    let next = this.peek(); // capture integer\n\n    while (next && isdigit(next)) {\n      this.advance();\n      result += this.current_char;\n      next = this.peek();\n    } // check if decimal point\n\n\n    if (next && next == \".\") {\n      let tmpNext = this.peek(2); // make sure next character is a digit, not an elipses or something like '1.'\n\n      if (tmpNext && isdigit(tmpNext)) {\n        this.advance();\n        result += this.current_char;\n        next = this.peek(); // append numbers after decimal point\n\n        while (next && isdigit(next)) {\n          this.advance();\n          result += this.current_char;\n          next = this.peek();\n        }\n      }\n    } // convert to number and return\n\n\n    return Number(result);\n  }\n  /**\n   * retrieves next token in string\n   */\n\n\n  next_token() {\n    this.advance();\n    let token = this.tokenize();\n    return token;\n  }\n  /**\n   * compares characters and matches with associated token\n   */\n\n\n  tokenize() {\n    if (!this.current_char) {\n      // no more characters\n      return {\n        type: TokenType.eof,\n        value: \"eof\"\n      };\n    }\n\n    if (isspace(this.current_char)) {\n      // ignore all spaces\n      this.ignore_whitespace();\n    }\n\n    if (isdigit(this.current_char)) {\n      // capture numeric token\n      return {\n        type: TokenType.num,\n        value: this.tokenize_number()\n      };\n    } else if (isalnum(this.current_char)) {\n      return this._id();\n    } else if (this.current_char == \"+\") {\n      // capture \"plus\" token\n      return plus_token;\n    } else if (this.current_char == \"-\") {\n      // capture \"minus\" token\n      return minus_token;\n    } else if (this.current_char == \"*\") {\n      // capture \"mul\" token\n      return mul_token;\n    } else if (this.current_char == \"/\") {\n      let next = this.peek();\n\n      if (next && next == \"/\") {\n        this.advance();\n        return rdiv_token;\n      } // capture \"div\" token\n\n\n      return div_token;\n    } else if (this.current_char == \"(\") {\n      // capture \"lparen\" token\n      return lparen_token;\n    } else if (this.current_char == \")\") {\n      // capture \"rparen\" token\n      return rparen_token;\n    } else if (this.current_char == \"[\") {\n      // capture \"lbracket\" token\n      return lbracket_token;\n    } else if (this.current_char == \"]\") {\n      // capture \"rbracket\" token\n      return rbracket_token;\n    } else if (this.current_char == \"<\") {\n      // capture \"lbracket\" token\n      return larrow_token;\n    } else if (this.current_char == \">\") {\n      // capture \"rbracket\" token\n      return rarrow_token;\n    } else if (this.current_char == \";\") {\n      // capture \"semicolon\" token\n      return semicolon_token;\n    } else if (this.current_char == \",\") {\n      // capture \"comma\" token\n      return comma_token;\n    } else if (this.current_char == \"|\") {\n      // capture \"bar\" token\n      return bar_token;\n    } else if (this.current_char == \"=\" && this.peek() != \"=\") {\n      // capture \"assign\" token\n      return assign_token;\n    } else if (this.current_char == \".\" && this.peek() != \".\") {\n      // capture \"dot\" token\n      return dot_token;\n    } else if (this.current_char == \"\\n\") {\n      // capture \"endl\" token\n      return endl_token;\n    } else if (this.current_char == \"^\") {\n      // capture \"^\"\n      return pow_token;\n    } // token wasn't recognized\n\n\n    throw new SymbolError(\"unexpected token: `\" + this.current_char + \"`\");\n  }\n\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/lexer.ts"],"names":["SymbolError","TokenType","plus_token","minus_token","mul_token","div_token","lparen_token","rparen_token","lbracket_token","rbracket_token","semicolon_token","comma_token","bar_token","assign_token","dot_token","endl_token","rdiv_token","larrow_token","rarrow_token","pow_token","isspace","isdigit","isalnum","Lexer","constructor","text","reserved_keywords","position","current_char","_id","result","next","peek","advance","type","id","value","length","charAt","undefined","steps","peekToken","pos","ignore_whitespace","current","tokenize_number","tmpNext","Number","next_token","token","tokenize","eof","num"],"mappings":"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","sourcesContent":["import { SymbolError } from \"./errors\";\nimport {\n  Token,\n  TokenType,\n  plus_token,\n  minus_token,\n  mul_token,\n  div_token,\n  lparen_token,\n  rparen_token,\n  lbracket_token,\n  rbracket_token,\n  semicolon_token,\n  comma_token,\n  bar_token,\n  assign_token,\n  dot_token,\n  endl_token,\n  SymbolToken,\n  rdiv_token,\n  larrow_token,\n  rarrow_token,\n  pow_token,\n} from \"./token\";\nimport { isspace, isdigit, isalnum } from \"./util\";\n\ninterface Keywords {\n  [key: string]: SymbolToken;\n}\n\n/**\n * Lexer tokenizes raw input into @class{Token} objects\n */\nexport class Lexer {\n  private readonly reserved_keywords: Keywords = {};\n  /**\n   * raw input text\n   */\n  private text: string;\n  /**\n   * current tokenizing position\n   */\n  private position: number;\n  /**\n   * current character at position\n   */\n  private current_char: string | undefined;\n\n  constructor(text: string) {\n    this.text = text;\n    this.position = -1;\n  }\n\n  private _id(): SymbolToken {\n    let result = \"\";\n    while (this.current_char && isalnum(this.current_char)) {\n      result += this.current_char;\n      let next = this.peek();\n      if (next && isalnum(next)) {\n        this.advance();\n      } else {\n        break;\n      }\n      /**\n      // allow spaces in identifier names\n      if (this.current_char && isspace(this.current_char)) {\n        // ignore whitespace until next token\n        this.ignore_whitespace(false);\n        // check if next token is also alphanumeric\n        let next = this.peek();\n        if (next && isalnum(next)) {\n          // if true, set next token\n          this.advance()\n        }\n      }*/\n    }\n    return (\n      this.reserved_keywords[result] || { type: TokenType.id, value: result }\n    );\n  }\n\n  /**\n   * increments position and updates current_char\n   * sets current_char to undefined if position is out of bounds\n   */\n  private advance() {\n    this.position++;\n\n    if (this.position < this.text.length) {\n      this.current_char = this.text.charAt(this.position);\n    } else {\n      this.current_char = undefined;\n    }\n  }\n\n  /**\n   * retrieves next token without advancing position\n   */\n  public peek(steps: number = 1): string | undefined {\n    if (this.position + steps >= this.text.length) {\n      return undefined;\n    } else {\n      return this.text.charAt(this.position + steps);\n    }\n  }\n\n  public peekToken(): string {\n    let pos = this.position + 1;\n    while (pos < this.text.length && isspace(this.text.charAt(pos))) {\n      pos += 1;\n    }\n    return this.text.charAt(pos);\n  }\n\n  /**\n   * skips all whitepsace in sequence\n   */\n  private ignore_whitespace(advance: boolean = true) {\n    if (advance) {\n      // stop at next token\n      while (this.current_char && isspace(this.current_char)) {\n        this.advance();\n      }\n    } else {\n      // stop before next token\n      let current = this.peek();\n      while (current && isspace(current)) {\n        this.advance();\n      }\n    }\n  }\n\n  /**\n   * converts numeric character sequence into a token\n   */\n  private tokenize_number(): number {\n    let result = this.current_char || \"\";\n    let next = this.peek();\n    // capture integer\n    while (next && isdigit(next)) {\n      this.advance();\n      result += this.current_char;\n      next = this.peek();\n    }\n\n    // check if decimal point\n    if (next && next == \".\") {\n      let tmpNext = this.peek(2);\n      // make sure next character is a digit, not an elipses or something like '1.'\n      if (tmpNext && isdigit(tmpNext)) {\n        this.advance();\n        result += this.current_char;\n        next = this.peek();\n\n        // append numbers after decimal point\n        while (next && isdigit(next)) {\n          this.advance();\n          result += this.current_char;\n          next = this.peek();\n        }\n      }\n    }\n\n    // convert to number and return\n    return Number(result);\n  }\n\n  /**\n   * retrieves next token in string\n   */\n  public next_token(): Token {\n    this.advance();\n    let token = this.tokenize();\n    return token;\n  }\n\n  /**\n   * compares characters and matches with associated token\n   */\n  private tokenize(): Token {\n    if (!this.current_char) {\n      // no more characters\n      return { type: TokenType.eof, value: \"eof\" };\n    }\n    if (isspace(this.current_char)) {\n      // ignore all spaces\n      this.ignore_whitespace();\n    }\n\n    if (isdigit(this.current_char)) {\n      // capture numeric token\n      return { type: TokenType.num, value: this.tokenize_number() };\n    } else if (isalnum(this.current_char)) {\n      return this._id();\n    } else if (this.current_char == \"+\") {\n      // capture \"plus\" token\n      return plus_token;\n    } else if (this.current_char == \"-\") {\n      // capture \"minus\" token\n      return minus_token;\n    } else if (this.current_char == \"*\") {\n      // capture \"mul\" token\n      return mul_token;\n    } else if (this.current_char == \"/\") {\n      let next = this.peek();\n      if (next && next == \"/\") {\n        this.advance();\n        return rdiv_token;\n      }\n      // capture \"div\" token\n      return div_token;\n    } else if (this.current_char == \"(\") {\n      // capture \"lparen\" token\n      return lparen_token;\n    } else if (this.current_char == \")\") {\n      // capture \"rparen\" token\n      return rparen_token;\n    } else if (this.current_char == \"[\") {\n      // capture \"lbracket\" token\n      return lbracket_token;\n    } else if (this.current_char == \"]\") {\n      // capture \"rbracket\" token\n      return rbracket_token;\n    } else if (this.current_char == \"<\") {\n      // capture \"lbracket\" token\n      return larrow_token;\n    } else if (this.current_char == \">\") {\n      // capture \"rbracket\" token\n      return rarrow_token;\n    } else if (this.current_char == \";\") {\n      // capture \"semicolon\" token\n      return semicolon_token;\n    } else if (this.current_char == \",\") {\n      // capture \"comma\" token\n      return comma_token;\n    } else if (this.current_char == \"|\") {\n      // capture \"bar\" token\n      return bar_token;\n    } else if (this.current_char == \"=\" && this.peek() != \"=\") {\n      // capture \"assign\" token\n      return assign_token;\n    } else if (this.current_char == \".\" && this.peek() != \".\") {\n      // capture \"dot\" token\n      return dot_token;\n    } else if (this.current_char == \"\\n\") {\n      // capture \"endl\" token\n      return endl_token;\n    } else if (this.current_char == \"^\") {\n      // capture \"^\"\n      return pow_token;\n    }\n\n    // token wasn't recognized\n    throw new SymbolError(\"unexpected token: `\" + this.current_char + \"`\");\n  }\n}\n"]},"metadata":{},"sourceType":"module"}