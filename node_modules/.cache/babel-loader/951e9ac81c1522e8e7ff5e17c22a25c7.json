{"ast":null,"code":"import { SymbolError } from \"./errors\";\nimport { TokenType, newToken } from \"./token\";\nimport { isspace, isdigit, isalnum } from \"./util\";\n\n/**\n * Lexer tokenizes raw input into @class{Token} objects\n */\nexport class Lexer {\n  /**\n   * raw input text\n   */\n\n  /**\n   * current tokenizing position\n   */\n\n  /**\n   * current character at position\n   */\n  constructor(text) {\n    this.text = void 0;\n    this.position = void 0;\n    this.current_char = void 0;\n    this.text = text;\n    this.position = -1;\n  }\n\n  _id() {\n    let result = \"\";\n\n    while (this.current_char && isalnum(this.current_char)) {\n      result += this.current_char;\n      let next = this.peek();\n\n      if (next && isalnum(next)) {\n        this.advance();\n      } else {\n        break;\n      }\n    }\n\n    return Lexer.reserved_keywords[result] || {\n      type: TokenType.id,\n      value: result\n    };\n  }\n  /**\n   * increments position and updates current_char\n   * sets current_char to undefined if position is out of bounds\n   */\n\n\n  advance() {\n    this.position++;\n\n    if (this.position < this.text.length) {\n      this.current_char = this.text.charAt(this.position);\n    } else {\n      this.current_char = undefined;\n    }\n  }\n  /**\n   * retrieves next character without advancing position\n   * @param steps number of steps to take\n   */\n\n\n  peek(steps = 1) {\n    if (this.position + steps >= this.text.length) {\n      return undefined;\n    } else {\n      return this.text.charAt(this.position + steps);\n    }\n  }\n  /**\n   * retrieves the next token by ignoring whitespaces\n   */\n\n\n  peekToken() {\n    let pos = this.position + 1;\n\n    while (pos < this.text.length && isspace(this.text.charAt(pos))) {\n      pos += 1;\n    }\n\n    return this.text.charAt(pos);\n  }\n  /**\n   * skips all whitepsace in sequence\n   */\n\n\n  ignore_whitespace(advance = true) {\n    if (advance) {\n      // stop at next token\n      while (this.current_char && isspace(this.current_char)) {\n        this.advance();\n      }\n    } else {\n      // stop before next token\n      let current = this.peek();\n\n      while (current && isspace(current)) {\n        this.advance();\n      }\n    }\n  }\n  /**\n   * converts numeric character sequence into a token\n   */\n\n\n  tokenize_number() {\n    let result = this.current_char || \"\";\n    let next = this.peek(); // capture integer\n\n    while (next && isdigit(next)) {\n      this.advance();\n      result += this.current_char;\n      next = this.peek();\n    } // check if decimal point\n\n\n    if (next && next == \".\") {\n      let tmpNext = this.peek(2);\n      this.advance(); // make sure next character is a digit, not an elipses or something like '1.'\n\n      if (tmpNext && isdigit(tmpNext)) {\n        result += this.current_char;\n        next = this.peek(); // append numbers after decimal point\n\n        while (next && isdigit(next)) {\n          this.advance();\n          result += this.current_char;\n          next = this.peek();\n        }\n      }\n    } // convert to number and return\n\n\n    return Number(result);\n  }\n  /**\n   * retrieves next token in string\n   */\n\n\n  next_token() {\n    this.advance();\n    let token = this.tokenize();\n    return token;\n  }\n  /**\n   * compares characters and matches with associated token\n   */\n\n\n  tokenize() {\n    // ignore all spaces\n    if (this.current_char && isspace(this.current_char)) {\n      this.ignore_whitespace();\n    } // check if no more characters\n\n\n    if (!this.current_char) {\n      return {\n        type: TokenType.eof,\n        value: \"eof\"\n      };\n    }\n\n    if (isdigit(this.current_char)) {\n      // capture numeric token\n      return {\n        type: TokenType.num,\n        value: this.tokenize_number()\n      };\n    } else if (isalnum(this.current_char)) {\n      return this._id();\n    } else if (this.current_char == \"+\") {\n      return newToken(TokenType.plus);\n    } else if (this.current_char == \"-\") {\n      return newToken(TokenType.minus);\n    } else if (this.current_char == \"*\") {\n      return newToken(TokenType.mul);\n    } else if (this.current_char == \"/\") {\n      // check if token is rdiv\n      let next = this.peek();\n\n      if (next && next == \"/\") {\n        this.advance();\n        return newToken(TokenType.rdiv);\n      }\n\n      return newToken(TokenType.div);\n    } else if (this.current_char == \"(\") {\n      return newToken(TokenType.lparen);\n    } else if (this.current_char == \")\") {\n      return newToken(TokenType.rparen);\n    } else if (this.current_char == \"[\") {\n      return newToken(TokenType.lbracket);\n    } else if (this.current_char == \"]\") {\n      return newToken(TokenType.rbracket);\n    } else if (this.current_char == \"<\") {\n      return newToken(TokenType.larrow);\n    } else if (this.current_char == \">\") {\n      return newToken(TokenType.rarrow);\n    } else if (this.current_char == \";\") {\n      return newToken(TokenType.semicolon);\n    } else if (this.current_char == \",\") {\n      return newToken(TokenType.comma);\n    } else if (this.current_char == \"=\" && this.peek() != \"=\") {\n      return newToken(TokenType.assign);\n    } else if (this.current_char == \".\" && this.peek() != \".\") {\n      return newToken(TokenType.dot);\n    } else if (this.current_char == \"\\n\") {\n      return newToken(TokenType.endl);\n    } else if (this.current_char == \"^\") {\n      return newToken(TokenType.pow);\n    } else if (this.current_char == \"&\") {\n      // check if token is boolean and\n      let next = this.peek();\n\n      if (next && next == \"&\") {\n        this.advance();\n        return newToken(TokenType.and_bool);\n      }\n\n      return newToken(TokenType.and);\n    } else if (this.current_char == \"|\") {\n      // check if token is rdiv\n      let next = this.peek();\n\n      if (next && next == \"|\") {\n        this.advance();\n        return newToken(TokenType.or_bool);\n      }\n\n      return newToken(TokenType.or);\n    } // token wasn't recognized\n\n\n    throw new SymbolError(\"unexpected token: `\" + this.current_char + \"`\");\n  }\n\n}\nLexer.reserved_keywords = {\n  true: newToken(TokenType.primitive, \"true\"),\n  false: newToken(TokenType.primitive, \"false\")\n};","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/lexer.ts"],"names":["SymbolError","TokenType","newToken","isspace","isdigit","isalnum","Lexer","constructor","text","position","current_char","_id","result","next","peek","advance","reserved_keywords","type","id","value","length","charAt","undefined","steps","peekToken","pos","ignore_whitespace","current","tokenize_number","tmpNext","Number","next_token","token","tokenize","eof","num","plus","minus","mul","rdiv","div","lparen","rparen","lbracket","rbracket","larrow","rarrow","semicolon","comma","assign","dot","endl","pow","and_bool","and","or_bool","or","true","primitive","false"],"mappings":"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","sourcesContent":["import { SymbolError } from \"./errors\";\nimport { Token, TokenType, SymbolToken, newToken } from \"./token\";\nimport { isspace, isdigit, isalnum } from \"./util\";\n\ninterface Keywords {\n  [key: string]: Token;\n}\n\n/**\n * Lexer tokenizes raw input into @class{Token} objects\n */\nexport class Lexer {\n  public static readonly reserved_keywords: Keywords = {\n    true: newToken(TokenType.primitive, \"true\"),\n    false: newToken(TokenType.primitive, \"false\"),\n  };\n  /**\n   * raw input text\n   */\n  private text: string;\n  /**\n   * current tokenizing position\n   */\n  private position: number;\n  /**\n   * current character at position\n   */\n  private current_char: string | undefined;\n\n  constructor(text: string) {\n    this.text = text;\n    this.position = -1;\n  }\n\n  private _id(): Token {\n    let result = \"\";\n    while (this.current_char && isalnum(this.current_char)) {\n      result += this.current_char;\n      let next = this.peek();\n      if (next && isalnum(next)) {\n        this.advance();\n      } else {\n        break;\n      }\n    }\n    return (\n      Lexer.reserved_keywords[result] || { type: TokenType.id, value: result }\n    );\n  }\n\n  /**\n   * increments position and updates current_char\n   * sets current_char to undefined if position is out of bounds\n   */\n  private advance() {\n    this.position++;\n\n    if (this.position < this.text.length) {\n      this.current_char = this.text.charAt(this.position);\n    } else {\n      this.current_char = undefined;\n    }\n  }\n\n  /**\n   * retrieves next character without advancing position\n   * @param steps number of steps to take\n   */\n  public peek(steps: number = 1): string | undefined {\n    if (this.position + steps >= this.text.length) {\n      return undefined;\n    } else {\n      return this.text.charAt(this.position + steps);\n    }\n  }\n\n  /**\n   * retrieves the next token by ignoring whitespaces\n   */\n  public peekToken(): string {\n    let pos = this.position + 1;\n    while (pos < this.text.length && isspace(this.text.charAt(pos))) {\n      pos += 1;\n    }\n    return this.text.charAt(pos);\n  }\n\n  /**\n   * skips all whitepsace in sequence\n   */\n  private ignore_whitespace(advance: boolean = true) {\n    if (advance) {\n      // stop at next token\n      while (this.current_char && isspace(this.current_char)) {\n        this.advance();\n      }\n    } else {\n      // stop before next token\n      let current = this.peek();\n      while (current && isspace(current)) {\n        this.advance();\n      }\n    }\n  }\n\n  /**\n   * converts numeric character sequence into a token\n   */\n  private tokenize_number(): number {\n    let result = this.current_char || \"\";\n    let next = this.peek();\n    // capture integer\n    while (next && isdigit(next)) {\n      this.advance();\n      result += this.current_char;\n      next = this.peek();\n    }\n\n    // check if decimal point\n    if (next && next == \".\") {\n      let tmpNext = this.peek(2);\n      this.advance();\n      // make sure next character is a digit, not an elipses or something like '1.'\n      if (tmpNext && isdigit(tmpNext)) {\n        result += this.current_char;\n        next = this.peek();\n\n        // append numbers after decimal point\n        while (next && isdigit(next)) {\n          this.advance();\n          result += this.current_char;\n          next = this.peek();\n        }\n      }\n    }\n\n    // convert to number and return\n    return Number(result);\n  }\n\n  /**\n   * retrieves next token in string\n   */\n  public next_token(): Token {\n    this.advance();\n    let token = this.tokenize();\n    return token;\n  }\n\n  /**\n   * compares characters and matches with associated token\n   */\n  private tokenize(): Token {\n    // ignore all spaces\n    if (this.current_char && isspace(this.current_char)) {\n      this.ignore_whitespace();\n    }\n\n    // check if no more characters\n    if (!this.current_char) {\n      return { type: TokenType.eof, value: \"eof\" };\n    }\n\n    if (isdigit(this.current_char)) {\n      // capture numeric token\n      return { type: TokenType.num, value: this.tokenize_number() };\n    } else if (isalnum(this.current_char)) {\n      return this._id();\n    } else if (this.current_char == \"+\") {\n      return newToken(TokenType.plus);\n    } else if (this.current_char == \"-\") {\n      return newToken(TokenType.minus);\n    } else if (this.current_char == \"*\") {\n      return newToken(TokenType.mul);\n    } else if (this.current_char == \"/\") {\n      // check if token is rdiv\n      let next = this.peek();\n      if (next && next == \"/\") {\n        this.advance();\n        return newToken(TokenType.rdiv);\n      }\n      return newToken(TokenType.div);\n    } else if (this.current_char == \"(\") {\n      return newToken(TokenType.lparen);\n    } else if (this.current_char == \")\") {\n      return newToken(TokenType.rparen);\n    } else if (this.current_char == \"[\") {\n      return newToken(TokenType.lbracket);\n    } else if (this.current_char == \"]\") {\n      return newToken(TokenType.rbracket);\n    } else if (this.current_char == \"<\") {\n      return newToken(TokenType.larrow);\n    } else if (this.current_char == \">\") {\n      return newToken(TokenType.rarrow);\n    } else if (this.current_char == \";\") {\n      return newToken(TokenType.semicolon);\n    } else if (this.current_char == \",\") {\n      return newToken(TokenType.comma);\n    } else if (this.current_char == \"=\" && this.peek() != \"=\") {\n      return newToken(TokenType.assign);\n    } else if (this.current_char == \".\" && this.peek() != \".\") {\n      return newToken(TokenType.dot);\n    } else if (this.current_char == \"\\n\") {\n      return newToken(TokenType.endl);\n    } else if (this.current_char == \"^\") {\n      return newToken(TokenType.pow);\n    } else if (this.current_char == \"&\") {\n      // check if token is boolean and\n      let next = this.peek();\n      if (next && next == \"&\") {\n        this.advance();\n        return newToken(TokenType.and_bool);\n      }\n      return newToken(TokenType.and);\n    } else if (this.current_char == \"|\") {\n      // check if token is rdiv\n      let next = this.peek();\n      if (next && next == \"|\") {\n        this.advance();\n        return newToken(TokenType.or_bool);\n      }\n      return newToken(TokenType.or);\n    }\n\n    // token wasn't recognized\n    throw new SymbolError(\"unexpected token: `\" + this.current_char + \"`\");\n  }\n}\n"]},"metadata":{},"sourceType":"module"}