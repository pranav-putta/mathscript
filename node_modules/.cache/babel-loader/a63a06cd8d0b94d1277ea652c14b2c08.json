{"ast":null,"code":"import { Computable } from \".\";\nimport { MatrixError, ParsingError } from \"../errors\";\nexport class Matrix extends Computable {\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(nodes = undefined, rows = undefined) {\n    super();\n    this.matrix = void 0;\n    this.nodes = void 0;\n    this.dimR = void 0;\n    this.dimC = void 0;\n\n    if (!rows && nodes) {\n      // raw node matrix\n      this.nodes = nodes;\n      this.matrix = undefined;\n      this.dimR = nodes.length;\n      this.dimC = this.dimR > 0 ? nodes[0].length : 0; // verify each row is the same length\n\n      for (let row of nodes) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    } else if (rows) {\n      // populate matrix with numbers\n      this.nodes = undefined;\n      this.matrix = rows;\n      this.dimR = rows.length;\n      this.dimC = this.dimR > 0 ? rows[0].length : 0; // verify each row is the same length\n\n      for (let row of rows) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    } else {\n      throw new ParsingError(\"expected a matrix or nodes\");\n    }\n  }\n\n  checkDimensions(other) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(`can't add matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n    }\n  }\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n\n\n  add(other) {\n    if (this.matrix) {\n      let arr = new Array();\n\n      if (Computable.isMatrix(other) && other.matrix) {\n        // add two matricies together\n        this.checkDimensions(other);\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] + other.matrix[i][j]);\n          }\n        }\n      } else if (Computable.isNumeric(other)) {\n        // add constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] + other);\n          }\n        }\n      }\n\n      return {\n        result: new Matrix(undefined, arr)\n      };\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n\n\n  sub(other) {\n    if (this.matrix) {\n      let arr = new Array();\n\n      if (Computable.isMatrix(other) && other.matrix) {\n        // subtract two matricies together\n        this.checkDimensions(other);\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] - other.matrix[i][j]);\n          }\n        }\n      } else if (Computable.isNumeric(other)) {\n        // subtract constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] - other);\n          }\n        }\n      }\n\n      return {\n        result: new Matrix(undefined, arr)\n      };\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n\n\n  el_mul(other) {\n    if (this.matrix && other.matrix) {\n      if (this.dimC == other.dimC && this.dimR == other.dimR) {\n        let arr = new Array();\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] * other.matrix[i][j]);\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      } else {\n        throw new MatrixError(\"cannot do element-wise multiplication on different sized matricies\");\n      }\n    }\n\n    throw new ParsingError(\"matrix hasn't been evaulated yet!\");\n  }\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n\n\n  mul(other) {\n    if (this.matrix) {\n      if (Computable.isMatrix(other)) {\n        if (other.matrix) {\n          // multiply two matricies\n          // check dimensions are proper\n          if (this.dimC != other.dimR) {\n            if (this.dimC == other.dimC && this.dimR == other.dimR) {\n              return {\n                result: this.mul(other.transpose().result).result,\n                message: \"inferred to take dot product.\"\n              };\n            }\n\n            throw new MatrixError(`can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n          }\n\n          let newMatrix = new Array();\n\n          for (let i = 0; i < this.dimR; i++) {\n            newMatrix.push([]);\n\n            for (let j = 0; j < other.dimC; j++) {\n              let temp = 0;\n\n              for (let k = 0; k < this.dimC; k++) {\n                temp += this.matrix[i][k] * other.matrix[k][j];\n              }\n\n              newMatrix[i].push(temp);\n            }\n          }\n\n          if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n            return {\n              result: newMatrix[0][0]\n            };\n          } else {\n            return {\n              result: new Matrix(undefined, newMatrix)\n            };\n          }\n        }\n      } else if (Computable.isNumeric(other)) {\n        let arr = new Array(); // multiply constant to each element\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] * other);\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      } else {\n        throw new MatrixError(\"couldn't multiply with a \" + other);\n      }\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  div(other) {\n    if (this.matrix) {\n      if (Computable.isNumeric(other)) {\n        let arr = new Array(); // multiply constant to each element\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] / other);\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      }\n\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  rdiv(other) {\n    if (this.matrix) {\n      if (Computable.isNumeric(other)) {\n        let arr = new Array(); // multiply constant to each element\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(Math.floor(this.matrix[i][j] / other));\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      }\n\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * take power\n   * @param other\n   */\n\n\n  pow(other) {\n    if (this.matrix) {\n      if (this.dimR != this.dimC) {\n        throw new MatrixError(\"only square matricies can be raised to the power\");\n      }\n\n      if (Computable.isNumeric(other)) {\n        let newMatrix = this;\n\n        for (let i = 0; i < other; i++) {\n          let tmp = newMatrix.mul(this).result;\n\n          if (Computable.isMatrix(tmp)) {\n            newMatrix = tmp;\n          } else {\n            throw new MatrixError(\"multiplication failed: \" + tmp);\n          }\n        }\n\n        return {\n          result: newMatrix\n        };\n      } else {\n        throw new MatrixError(\"matrix power is not supported\");\n      }\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * evaluates matrix from raw nodes\n   */\n\n\n  evaluate() {\n    if (!this.matrix) {\n      let arr = new Array();\n\n      for (let row = 0; row < this.dimR; row++) {\n        arr.push([]);\n\n        for (let col = 0; col < this.dimC; col++) {\n          let val = this.nodes[row][col].eval();\n\n          if (Computable.isNumeric(val)) {\n            arr[row].push(val);\n          } else {\n            throw new SyntaxError(\"couldn't evaluate matrix! expected numbers.\");\n          }\n        }\n      }\n\n      this.matrix = arr;\n    }\n  }\n\n  transpose(save = false) {\n    if (this.matrix) {\n      let arr = new Array();\n\n      for (let i = 0; i < this.dimC; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimR; j++) {\n          arr[i].push(this.matrix[j][i]);\n        }\n      }\n\n      if (save) {\n        this.matrix = arr;\n        let tmp = this.dimR;\n        this.dimR = this.dimC;\n        this.dimC = tmp;\n        return {\n          result: this\n        };\n      }\n\n      return {\n        result: new Matrix(undefined, arr)\n      };\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet!\");\n  }\n\n  determinant() {\n    if (this.matrix) {\n      if (this.dimR != this.dimC) {\n        throw new MatrixError(\"cannot take determinant of non-square matrix\");\n      }\n\n      let n = this.dimR;\n      let M = this.matrix;\n\n      if (n == 2) {\n        return M[0][0] * M[1][1] - M[0][1] * M[1][0];\n      } else {\n        let d = 0;\n\n        for (let i = 0; i < n; i++) {\n          // create a sub matrix\n          let subMatrix = [];\n\n          for (let r = 0; r < n; r++) {\n            subMatrix.push([]);\n\n            for (let c = 0; c < n; c++) {\n              if (c != i) {\n                subMatrix[r].push(this.matrix[r][c]);\n              }\n            }\n          }\n\n          d += M[0][i] * new Matrix(undefined, subMatrix).determinant();\n        }\n      }\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet!\");\n  }\n\n  subMatrix(startRow, endRow = this.dimR - 1, startCol, endCol = this.dimC - 1) {\n    if (this.matrix) {\n      let arr = new Array();\n\n      for (let i = startRow; i <= endRow; i++) {\n        arr.push([]);\n\n        for (let j = startCol; j <= endCol; j++) {\n          arr[i].push(this.matrix[i][j]);\n        }\n      }\n\n      return new Matrix(undefined, arr);\n    } else {\n      throw new ParsingError(\"matrix has not been evaluated yet!\");\n    }\n  }\n\n  toString() {\n    let m = this.matrix;\n\n    if (m) {\n      let str = \"\";\n\n      if (m.length == 1) {\n        str += \"< \";\n\n        for (let i = 0; i < this.dimC; i++) {\n          str += m[0][i];\n\n          if (i != m[0].length - 1) {\n            str += \" \";\n          }\n        }\n\n        str += \" >\";\n      } else {\n        str += \"[\";\n\n        for (let i = 0; i < this.dimR; i++) {\n          if (i != 0) {\n            str += \" \";\n          }\n\n          str += \"[ \";\n\n          for (let j = 0; j < this.dimC; j++) {\n            str += m[i][j] + \" \";\n          }\n\n          str += \"]\";\n\n          if (i != this.dimR - 1) {\n            str += \"\\n\";\n          }\n        }\n\n        str += \"]\";\n        str += `  { ${this.dimR} x ${this.dimC} }`;\n      }\n\n      return str;\n    } else {\n      throw new ParsingError(\"matrix has not been evaluated yet!\");\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/computable/matrix.ts"],"names":["Computable","MatrixError","ParsingError","Matrix","constructor","nodes","undefined","rows","matrix","dimR","dimC","length","row","checkDimensions","other","add","arr","Array","isMatrix","i","push","j","isNumeric","result","sub","el_mul","mul","transpose","message","newMatrix","temp","k","div","rdiv","Math","floor","pow","tmp","evaluate","col","val","eval","SyntaxError","save","determinant","n","M","d","subMatrix","r","c","startRow","endRow","startCol","endCol","toString","m","str"],"mappings":"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","sourcesContent":["import { Computable, Result } from \".\";\nimport { ComputableNode } from \"../ast\";\nimport { MatrixError, ParsingError } from \"../errors\";\n\nexport class Matrix extends Computable {\n  matrix: number[][] | undefined;\n  nodes: ComputableNode[][] | undefined;\n  dimR: number;\n  dimC: number;\n\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(\n    nodes: ComputableNode[][] | undefined = undefined,\n    rows: number[][] | undefined = undefined\n  ) {\n    super();\n    if (!rows && nodes) {\n      // raw node matrix\n      this.nodes = nodes;\n      this.matrix = undefined;\n      this.dimR = nodes.length;\n      this.dimC = this.dimR > 0 ? nodes[0].length : 0;\n\n      // verify each row is the same length\n      for (let row of nodes) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    } else if (rows) {\n      // populate matrix with numbers\n      this.nodes = undefined;\n      this.matrix = rows;\n      this.dimR = rows.length;\n      this.dimC = this.dimR > 0 ? rows[0].length : 0;\n\n      // verify each row is the same length\n      for (let row of rows) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    } else {\n      throw new ParsingError(\"expected a matrix or nodes\");\n    }\n  }\n\n  private checkDimensions(other: Matrix) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(\n        `can't add matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n      );\n    }\n  }\n\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n  public add(other: Computable): MatrixResult {\n    if (this.matrix) {\n      let arr: number[][] = new Array();\n      if (Computable.isMatrix(other) && other.matrix) {\n        // add two matricies together\n        this.checkDimensions(other);\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] + other.matrix[i][j]);\n          }\n        }\n      } else if (Computable.isNumeric(other)) {\n        // add constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] + other);\n          }\n        }\n      }\n\n      return { result: new Matrix(undefined, arr) };\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n  public sub(other: Computable): MatrixResult {\n    if (this.matrix) {\n      let arr: number[][] = new Array();\n\n      if (Computable.isMatrix(other) && other.matrix) {\n        // subtract two matricies together\n        this.checkDimensions(other);\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] - other.matrix[i][j]);\n          }\n        }\n      } else if (Computable.isNumeric(other)) {\n        // subtract constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] - other);\n          }\n        }\n      }\n\n      return { result: new Matrix(undefined, arr) };\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n  public el_mul(other: Matrix): MatrixResult {\n    if (this.matrix && other.matrix) {\n      if (this.dimC == other.dimC && this.dimR == other.dimR) {\n        let arr: number[][] = new Array();\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] * other.matrix[i][j]);\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      } else {\n        throw new MatrixError(\n          \"cannot do element-wise multiplication on different sized matricies\"\n        );\n      }\n    }\n\n    throw new ParsingError(\"matrix hasn't been evaulated yet!\");\n  }\n\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n  public mul(other: Computable): Result {\n    if (this.matrix) {\n      if (Computable.isMatrix(other)) {\n        if (other.matrix) {\n          // multiply two matricies\n          // check dimensions are proper\n          if (this.dimC != other.dimR) {\n            if (this.dimC == other.dimC && this.dimR == other.dimR) {\n              return {\n                result: this.mul(other.transpose().result).result,\n                message: \"inferred to take dot product.\",\n              };\n            }\n            throw new MatrixError(\n              `can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n            );\n          }\n          let newMatrix: number[][] = new Array();\n          for (let i = 0; i < this.dimR; i++) {\n            newMatrix.push([]);\n            for (let j = 0; j < other.dimC; j++) {\n              let temp = 0;\n              for (let k = 0; k < this.dimC; k++) {\n                temp += this.matrix[i][k] * other.matrix[k][j];\n              }\n              newMatrix[i].push(temp);\n            }\n          }\n          if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n            return { result: newMatrix[0][0] };\n          } else {\n            return { result: new Matrix(undefined, newMatrix) };\n          }\n        }\n      } else if (Computable.isNumeric(other)) {\n        let arr: number[][] = new Array();\n        // multiply constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] * other);\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      } else {\n        throw new MatrixError(\"couldn't multiply with a \" + other);\n      }\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public div(other: Computable): MatrixResult {\n    if (this.matrix) {\n      if (Computable.isNumeric(other)) {\n        let arr: number[][] = new Array();\n        // multiply constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] / other);\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      }\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public rdiv(other: Computable): MatrixResult {\n    if (this.matrix) {\n      if (Computable.isNumeric(other)) {\n        let arr: number[][] = new Array();\n        // multiply constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(Math.floor(this.matrix[i][j] / other));\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      }\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * take power\n   * @param other\n   */\n  public pow(other: Computable): MatrixResult {\n    if (this.matrix) {\n      if (this.dimR != this.dimC) {\n        throw new MatrixError(\n          \"only square matricies can be raised to the power\"\n        );\n      }\n      if (Computable.isNumeric(other)) {\n        let newMatrix: Matrix = this;\n        for (let i = 0; i < other; i++) {\n          let tmp = newMatrix.mul(this).result;\n          if (Computable.isMatrix(tmp)) {\n            newMatrix = tmp;\n          } else {\n            throw new MatrixError(\"multiplication failed: \" + tmp);\n          }\n        }\n        return { result: newMatrix };\n      } else {\n        throw new MatrixError(\"matrix power is not supported\");\n      }\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * evaluates matrix from raw nodes\n   */\n  public evaluate() {\n    if (!this.matrix) {\n      let arr: number[][] = new Array();\n      for (let row = 0; row < this.dimR; row++) {\n        arr.push([]);\n        for (let col = 0; col < this.dimC; col++) {\n          let val = this.nodes[row][col].eval();\n          if (Computable.isNumeric(val)) {\n            arr[row].push(val);\n          } else {\n            throw new SyntaxError(\n              \"couldn't evaluate matrix! expected numbers.\"\n            );\n          }\n        }\n      }\n      this.matrix = arr;\n    }\n  }\n\n  public transpose(save: boolean = false): MatrixResult {\n    if (this.matrix) {\n      let arr: number[][] = new Array();\n      for (let i = 0; i < this.dimC; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimR; j++) {\n          arr[i].push(this.matrix[j][i]);\n        }\n      }\n\n      if (save) {\n        this.matrix = arr;\n        let tmp = this.dimR;\n        this.dimR = this.dimC;\n        this.dimC = tmp;\n        return { result: this };\n      }\n      return { result: new Matrix(undefined, arr) };\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet!\");\n  }\n\n  public determinant(): number {\n    if (this.matrix) {\n      if (this.dimR != this.dimC) {\n        throw new MatrixError(\"cannot take determinant of non-square matrix\");\n      }\n\n      let n = this.dimR;\n      let M = this.matrix;\n      if (n == 2) {\n        return M[0][0] * M[1][1] - M[0][1] * M[1][0];\n      } else {\n        let d = 0;\n        for (let i = 0; i < n; i++) {\n          // create a sub matrix\n          let subMatrix: number[][] = [];\n          for (let r = 0; r < n; r++) {\n            subMatrix.push([]);\n            for (let c = 0; c < n; c++) {\n              if (c != i) {\n                subMatrix[r].push(this.matrix[r][c]);\n              }\n            }\n          }\n\n          d += M[0][i] * new Matrix(undefined, subMatrix).determinant();\n        }\n      }\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet!\");\n  }\n\n  public subMatrix(\n    startRow: number,\n    endRow: number = this.dimR - 1,\n    startCol: number,\n    endCol: number = this.dimC - 1\n  ): Matrix {\n    if (this.matrix) {\n      let arr: number[][] = new Array();\n      for (let i = startRow; i <= endRow; i++) {\n        arr.push([]);\n        for (let j = startCol; j <= endCol; j++) {\n          arr[i].push(this.matrix[i][j]);\n        }\n      }\n      return new Matrix(undefined, arr);\n    } else {\n      throw new ParsingError(\"matrix has not been evaluated yet!\");\n    }\n  }\n\n  public toString(): string {\n    let m = this.matrix;\n    if (m) {\n      let str = \"\";\n      if (m.length == 1) {\n        str += \"< \";\n        for (let i = 0; i < this.dimC; i++) {\n          str += m[0][i];\n          if (i != m[0].length - 1) {\n            str += \" \";\n          }\n        }\n        str += \" >\";\n      } else {\n        str += \"[\";\n        for (let i = 0; i < this.dimR; i++) {\n          if (i != 0) {\n            str += \" \";\n          }\n          str += \"[ \";\n          for (let j = 0; j < this.dimC; j++) {\n            str += m[i][j] + \" \";\n          }\n          str += \"]\";\n          if (i != this.dimR - 1) {\n            str += \"\\n\";\n          }\n        }\n        str += \"]\";\n        str += `  { ${this.dimR} x ${this.dimC} }`;\n      }\n\n      return str;\n    } else {\n      throw new ParsingError(\"matrix has not been evaluated yet!\");\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}