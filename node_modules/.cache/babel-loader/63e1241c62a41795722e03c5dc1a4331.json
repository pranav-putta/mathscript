{"ast":null,"code":"import { ArithmeticError, MatrixError } from \"./errors\";\nimport { TokenType } from \"./token\";\nexport class Computable {}\n/**\n * checks if given element is of type computable\n * @param el any element\n */\n\nexport function isComputable(el) {\n  return el instanceof Computable;\n}\nexport function computeResult(a, b, operator) {\n  switch (operator) {\n    case TokenType.plus:\n      return a.add(b);\n\n    case TokenType.minus:\n      return a.sub(b);\n\n    case TokenType.mul:\n      return a.mul(b);\n\n    case TokenType.div:\n      return a.div(b);\n\n    case TokenType.rdiv:\n      return a.rdiv(b);\n  }\n\n  if (isLogical(a) && isLogical(b)) {\n    switch (operator) {\n      case TokenType.and_bool:\n        return a.and(b);\n\n      case TokenType.or_bool:\n        return a.or(b);\n    }\n  }\n\n  throw new ArithmeticError(\"unsupported operation \" + operator.toString());\n}\nexport class UnevaluatedMatrix {\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(nodes) {\n    this.matrix = void 0;\n    this.dimR = void 0;\n    this.dimC = void 0;\n    // raw node matrix\n    this.matrix = nodes;\n    this.dimR = nodes.length;\n    this.dimC = this.dimR > 0 ? nodes[0].length : 0; // verify each row is the same length\n\n    for (let row of nodes) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n  /**\n   * evaluates matrix from raw nodes\n   */\n\n\n  evaluate() {\n    let arr = new Array();\n\n    for (let row = 0; row < this.dimR; row++) {\n      arr.push([]);\n\n      for (let col = 0; col < this.dimC; col++) {\n        let val = this.matrix[row][col].eval();\n\n        if (isNumeric(val)) {\n          arr[row].push(val.value);\n        } else {\n          throw new SyntaxError(\"couldn't evaluate matrix! expected numbers.\");\n        }\n      }\n    }\n\n    return new Matrix(arr);\n  }\n\n  static isUnevaluatedMatrix(m) {\n    return m instanceof UnevaluatedMatrix;\n  }\n\n}\nexport class Matrix extends Computable {\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(rows) {\n    super();\n    this.matrix = void 0;\n    this.dimR = void 0;\n    this.dimC = void 0;\n    this.matrix = rows;\n    this.dimR = rows.length;\n    this.dimC = this.dimR > 0 ? rows[0].length : 0; // verify each row is the same length\n\n    for (let row of rows) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n\n  checkDimensions(other) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(`can't perform operations on matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n    }\n  }\n\n  expectedMatrixError() {\n    throw new ArithmeticError(\"expected a matrix for calculations.\");\n  }\n\n  expectedMatrixOrNumericError() {\n    throw new ArithmeticError(\"expected a matrix or numeric for calculations.\");\n  }\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n\n\n  add(other) {\n    let arr = new Array();\n\n    if (isMatrix(other)) {\n      // add two matricies together\n      this.checkDimensions(other);\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // add constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return {\n      result: new Matrix(arr)\n    };\n  }\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n\n\n  sub(other) {\n    let arr = new Array();\n\n    if (isMatrix(other)) {\n      // subtract two matricies together\n      this.checkDimensions(other);\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // subtract constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return {\n      result: new Matrix(arr)\n    };\n  }\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n\n\n  el_mul(other) {\n    if (this.dimC == other.dimC && this.dimR == other.dimR) {\n      let arr = new Array();\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.matrix[i][j]);\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    } else {\n      throw new MatrixError(\"cannot do element-wise multiplication on different sized matricies\");\n    }\n  }\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n\n\n  mul(other) {\n    if (isMatrix(other)) {\n      // multiply two matricies\n      // check dimensions are proper\n      if (this.dimC != other.dimR) {\n        if (this.dimC == other.dimC && this.dimR == other.dimR) {\n          return {\n            result: this.mul(other.transpose().result).result,\n            message: \"inferred to take dot product.\"\n          };\n        }\n\n        throw new MatrixError(`can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n      }\n\n      let newMatrix = new Array();\n\n      for (let i = 0; i < this.dimR; i++) {\n        newMatrix.push([]);\n\n        for (let j = 0; j < other.dimC; j++) {\n          let temp = 0;\n\n          for (let k = 0; k < this.dimC; k++) {\n            temp += this.matrix[i][k] * other.matrix[k][j];\n          }\n\n          newMatrix[i].push(temp);\n        }\n\n        if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n          return {\n            result: new Numeric(newMatrix[0][0])\n          };\n        } else {\n          return {\n            result: new Matrix(newMatrix)\n          };\n        }\n      }\n    } else if (isNumeric(other)) {\n      let arr = new Array(); // multiply constant to each element\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.value);\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    }\n\n    this.expectedMatrixOrNumericError();\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  div(other) {\n    if (isNumeric(other)) {\n      let arr = new Array(); // multiply constant to each element\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] / other.value);\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    }\n\n    this.expectedMatrixError();\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  rdiv(other) {\n    if (isNumeric(other)) {\n      let arr = new Array(); // multiply constant to each element\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(Math.floor(this.matrix[i][j] / other.value));\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    }\n\n    this.expectedMatrixError();\n  }\n  /**\n   * take power\n   * @param other\n   */\n\n\n  pow(other) {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"only square matricies can be raised to the power\");\n    }\n\n    if (isNumeric(other)) {\n      let newMatrix = this;\n\n      for (let i = 0; i < other.value; i++) {\n        let tmp = newMatrix.mul(this).result;\n\n        if (isMatrix(tmp)) {\n          newMatrix = tmp;\n        } else {\n          throw new MatrixError(\"multiplication failed: \" + tmp);\n        }\n      }\n\n      return {\n        result: newMatrix\n      };\n    } else {\n      throw new MatrixError(\"matrix power is not supported\");\n    }\n  }\n\n  transpose(save = false) {\n    let arr = new Array();\n\n    for (let i = 0; i < this.dimC; i++) {\n      arr.push([]);\n\n      for (let j = 0; j < this.dimR; j++) {\n        arr[i].push(this.matrix[j][i]);\n      }\n    }\n\n    if (save) {\n      this.matrix = arr;\n      let tmp = this.dimR;\n      this.dimR = this.dimC;\n      this.dimC = tmp;\n      return {\n        result: this\n      };\n    }\n\n    return {\n      result: new Matrix(arr)\n    };\n  }\n\n  determinant() {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"cannot take determinant of non-square matrix\");\n    }\n\n    let n = this.dimR;\n    let M = this.matrix;\n\n    if (n == 2) {\n      return M[0][0] * M[1][1] - M[0][1] * M[1][0];\n    } else {\n      let d = 0;\n\n      for (let i = 0; i < n; i++) {\n        // create a sub matrix\n        let subMatrix = [];\n\n        for (let r = 0; r < n; r++) {\n          subMatrix.push([]);\n\n          for (let c = 0; c < n; c++) {\n            if (c != i) {\n              subMatrix[r].push(this.matrix[r][c]);\n            }\n          }\n        }\n\n        d += M[0][i] * new Matrix(subMatrix).determinant();\n      }\n\n      return d;\n    }\n  }\n\n  subMatrix(startRow, endRow = this.dimR - 1, startCol, endCol = this.dimC - 1) {\n    let arr = new Array();\n\n    for (let i = startRow; i <= endRow; i++) {\n      arr.push([]);\n\n      for (let j = startCol; j <= endCol; j++) {\n        arr[i].push(this.matrix[i][j]);\n      }\n    }\n\n    return new Matrix(arr);\n  }\n\n  toString() {\n    let m = this.matrix;\n    let str = \"\";\n\n    if (m.length == 1) {\n      str += \"< \";\n\n      for (let i = 0; i < this.dimC; i++) {\n        str += m[0][i];\n\n        if (i != m[0].length - 1) {\n          str += \" \";\n        }\n      }\n\n      str += \" >\";\n    } else {\n      str += \"[\";\n\n      for (let i = 0; i < this.dimR; i++) {\n        if (i != 0) {\n          str += \" \";\n        }\n\n        str += \"[ \";\n\n        for (let j = 0; j < this.dimC; j++) {\n          str += m[i][j] + \" \";\n        }\n\n        str += \"]\";\n\n        if (i != this.dimR - 1) {\n          str += \"\\n\";\n        }\n      }\n\n      str += \"]\";\n      str += `  { ${this.dimR} x ${this.dimC} }`;\n    }\n\n    return str;\n  }\n\n}\nexport function isMatrix(el) {\n  return el instanceof Matrix;\n}\nexport class Numeric extends Computable {\n  constructor(val) {\n    super();\n    this.value = void 0;\n    this.value = val;\n  }\n\n  error() {\n    throw new ArithmeticError(\"cannot add numeric with non-numeric\");\n  }\n\n  add(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value + other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.add(this);\n    }\n\n    this.error();\n  }\n\n  sub(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value - other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.sub(this);\n    }\n\n    this.error();\n  }\n\n  mul(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value * other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.mul(this);\n    }\n\n    this.error();\n  }\n\n  div(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value / other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.div(this);\n    }\n\n    this.error();\n  }\n\n  rdiv(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(Math.floor(this.value / other.value))\n      };\n    } else if (isMatrix(other)) {\n      return other.rdiv(this);\n    }\n\n    this.error();\n  }\n\n  pow(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(Math.pow(this.value, other.value))\n      };\n    }\n\n    this.error();\n  }\n\n  toString() {\n    return this.value.toString();\n  }\n\n}\nexport function isNumeric(el) {\n  return el instanceof Numeric;\n}\n\n/**\n * boolean computable value\n */\nexport class Logical extends Numeric {\n  constructor(value) {\n    super(value ? 1 : 0);\n    this.boolVal = void 0;\n    this.boolVal = value;\n  }\n\n  add(other) {\n    return other.add(new Numeric(this.value));\n  }\n\n  sub(other) {\n    return other.add(new Numeric(this.value * -1));\n  }\n\n  mul(other) {\n    return other.mul(new Numeric(this.value));\n  }\n\n  div(other) {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  rdiv(other) {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  pow(other) {\n    throw new ArithmeticError(\"boolean powers not supported\");\n  }\n\n  or(other) {\n    return {\n      result: new Logical(this.boolVal || other.boolVal)\n    };\n  }\n\n  and(other) {\n    return {\n      result: new Logical(this.boolVal && other.boolVal)\n    };\n  }\n\n  xor(other) {\n    return {\n      result: new Logical(this.boolVal !== other.boolVal)\n    };\n  }\n\n  nand(other) {\n    return {\n      result: new Logical(this.boolVal == other.boolVal && !this.boolVal)\n    };\n  }\n\n  toString() {\n    return new String(this.boolVal).toString();\n  }\n\n}\nexport function isLogical(el) {\n  return el instanceof Logical;\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/computable.ts"],"names":["ArithmeticError","MatrixError","TokenType","Computable","isComputable","el","computeResult","a","b","operator","plus","add","minus","sub","mul","div","rdiv","isLogical","and_bool","and","or_bool","or","toString","UnevaluatedMatrix","constructor","nodes","matrix","dimR","dimC","length","row","evaluate","arr","Array","push","col","val","eval","isNumeric","value","SyntaxError","Matrix","isUnevaluatedMatrix","m","rows","checkDimensions","other","expectedMatrixError","expectedMatrixOrNumericError","isMatrix","i","j","result","el_mul","transpose","message","newMatrix","temp","k","Numeric","Math","floor","pow","tmp","save","determinant","n","M","d","subMatrix","r","c","startRow","endRow","startCol","endCol","str","error","Logical","boolVal","xor","nand","String"],"mappings":"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","sourcesContent":["import { ComputableNode } from \"./ast\";\nimport { ArithmeticError, MatrixError } from \"./errors\";\nimport { TokenType } from \"./token\";\n\nexport interface Result {\n  result: Computable;\n  message?: string;\n}\n\nexport abstract class Computable {\n  public abstract add(other: Computable): Result;\n  public abstract sub(other: Computable): Result;\n  public abstract mul(other: Computable): Result;\n  public abstract div(other: Computable): Result;\n  public abstract rdiv(other: Computable): Result;\n  public abstract pow(other: Computable): Result;\n}\n\n/**\n * checks if given element is of type computable\n * @param el any element\n */\nexport function isComputable(el: any): el is Computable {\n  return el instanceof Computable;\n}\n\nexport function computeResult(\n  a: Computable,\n  b: Computable,\n  operator: TokenType\n): Result {\n  switch (operator) {\n    case TokenType.plus:\n      return a.add(b);\n    case TokenType.minus:\n      return a.sub(b);\n    case TokenType.mul:\n      return a.mul(b);\n    case TokenType.div:\n      return a.div(b);\n    case TokenType.rdiv:\n      return a.rdiv(b);\n  }\n  if (isLogical(a) && isLogical(b)) {\n    switch (operator) {\n      case TokenType.and_bool:\n        return a.and(b);\n      case TokenType.or_bool:\n        return a.or(b);\n    }\n  }\n  throw new ArithmeticError(\"unsupported operation \" + operator.toString());\n}\n\nexport interface MatrixResult extends Result {\n  result: Matrix;\n}\n\nexport class UnevaluatedMatrix {\n  private matrix: ComputableNode[][];\n  private dimR: number;\n  private dimC: number;\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(nodes: ComputableNode[][]) {\n    // raw node matrix\n    this.matrix = nodes;\n    this.dimR = nodes.length;\n    this.dimC = this.dimR > 0 ? nodes[0].length : 0;\n\n    // verify each row is the same length\n    for (let row of nodes) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n\n  /**\n   * evaluates matrix from raw nodes\n   */\n  public evaluate(): Matrix {\n    let arr: number[][] = new Array();\n    for (let row = 0; row < this.dimR; row++) {\n      arr.push([]);\n      for (let col = 0; col < this.dimC; col++) {\n        let val = this.matrix[row][col].eval();\n        if (isNumeric(val)) {\n          arr[row].push(val.value);\n        } else {\n          throw new SyntaxError(\"couldn't evaluate matrix! expected numbers.\");\n        }\n      }\n    }\n    return new Matrix(arr);\n  }\n\n  public static isUnevaluatedMatrix(m: any): m is UnevaluatedMatrix {\n    return m instanceof UnevaluatedMatrix;\n  }\n}\n\nexport class Matrix extends Computable {\n  matrix: number[][];\n  dimR: number;\n  dimC: number;\n\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(rows: number[][]) {\n    super();\n\n    this.matrix = rows;\n    this.dimR = rows.length;\n    this.dimC = this.dimR > 0 ? rows[0].length : 0;\n\n    // verify each row is the same length\n    for (let row of rows) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n\n  private checkDimensions(other: Matrix) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(\n        `can't perform operations on matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n      );\n    }\n  }\n\n  private expectedMatrixError(): never {\n    throw new ArithmeticError(\"expected a matrix for calculations.\");\n  }\n\n  private expectedMatrixOrNumericError(): never {\n    throw new ArithmeticError(\"expected a matrix or numeric for calculations.\");\n  }\n\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n  public add(other: Computable): MatrixResult {\n    let arr: number[][] = new Array();\n    if (isMatrix(other)) {\n      // add two matricies together\n      this.checkDimensions(other);\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // add constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return { result: new Matrix(arr) };\n  }\n\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n  public sub(other: Computable): MatrixResult {\n    let arr: number[][] = new Array();\n\n    if (isMatrix(other)) {\n      // subtract two matricies together\n      this.checkDimensions(other);\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // subtract constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return { result: new Matrix(arr) };\n  }\n\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n  public el_mul(other: Matrix): MatrixResult {\n    if (this.dimC == other.dimC && this.dimR == other.dimR) {\n      let arr: number[][] = new Array();\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.matrix[i][j]);\n        }\n      }\n      return { result: new Matrix(arr) };\n    } else {\n      throw new MatrixError(\n        \"cannot do element-wise multiplication on different sized matricies\"\n      );\n    }\n  }\n\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n  public mul(other: Computable): Result {\n    if (isMatrix(other)) {\n      // multiply two matricies\n      // check dimensions are proper\n      if (this.dimC != other.dimR) {\n        if (this.dimC == other.dimC && this.dimR == other.dimR) {\n          return {\n            result: this.mul(other.transpose().result).result,\n            message: \"inferred to take dot product.\",\n          };\n        }\n        throw new MatrixError(\n          `can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n        );\n      }\n      let newMatrix: number[][] = new Array();\n      for (let i = 0; i < this.dimR; i++) {\n        newMatrix.push([]);\n        for (let j = 0; j < other.dimC; j++) {\n          let temp = 0;\n          for (let k = 0; k < this.dimC; k++) {\n            temp += this.matrix[i][k] * other.matrix[k][j];\n          }\n          newMatrix[i].push(temp);\n        }\n\n        if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n          return { result: new Numeric(newMatrix[0][0]) };\n        } else {\n          return { result: new Matrix(newMatrix) };\n        }\n      }\n    } else if (isNumeric(other)) {\n      let arr: number[][] = new Array();\n      // multiply constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.value);\n        }\n      }\n      return { result: new Matrix(arr) };\n    }\n    this.expectedMatrixOrNumericError();\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public div(other: Computable): MatrixResult {\n    if (isNumeric(other)) {\n      let arr: number[][] = new Array();\n      // multiply constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] / other.value);\n        }\n      }\n      return { result: new Matrix(arr) };\n    }\n    this.expectedMatrixError();\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public rdiv(other: Computable): MatrixResult {\n    if (isNumeric(other)) {\n      let arr: number[][] = new Array();\n      // multiply constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(Math.floor(this.matrix[i][j] / other.value));\n        }\n      }\n      return { result: new Matrix(arr) };\n    }\n    this.expectedMatrixError();\n  }\n\n  /**\n   * take power\n   * @param other\n   */\n  public pow(other: Computable): MatrixResult {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"only square matricies can be raised to the power\");\n    }\n    if (isNumeric(other)) {\n      let newMatrix: Matrix = this;\n      for (let i = 0; i < other.value; i++) {\n        let tmp = newMatrix.mul(this).result;\n        if (isMatrix(tmp)) {\n          newMatrix = tmp;\n        } else {\n          throw new MatrixError(\"multiplication failed: \" + tmp);\n        }\n      }\n      return { result: newMatrix };\n    } else {\n      throw new MatrixError(\"matrix power is not supported\");\n    }\n  }\n\n  public transpose(save: boolean = false): MatrixResult {\n    let arr: number[][] = new Array();\n    for (let i = 0; i < this.dimC; i++) {\n      arr.push([]);\n      for (let j = 0; j < this.dimR; j++) {\n        arr[i].push(this.matrix[j][i]);\n      }\n    }\n\n    if (save) {\n      this.matrix = arr;\n      let tmp = this.dimR;\n      this.dimR = this.dimC;\n      this.dimC = tmp;\n      return { result: this };\n    }\n    return { result: new Matrix(arr) };\n  }\n\n  public determinant(): number {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"cannot take determinant of non-square matrix\");\n    }\n\n    let n = this.dimR;\n    let M = this.matrix;\n    if (n == 2) {\n      return M[0][0] * M[1][1] - M[0][1] * M[1][0];\n    } else {\n      let d = 0;\n      for (let i = 0; i < n; i++) {\n        // create a sub matrix\n        let subMatrix: number[][] = [];\n        for (let r = 0; r < n; r++) {\n          subMatrix.push([]);\n          for (let c = 0; c < n; c++) {\n            if (c != i) {\n              subMatrix[r].push(this.matrix[r][c]);\n            }\n          }\n        }\n\n        d += M[0][i] * new Matrix(subMatrix).determinant();\n      }\n      return d;\n    }\n  }\n\n  public subMatrix(\n    startRow: number,\n    endRow: number = this.dimR - 1,\n    startCol: number,\n    endCol: number = this.dimC - 1\n  ): Matrix {\n    let arr: number[][] = new Array();\n    for (let i = startRow; i <= endRow; i++) {\n      arr.push([]);\n      for (let j = startCol; j <= endCol; j++) {\n        arr[i].push(this.matrix[i][j]);\n      }\n    }\n    return new Matrix(arr);\n  }\n\n  public toString(): string {\n    let m = this.matrix;\n    let str = \"\";\n    if (m.length == 1) {\n      str += \"< \";\n      for (let i = 0; i < this.dimC; i++) {\n        str += m[0][i];\n        if (i != m[0].length - 1) {\n          str += \" \";\n        }\n      }\n      str += \" >\";\n    } else {\n      str += \"[\";\n      for (let i = 0; i < this.dimR; i++) {\n        if (i != 0) {\n          str += \" \";\n        }\n        str += \"[ \";\n        for (let j = 0; j < this.dimC; j++) {\n          str += m[i][j] + \" \";\n        }\n        str += \"]\";\n        if (i != this.dimR - 1) {\n          str += \"\\n\";\n        }\n      }\n      str += \"]\";\n      str += `  { ${this.dimR} x ${this.dimC} }`;\n    }\n\n    return str;\n  }\n}\n\nexport function isMatrix(el: any): el is Matrix {\n  return el instanceof Matrix;\n}\n\nexport class Numeric extends Computable {\n  value: number;\n\n  constructor(val: number) {\n    super();\n    this.value = val;\n  }\n\n  private error(): never {\n    throw new ArithmeticError(\"cannot add numeric with non-numeric\");\n  }\n\n  public add(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value + other.value) };\n    } else if (isMatrix(other)) {\n      return other.add(this);\n    }\n    this.error();\n  }\n\n  public sub(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value - other.value) };\n    } else if (isMatrix(other)) {\n      return other.sub(this);\n    }\n    this.error();\n  }\n\n  public mul(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value * other.value) };\n    } else if (isMatrix(other)) {\n      return other.mul(this);\n    }\n    this.error();\n  }\n\n  public div(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value / other.value) };\n    } else if (isMatrix(other)) {\n      return other.div(this);\n    }\n    this.error();\n  }\n\n  public rdiv(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(Math.floor(this.value / other.value)) };\n    } else if (isMatrix(other)) {\n      return other.rdiv(this);\n    }\n    this.error();\n  }\n\n  public pow(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(Math.pow(this.value, other.value)) };\n    }\n    this.error();\n  }\n\n  public toString(): string {\n    return this.value.toString();\n  }\n}\n\nexport function isNumeric(el: any): el is Numeric {\n  return el instanceof Numeric;\n}\n\nexport interface LogicalResult extends Result {\n  result: Logical;\n}\n/**\n * boolean computable value\n */\nexport class Logical extends Numeric {\n  private boolVal: boolean;\n\n  constructor(value: boolean) {\n    super(value ? 1 : 0);\n    this.boolVal = value;\n  }\n\n  public add(other: Computable): Result {\n    return other.add(new Numeric(this.value));\n  }\n  public sub(other: Computable): Result {\n    return other.add(new Numeric(this.value * -1));\n  }\n  public mul(other: Computable): Result {\n    return other.mul(new Numeric(this.value));\n  }\n  public div(other: Computable): Result {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  public rdiv(other: Computable): Result {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n  public pow(other: Computable): Result {\n    throw new ArithmeticError(\"boolean powers not supported\");\n  }\n\n  public or(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal || other.boolVal) };\n  }\n\n  public and(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal && other.boolVal) };\n  }\n\n  public xor(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal !== other.boolVal) };\n  }\n\n  public nand(other: Logical): LogicalResult {\n    return {\n      result: new Logical(this.boolVal == other.boolVal && !this.boolVal),\n    };\n  }\n\n  public toString(): string {\n    return new String(this.boolVal).toString();\n  }\n}\n\nexport function isLogical(el: any): el is Logical {\n  return el instanceof Logical;\n}\n"]},"metadata":{},"sourceType":"module"}