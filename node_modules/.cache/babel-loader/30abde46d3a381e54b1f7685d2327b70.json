{"ast":null,"code":"import { AComputable } from \"./computable\";\nimport { ArgumentError } from \"./errors\";\n/**\n * \n * @param node \n */\n\nexport function rref(node) {\n  let matrix = node.eval();\n\n  if (AComputable.isMatrix(matrix) && matrix.rows) {\n    var lead = 0;\n\n    for (var k = 0; k < matrix.dimR; k++) {\n      if (matrix.dimC <= lead) return matrix;\n      var i = k;\n\n      while (matrix.rows[i][lead] === 0) {\n        i++;\n\n        if (matrix.dimR === i) {\n          i = k;\n          lead++;\n          if (matrix.dimC === lead) return matrix;\n        }\n      }\n\n      var irow = matrix.rows[i],\n          krow = matrix.rows[k];\n      matrix.rows[i] = krow, matrix.rows[k] = irow;\n      var val = matrix.rows[k][lead];\n\n      for (var j = 0; j < matrix.dimC; j++) {\n        matrix.rows[k][j] /= val;\n      }\n\n      for (var i = 0; i < matrix.dimR; i++) {\n        if (i === k) continue;\n        val = matrix.rows[i][lead];\n\n        for (var j = 0; j < matrix.dimC; j++) {\n          matrix.rows[i][j] -= val * matrix.rows[k][j];\n        }\n      }\n\n      lead++;\n    }\n\n    return matrix;\n  } else {\n    throw new ArgumentError(\"expected a matrix.\");\n  }\n}\nexport function transpose(node) {\n  let matrix = node.eval();\n\n  if (AComputable.isMatrix(matrix)) {\n    return matrix.transpose(true).result;\n  } else {\n    throw new ArgumentError(\"expected a matrix\");\n  }\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/functions.ts"],"names":["AComputable","ArgumentError","rref","node","matrix","eval","isMatrix","rows","lead","k","dimR","dimC","i","irow","krow","val","j","transpose","result"],"mappings":"AACA,SAASA,WAAT,QAAoC,cAApC;AACA,SAASC,aAAT,QAA8B,UAA9B;AAEA;;;;;AAIA,OAAO,SAASC,IAAT,CAAcC,IAAd,EAAyB;AAC9B,MAAIC,MAAM,GAAGD,IAAI,CAACE,IAAL,EAAb;;AACA,MAAIL,WAAW,CAACM,QAAZ,CAAqBF,MAArB,KAAgCA,MAAM,CAACG,IAA3C,EAAiD;AAC/C,QAAIC,IAAI,GAAG,CAAX;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,MAAM,CAACM,IAA3B,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,UAAIL,MAAM,CAACO,IAAP,IAAeH,IAAnB,EAAyB,OAAOJ,MAAP;AAEzB,UAAIQ,CAAC,GAAGH,CAAR;;AACA,aAAOL,MAAM,CAACG,IAAP,CAAYK,CAAZ,EAAeJ,IAAf,MAAyB,CAAhC,EAAmC;AACjCI,QAAAA,CAAC;;AACD,YAAIR,MAAM,CAACM,IAAP,KAAgBE,CAApB,EAAuB;AACrBA,UAAAA,CAAC,GAAGH,CAAJ;AACAD,UAAAA,IAAI;AACJ,cAAIJ,MAAM,CAACO,IAAP,KAAgBH,IAApB,EAA0B,OAAOJ,MAAP;AAC3B;AACF;;AACD,UAAIS,IAAI,GAAGT,MAAM,CAACG,IAAP,CAAYK,CAAZ,CAAX;AAAA,UACEE,IAAI,GAAGV,MAAM,CAACG,IAAP,CAAYE,CAAZ,CADT;AAECL,MAAAA,MAAM,CAACG,IAAP,CAAYK,CAAZ,IAAiBE,IAAlB,EAA0BV,MAAM,CAACG,IAAP,CAAYE,CAAZ,IAAiBI,IAA3C;AAEA,UAAIE,GAAG,GAAGX,MAAM,CAACG,IAAP,CAAYE,CAAZ,EAAeD,IAAf,CAAV;;AACA,WAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,MAAM,CAACO,IAA3B,EAAiCK,CAAC,EAAlC,EAAsC;AACpCZ,QAAAA,MAAM,CAACG,IAAP,CAAYE,CAAZ,EAAeO,CAAf,KAAqBD,GAArB;AACD;;AAED,WAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,MAAM,CAACM,IAA3B,EAAiCE,CAAC,EAAlC,EAAsC;AACpC,YAAIA,CAAC,KAAKH,CAAV,EAAa;AACbM,QAAAA,GAAG,GAAGX,MAAM,CAACG,IAAP,CAAYK,CAAZ,EAAeJ,IAAf,CAAN;;AACA,aAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,MAAM,CAACO,IAA3B,EAAiCK,CAAC,EAAlC,EAAsC;AACpCZ,UAAAA,MAAM,CAACG,IAAP,CAAYK,CAAZ,EAAeI,CAAf,KAAqBD,GAAG,GAAGX,MAAM,CAACG,IAAP,CAAYE,CAAZ,EAAeO,CAAf,CAA3B;AACD;AACF;;AACDR,MAAAA,IAAI;AACL;;AACD,WAAOJ,MAAP;AACD,GAjCD,MAiCO;AACL,UAAM,IAAIH,aAAJ,CAAkB,oBAAlB,CAAN;AACD;AACF;AAED,OAAO,SAASgB,SAAT,CAAmBd,IAAnB,EAA8B;AACnC,MAAIC,MAAM,GAAGD,IAAI,CAACE,IAAL,EAAb;;AAEA,MAAIL,WAAW,CAACM,QAAZ,CAAqBF,MAArB,CAAJ,EAAkC;AAChC,WAAOA,MAAM,CAACa,SAAP,CAAiB,IAAjB,EAAuBC,MAA9B;AACD,GAFD,MAEO;AACL,UAAM,IAAIjB,aAAJ,CAAkB,mBAAlB,CAAN;AACD;AACF","sourcesContent":["import { AST } from \"./ast\";\nimport { AComputable, Matrix } from \"./computable\";\nimport { ArgumentError } from \"./errors\";\n\n/**\n * \n * @param node \n */\nexport function rref(node: AST) {\n  let matrix = node.eval();\n  if (AComputable.isMatrix(matrix) && matrix.rows) {\n    var lead = 0;\n    for (var k = 0; k < matrix.dimR; k++) {\n      if (matrix.dimC <= lead) return matrix;\n\n      var i = k;\n      while (matrix.rows[i][lead] === 0) {\n        i++;\n        if (matrix.dimR === i) {\n          i = k;\n          lead++;\n          if (matrix.dimC === lead) return matrix;\n        }\n      }\n      var irow = matrix.rows[i],\n        krow = matrix.rows[k];\n      (matrix.rows[i] = krow), (matrix.rows[k] = irow);\n\n      var val = matrix.rows[k][lead];\n      for (var j = 0; j < matrix.dimC; j++) {\n        matrix.rows[k][j] /= val;\n      }\n\n      for (var i = 0; i < matrix.dimR; i++) {\n        if (i === k) continue;\n        val = matrix.rows[i][lead];\n        for (var j = 0; j < matrix.dimC; j++) {\n          matrix.rows[i][j] -= val * matrix.rows[k][j];\n        }\n      }\n      lead++;\n    }\n    return matrix;\n  } else {\n    throw new ArgumentError(\"expected a matrix.\");\n  }\n}\n\nexport function transpose(node: AST) {\n  let matrix = node.eval();\n\n  if (AComputable.isMatrix(matrix)) {\n    return matrix.transpose(true).result;\n  } else {\n    throw new ArgumentError(\"expected a matrix\");\n  }\n}\n"]},"metadata":{},"sourceType":"module"}