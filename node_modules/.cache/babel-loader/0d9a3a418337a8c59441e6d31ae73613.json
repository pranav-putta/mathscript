{"ast":null,"code":"import { AssignNode, BinaryOperatorNode, CompoundNode, isComputableNode, SingleValueNode, UnaryOperatorNode, VariableNode, ProcedureNode } from \"./ast\";\nimport { Matrix } from \"./computable\";\nimport { MatrixError, ParsingError, SymbolError, SyntaxError } from \"./errors\";\nimport { TokenType, isNumericToken, isSymbolToken } from \"./token\";\nexport class Parser {\n  constructor(lexer) {\n    this.lexer = void 0;\n    this.current_token = void 0;\n    this.lexer = lexer;\n    this.current_token = this.lexer.next_token();\n  }\n  /**\n   * identify expression\n   * expr   : term ((PLUS | MINUS) term)* | term ((PLUS | MINUS)term)*\n   * term   : factor ((MUL | DIV | POW) factor)*\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix | variable | procedure\n   * matrix :  lbracket (row)* rbracket\n   */\n\n\n  expr(ignoreWhiteSpace = true) {\n    // first node\n    let node = this.term(); // do this until a new ((PLUS | MINUS) term) cannot be found\n\n    while (this.current_token.type == TokenType.plus || this.current_token.type == TokenType.minus) {\n      // check white spaces,\n      // if next character is empty or previous character is empty, binary operate\n      if (ignoreWhiteSpace || this.lexer.peek(1) == \" \" || this.lexer.peek(-1) != \" \") {\n        // capture operator (PLUS | MINUS)\n        let token = this.current_token;\n\n        if (token.type == TokenType.plus) {\n          this.eat(TokenType.plus);\n        } else if (token.type == TokenType.minus) {\n          this.eat(TokenType.minus);\n        } // build abstract syntax tree\n\n\n        node = new BinaryOperatorNode(node, token, this.term());\n      } else {\n        return node;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * identify term\n   * term   : factor ((MUL | DIV) factor)*\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix\n   * matrix :  lbracket (row)* rbracket\n   * @return node\n   */\n\n\n  term() {\n    // left factor\n    let node = this.powers(); // do this until a new ((POW | MUL | DIV | RDIV) factor) cannot be found\n\n    while (this.current_token.type == TokenType.mul || this.current_token.type == TokenType.div || this.current_token.type == TokenType.rdiv) {\n      // capture next operator (MUL | DIV)\n      let token = this.current_token;\n\n      if (token.type == TokenType.mul) {\n        this.eat(TokenType.mul);\n      } else if (token.type == TokenType.div) {\n        this.eat(TokenType.div);\n      } else if (token.type == TokenType.rdiv) {\n        this.eat(TokenType.rdiv);\n      } // build abstract syntax tree\n\n\n      node = new BinaryOperatorNode(node, token, this.powers());\n    }\n\n    return node;\n  }\n\n  powers() {\n    // left factor\n    let node = this.factor();\n\n    while (this.current_token.type == TokenType.pow) {\n      let token = this.current_token;\n\n      if (token.type == TokenType.pow) {\n        this.eat(TokenType.pow);\n      }\n\n      node = new BinaryOperatorNode(node, token, this.factor());\n    }\n\n    return node;\n  }\n  /**\n   * identify factor\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix\n   * matrix :  lbracket (row)* rbracket\n   * @return abstract syntax node\n   */\n\n\n  factor() {\n    let token = this.current_token;\n\n    if (token.type == TokenType.plus) {\n      // positive sign\n      this.eat(TokenType.plus);\n      return new UnaryOperatorNode(token, this.factor());\n    } else if (token.type == TokenType.minus) {\n      // negation sign\n      this.eat(TokenType.minus);\n      return new UnaryOperatorNode(token, this.factor());\n    } else if (isNumericToken(token)) {\n      // token is a number\n      this.eat(TokenType.num);\n      return new SingleValueNode(token.value);\n    } else if (token.type == TokenType.lparen) {\n      // lparen expr rparen\n      this.eat(TokenType.lparen);\n      let node = this.expr();\n      this.eat(TokenType.rparen);\n      return node;\n    } else if (token.type == TokenType.lbracket) {\n      // matrix\n      let matrix = this.matrix();\n      return new SingleValueNode(matrix);\n    } else if (token.type == TokenType.larrow) {\n      let vector = this.vector();\n      return new SingleValueNode(vector);\n    } else if (token.type == TokenType.id) {\n      let next = this.lexer.peek();\n\n      if (next && next == \"(\") {\n        return this.procedure();\n      } else {\n        return this.variable();\n      }\n    }\n\n    throw new SyntaxError(\"unexpected symbol\");\n  }\n\n  vector() {\n    // check left arrow\n    this.eat(TokenType.larrow); // get one row\n\n    let row = this.matrix_row(TokenType.rarrow); // check right arrow\n\n    this.eat(TokenType.rarrow);\n    return new Matrix([row]);\n  }\n  /**\n   * matrix :  lbracket (row ;)* (row ]) rbracket\n   */\n\n\n  matrix() {\n    let arr = new Array(); // check left bracket\n\n    this.eat(TokenType.lbracket, \"parsing matrix: \"); // loop through rows\n\n    while (this.current_token.type != TokenType.rbracket) {\n      let row = this.matrix_row(TokenType.rbracket);\n      arr.push(row);\n\n      if (this.current_token.type == TokenType.semicolon) {\n        this.eat(TokenType.semicolon, \"parsing matrix row: \");\n      }\n    } // check right bracket\n\n\n    this.eat(TokenType.rbracket, \"parsing matrix: \");\n    return new Matrix(arr);\n  }\n  /**\n   * row : (factor,)*\n   */\n\n\n  matrix_row(endToken) {\n    let arr = new Array();\n\n    while (true) {\n      let val = this.expr(false); // make sure the element is computable\n\n      if (isComputableNode(val)) {\n        // everything else is good, push element into row\n        arr.push(val); // if row hasn't reached end, consume 'comma' separator\n\n        if (this.current_token.type != TokenType.semicolon && this.current_token.type != endToken) {\n          if (this.current_token.type == TokenType.comma) {\n            this.eat(TokenType.comma, \"parsing matrix row: \");\n          }\n        } else {\n          break;\n        }\n      } else {\n        throw new MatrixError(\"matrix parsing error: expected a numeric element\");\n      }\n    }\n\n    return arr;\n  }\n  /**\n   * consume token and advance to next token\n   * @param type token type to verify\n   */\n\n\n  eat(type, message) {\n    if (this.current_token.type == type) {\n      // if expected token type and current token type matches, proceed to next token\n      this.current_token = this.lexer.next_token();\n    } else {\n      // if token type does not match, a syntax error has happened\n      throw new SyntaxError(message || \"\" + \"expected \" + type.toString() + \", but got \" + this.current_token.type.toString());\n    }\n  }\n  /**\n   * variable : id\n   */\n\n\n  variable() {\n    if (isSymbolToken(this.current_token)) {\n      let node = new VariableNode(this.current_token);\n      this.eat(TokenType.id);\n      return node;\n    }\n\n    throw new SymbolError(\"couldn't parse variable name\");\n  }\n  /**\n   * assignment : (variable = expr) (,variable = expr)*\n   */\n\n\n  assignment() {\n    let left = this.variable();\n    let token = this.current_token;\n    this.eat(TokenType.assign, \"parsing assignment: \");\n    let right = this.expr();\n    let assignments = [new AssignNode(left, token, right)]; //  check if multiline assignment\n\n    if (this.current_token.type == TokenType.comma) {\n      this.eat(TokenType.comma);\n      let next = this.assignment();\n      assignments = assignments.concat(next);\n    }\n\n    return assignments;\n  }\n  /**\n   * procedure : id lparen (expr,)* rparen\n   */\n\n\n  procedure() {\n    let token = this.current_token;\n\n    if (!isSymbolToken(token)) {\n      throw new SymbolError(\"expected an identifier symbol but didn't get it!\");\n    }\n\n    this.eat(TokenType.id);\n    this.eat(TokenType.lparen);\n    let args = [];\n\n    while (true) {\n      args.push(this.expr());\n\n      if (this.current_token.type == TokenType.comma) {\n        this.eat(TokenType.comma);\n      } else {\n        break;\n      }\n    }\n\n    this.eat(TokenType.rparen);\n    return new ProcedureNode(token, args);\n  }\n  /**\n   * assignment | procedure | expr\n   */\n\n\n  variable_statement() {\n    let token = this.current_token;\n\n    if (token.type == TokenType.id) {\n      if (this.lexer.peekToken() == \"=\") {\n        return this.assignment();\n      } else if (this.lexer.peekToken() == \"(\") {\n        return [this.procedure()];\n      } else {\n        return [this.expr()];\n      }\n    }\n\n    throw new ParsingError(\"couldn't find a variable!\");\n  }\n  /**\n   * statement : compound_statement | assignment_statment | expression_statement | empty\n   */\n\n\n  statement() {\n    if (this.current_token.type == TokenType.id) {\n      return this.variable_statement();\n    } else {\n      return [this.expr(true)];\n    }\n  }\n  /**\n   * statement_list : statement | statement endl statement_list\n   */\n\n\n  statement_list() {\n    let results = this.statement();\n\n    while (this.current_token.type == TokenType.endl) {\n      this.eat(TokenType.endl);\n      results = results.concat(this.statement());\n    }\n\n    if (this.current_token.type == TokenType.id) {\n      throw new SyntaxError(\"unexpected identifier\");\n    }\n\n    return results;\n  }\n  /**\n   * compound: statement_list\n   */\n\n\n  compound() {\n    let nodes = this.statement_list();\n    let node = new CompoundNode();\n\n    for (let n of nodes) {\n      node._children.push(n);\n    }\n\n    return node;\n  }\n\n  program() {\n    let node = this.compound();\n    this.eat(TokenType.eof);\n    return node;\n  }\n  /**\n   * parse tokens into an abstract syntax tree for traversal\n   */\n\n\n  parse() {\n    let node = this.program();\n\n    if (this.current_token.type != TokenType.eof) {\n      throw new SyntaxError(\"parsing didn't go as expected!\");\n    }\n\n    return node;\n  }\n\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/parser.ts"],"names":["AssignNode","BinaryOperatorNode","CompoundNode","isComputableNode","SingleValueNode","UnaryOperatorNode","VariableNode","ProcedureNode","Matrix","MatrixError","ParsingError","SymbolError","SyntaxError","TokenType","isNumericToken","isSymbolToken","Parser","constructor","lexer","current_token","next_token","expr","ignoreWhiteSpace","node","term","type","plus","minus","peek","token","eat","powers","mul","div","rdiv","factor","pow","num","value","lparen","rparen","lbracket","matrix","larrow","vector","id","next","procedure","variable","row","matrix_row","rarrow","arr","Array","rbracket","push","semicolon","endToken","val","comma","message","toString","assignment","left","assign","right","assignments","concat","args","variable_statement","peekToken","statement","statement_list","results","endl","compound","nodes","n","_children","program","eof","parse"],"mappings":"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","sourcesContent":["import {\n  AssignNode,\n  AST,\n  BinaryOperatorNode,\n  CompoundNode,\n  ComputableNode,\n  isComputableNode,\n  SingleValueNode,\n  UnaryOperatorNode,\n  VariableNode,\n  ProcedureNode,\n} from \"./ast\";\nimport { Matrix, AComputable } from \"./computable\";\nimport { MatrixError, ParsingError, SymbolError, SyntaxError } from \"./errors\";\nimport { Lexer } from \"./lexer\";\nimport {\n  TokenType,\n  Token,\n  isNumericToken,\n  plus_token,\n  eof_token,\n  isSymbolToken,\n} from \"./token\";\n\nexport class Parser {\n  private lexer: Lexer;\n  private current_token: Token;\n\n  constructor(lexer: Lexer) {\n    this.lexer = lexer;\n    this.current_token = this.lexer.next_token();\n  }\n\n  /**\n   * identify expression\n   * expr   : term ((PLUS | MINUS) term)* | term ((PLUS | MINUS)term)*\n   * term   : factor ((MUL | DIV | POW) factor)*\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix | variable | procedure\n   * matrix :  lbracket (row)* rbracket\n   */\n  private expr(ignoreWhiteSpace: boolean = true): AST {\n    // first node\n    let node: AST = this.term();\n\n    // do this until a new ((PLUS | MINUS) term) cannot be found\n    while (\n      this.current_token.type == TokenType.plus ||\n      this.current_token.type == TokenType.minus\n    ) {\n      // check white spaces,\n      // if next character is empty or previous character is empty, binary operate\n      if (\n        ignoreWhiteSpace ||\n        this.lexer.peek(1) == \" \" ||\n        this.lexer.peek(-1) != \" \"\n      ) {\n        // capture operator (PLUS | MINUS)\n        let token = this.current_token;\n        if (token.type == TokenType.plus) {\n          this.eat(TokenType.plus);\n        } else if (token.type == TokenType.minus) {\n          this.eat(TokenType.minus);\n        }\n        // build abstract syntax tree\n        node = new BinaryOperatorNode(node, token, this.term());\n      } else {\n        return node;\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * identify term\n   * term   : factor ((MUL | DIV) factor)*\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix\n   * matrix :  lbracket (row)* rbracket\n   * @return node\n   */\n  private term(): AST {\n    // left factor\n    let node: AST = this.powers();\n    // do this until a new ((POW | MUL | DIV | RDIV) factor) cannot be found\n    while (\n      this.current_token.type == TokenType.mul ||\n      this.current_token.type == TokenType.div ||\n      this.current_token.type == TokenType.rdiv\n    ) {\n      // capture next operator (MUL | DIV)\n      let token = this.current_token;\n      if (token.type == TokenType.mul) {\n        this.eat(TokenType.mul);\n      } else if (token.type == TokenType.div) {\n        this.eat(TokenType.div);\n      } else if (token.type == TokenType.rdiv) {\n        this.eat(TokenType.rdiv);\n      }\n      // build abstract syntax tree\n      node = new BinaryOperatorNode(node, token, this.powers());\n    }\n\n    return node;\n  }\n\n  private powers(): AST {\n    // left factor\n    let node: AST = this.factor();\n    while (this.current_token.type == TokenType.pow) {\n      let token = this.current_token;\n      if (token.type == TokenType.pow) {\n        this.eat(TokenType.pow);\n      }\n      node = new BinaryOperatorNode(node, token, this.factor());\n    }\n    return node;\n  }\n\n  /**\n   * identify factor\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix\n   * matrix :  lbracket (row)* rbracket\n   * @return abstract syntax node\n   */\n  private factor(): AST {\n    let token = this.current_token;\n    if (token.type == TokenType.plus) {\n      // positive sign\n      this.eat(TokenType.plus);\n      return new UnaryOperatorNode(token, this.factor());\n    } else if (token.type == TokenType.minus) {\n      // negation sign\n      this.eat(TokenType.minus);\n      return new UnaryOperatorNode(token, this.factor());\n    } else if (isNumericToken(token)) {\n      // token is a number\n      this.eat(TokenType.num);\n      return new SingleValueNode(token.value);\n    } else if (token.type == TokenType.lparen) {\n      // lparen expr rparen\n      this.eat(TokenType.lparen);\n      let node: AST = this.expr();\n      this.eat(TokenType.rparen);\n      return node;\n    } else if (token.type == TokenType.lbracket) {\n      // matrix\n      let matrix: Matrix = this.matrix();\n      return new SingleValueNode(matrix);\n    } else if (token.type == TokenType.larrow) {\n      let vector: Matrix = this.vector();\n      return new SingleValueNode(vector);\n    } else if (token.type == TokenType.id) {\n      let next = this.lexer.peek();\n      if (next && next == \"(\") {\n        return this.procedure();\n      } else {\n        return this.variable();\n      }\n    }\n\n    throw new SyntaxError(\"unexpected symbol\");\n  }\n\n  private vector(): Matrix {\n    // check left arrow\n    this.eat(TokenType.larrow);\n    // get one row\n    let row = this.matrix_row(TokenType.rarrow);\n    // check right arrow\n    this.eat(TokenType.rarrow);\n    return new Matrix([row]);\n  }\n\n  /**\n   * matrix :  lbracket (row ;)* (row ]) rbracket\n   */\n  private matrix(): Matrix {\n    let arr: ComputableNode[][] = new Array();\n    // check left bracket\n    this.eat(TokenType.lbracket, \"parsing matrix: \");\n    // loop through rows\n    while (this.current_token.type != TokenType.rbracket) {\n      let row = this.matrix_row(TokenType.rbracket);\n      arr.push(row);\n      if (this.current_token.type == TokenType.semicolon) {\n        this.eat(TokenType.semicolon, \"parsing matrix row: \");\n      }\n    }\n    // check right bracket\n    this.eat(TokenType.rbracket, \"parsing matrix: \");\n    return new Matrix(arr);\n  }\n\n  /**\n   * row : (factor,)*\n   */\n  private matrix_row(endToken: TokenType): ComputableNode[] {\n    let arr: ComputableNode[] = new Array();\n\n    while (true) {\n      let val = this.expr(false);\n      // make sure the element is computable\n      if (isComputableNode(val)) {\n        // everything else is good, push element into row\n        arr.push(val);\n        // if row hasn't reached end, consume 'comma' separator\n        if (\n          this.current_token.type != TokenType.semicolon &&\n          this.current_token.type != endToken\n        ) {\n          if (this.current_token.type == TokenType.comma) {\n            this.eat(TokenType.comma, \"parsing matrix row: \");\n          }\n        } else {\n          break;\n        }\n      } else {\n        throw new MatrixError(\n          \"matrix parsing error: expected a numeric element\"\n        );\n      }\n    }\n\n    return arr;\n  }\n\n  /**\n   * consume token and advance to next token\n   * @param type token type to verify\n   */\n  private eat(type: TokenType, message?: string) {\n    if (this.current_token.type == type) {\n      // if expected token type and current token type matches, proceed to next token\n      this.current_token = this.lexer.next_token();\n    } else {\n      // if token type does not match, a syntax error has happened\n      throw new SyntaxError(\n        message ||\n          \"\" +\n            \"expected \" +\n            type.toString() +\n            \", but got \" +\n            this.current_token.type.toString()\n      );\n    }\n  }\n\n  /**\n   * variable : id\n   */\n  public variable(): VariableNode {\n    if (isSymbolToken(this.current_token)) {\n      let node = new VariableNode(this.current_token);\n      this.eat(TokenType.id);\n      return node;\n    }\n    throw new SymbolError(\"couldn't parse variable name\");\n  }\n\n  /**\n   * assignment : (variable = expr) (,variable = expr)*\n   */\n  public assignment(): AssignNode[] {\n    let left = this.variable();\n    let token = this.current_token;\n    this.eat(TokenType.assign, \"parsing assignment: \");\n    let right = this.expr();\n    let assignments = [new AssignNode(left, token, right)];\n    //  check if multiline assignment\n    if (this.current_token.type == TokenType.comma) {\n      this.eat(TokenType.comma);\n      let next = this.assignment();\n      assignments = assignments.concat(next);\n    }\n    return assignments;\n  }\n\n  /**\n   * procedure : id lparen (expr,)* rparen\n   */\n  public procedure(): ProcedureNode {\n    let token = this.current_token;\n    if (!isSymbolToken(token)) {\n      throw new SymbolError(\"expected an identifier symbol but didn't get it!\");\n    }\n    this.eat(TokenType.id);\n    this.eat(TokenType.lparen);\n    let args = [];\n    while (true) {\n      args.push(this.expr());\n      if (this.current_token.type == TokenType.comma) {\n        this.eat(TokenType.comma);\n      } else {\n        break;\n      }\n    }\n    this.eat(TokenType.rparen);\n    return new ProcedureNode(token, args);\n  }\n\n  /**\n   * assignment | procedure | expr\n   */\n  public variable_statement(): AST[] {\n    let token = this.current_token;\n    if (token.type == TokenType.id) {\n      if (this.lexer.peekToken() == \"=\") {\n        return this.assignment();\n      } else if (this.lexer.peekToken() == \"(\") {\n        return [this.procedure()];\n      } else {\n        return [this.expr()];\n      }\n    }\n\n    throw new ParsingError(\"couldn't find a variable!\");\n  }\n\n  /**\n   * statement : compound_statement | assignment_statment | expression_statement | empty\n   */\n  public statement(): AST[] {\n    if (this.current_token.type == TokenType.id) {\n      return this.variable_statement();\n    } else {\n      return [this.expr(true)];\n    }\n  }\n\n  /**\n   * statement_list : statement | statement endl statement_list\n   */\n  public statement_list(): AST[] {\n    let results = this.statement();\n    while (this.current_token.type == TokenType.endl) {\n      this.eat(TokenType.endl);\n      results = results.concat(this.statement());\n    }\n\n    if (this.current_token.type == TokenType.id) {\n      throw new SyntaxError(\"unexpected identifier\");\n    }\n\n    return results;\n  }\n\n  /**\n   * compound: statement_list\n   */\n  public compound(): AST {\n    let nodes = this.statement_list();\n\n    let node = new CompoundNode();\n    for (let n of nodes) {\n      node._children.push(n);\n    }\n\n    return node;\n  }\n\n  public program(): AST {\n    let node = this.compound();\n    this.eat(TokenType.eof);\n    return node;\n  }\n\n  /**\n   * parse tokens into an abstract syntax tree for traversal\n   */\n  public parse(): AST {\n    let node = this.program();\n    if (this.current_token.type != TokenType.eof) {\n      throw new SyntaxError(\"parsing didn't go as expected!\");\n    }\n    return node;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}