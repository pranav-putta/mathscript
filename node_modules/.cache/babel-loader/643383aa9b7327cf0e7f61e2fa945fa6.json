{"ast":null,"code":"import { SymbolError } from \"./errors\";\nimport { TokenType, newToken } from \"./token\";\nimport { isspace, isdigit, isalnum } from \"./util\";\n\n/**\n * Lexer tokenizes raw input into @class{Token} objects\n */\nexport class Lexer {\n  /**\n   * raw input text\n   */\n\n  /**\n   * current tokenizing position\n   */\n\n  /**\n   * current character at position\n   */\n  constructor(text) {\n    this.text = void 0;\n    this.position = void 0;\n    this.current_char = void 0;\n    this.text = text;\n    this.position = -1;\n  }\n\n  _id() {\n    let result = \"\";\n\n    while (this.current_char && isalnum(this.current_char)) {\n      result += this.current_char;\n      let next = this.peek();\n\n      if (next && isalnum(next)) {\n        this.advance();\n      } else {\n        break;\n      }\n    }\n\n    return Lexer.reserved_keywords[result] || {\n      type: TokenType.id,\n      value: result\n    };\n  }\n  /**\n   * increments position and updates current_char\n   * sets current_char to undefined if position is out of bounds\n   */\n\n\n  advance() {\n    this.position++;\n\n    if (this.position < this.text.length) {\n      this.current_char = this.text.charAt(this.position);\n    } else {\n      this.current_char = undefined;\n    }\n  }\n  /**\n   * retrieves next character without advancing position\n   * @param steps number of steps to take\n   */\n\n\n  peek(steps = 1) {\n    if (this.position + steps >= this.text.length) {\n      return undefined;\n    } else {\n      return this.text.charAt(this.position + steps);\n    }\n  }\n  /**\n   * retrieves the next token by ignoring whitespaces\n   */\n\n\n  peekToken() {\n    let pos = this.position + 1;\n\n    while (pos < this.text.length && isspace(this.text.charAt(pos))) {\n      pos += 1;\n    }\n\n    return this.text.charAt(pos);\n  }\n  /**\n   * skips all whitepsace in sequence\n   */\n\n\n  ignore_whitespace(advance = true) {\n    if (advance) {\n      // stop at next token\n      while (this.current_char && isspace(this.current_char)) {\n        this.advance();\n      }\n    } else {\n      // stop before next token\n      let current = this.peek();\n\n      while (current && isspace(current)) {\n        this.advance();\n      }\n    }\n  }\n  /**\n   * converts numeric character sequence into a token\n   */\n\n\n  tokenize_number() {\n    let result = this.current_char || \"\";\n    let next = this.peek(); // capture integer\n\n    while (next && isdigit(next)) {\n      this.advance();\n      result += this.current_char;\n      next = this.peek();\n    } // check if decimal point\n\n\n    if (next && next == \".\") {\n      let tmpNext = this.peek(2);\n      this.advance(); // make sure next character is a digit, not an elipses or something like '1.'\n\n      if (tmpNext && isdigit(tmpNext)) {\n        result += this.current_char;\n        next = this.peek(); // append numbers after decimal point\n\n        while (next && isdigit(next)) {\n          this.advance();\n          result += this.current_char;\n          next = this.peek();\n        }\n      }\n    } // convert to number and return\n\n\n    return Number(result);\n  }\n  /**\n   * retrieves next token in string\n   */\n\n\n  next_token() {\n    this.advance();\n    let token = this.tokenize();\n    return token;\n  }\n  /**\n   * compares characters and matches with associated token\n   */\n\n\n  tokenize() {\n    // ignore all spaces\n    if (this.current_char && isspace(this.current_char)) {\n      this.ignore_whitespace();\n    }\n\n    if (!this.current_char) {\n      // check if no more characters\n      return {\n        type: TokenType.eof,\n        value: \"eof\"\n      };\n    } else if (isdigit(this.current_char)) {\n      // capture numeric token\n      return {\n        type: TokenType.num,\n        value: this.tokenize_number()\n      };\n    } else if (isalnum(this.current_char)) {\n      // capture alphanumeric token\n      return this._id();\n    } else {\n      // look for each token\n      for (let type in TokenType) {\n        let tok = TokenType[type]; // if this character type is more than one, peek next\n\n        let char = this.current_char;\n        let n = TokenType[type].length;\n\n        for (let peekStep = 1; peekStep < n; peekStep++) {\n          char += this.peek(peekStep);\n        } // if type is strictly equal to char, match and return\n\n\n        if (TokenType[type] == char) {\n          for (let i = 1; i < n; i++) {\n            this.advance();\n          }\n\n          return newToken(tok, type.toString());\n        }\n      }\n    } // token wasn't recognized\n\n\n    throw new SymbolError(\"unexpected token: `\" + this.current_char + \"`\");\n  }\n\n}\nLexer.reserved_keywords = {\n  true: newToken(TokenType.primitive, \"true\"),\n  false: newToken(TokenType.primitive, \"false\")\n};","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/lexer.ts"],"names":["SymbolError","TokenType","newToken","isspace","isdigit","isalnum","Lexer","constructor","text","position","current_char","_id","result","next","peek","advance","reserved_keywords","type","id","value","length","charAt","undefined","steps","peekToken","pos","ignore_whitespace","current","tokenize_number","tmpNext","Number","next_token","token","tokenize","eof","num","tok","char","n","peekStep","i","toString","true","primitive","false"],"mappings":"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","sourcesContent":["import { SymbolError } from \"./errors\";\nimport { Token, TokenType, SymbolToken, newToken } from \"./token\";\nimport { isspace, isdigit, isalnum } from \"./util\";\n\ninterface Keywords {\n  [key: string]: Token;\n}\n\n/**\n * Lexer tokenizes raw input into @class{Token} objects\n */\nexport class Lexer {\n  public static readonly reserved_keywords: Keywords = {\n    true: newToken(TokenType.primitive, \"true\"),\n    false: newToken(TokenType.primitive, \"false\"),\n  };\n  /**\n   * raw input text\n   */\n  private text: string;\n  /**\n   * current tokenizing position\n   */\n  private position: number;\n  /**\n   * current character at position\n   */\n  private current_char: string | undefined;\n\n  constructor(text: string) {\n    this.text = text;\n    this.position = -1;\n  }\n\n  private _id(): Token {\n    let result = \"\";\n    while (this.current_char && isalnum(this.current_char)) {\n      result += this.current_char;\n      let next = this.peek();\n      if (next && isalnum(next)) {\n        this.advance();\n      } else {\n        break;\n      }\n    }\n    return (\n      Lexer.reserved_keywords[result] || { type: TokenType.id, value: result }\n    );\n  }\n\n  /**\n   * increments position and updates current_char\n   * sets current_char to undefined if position is out of bounds\n   */\n  private advance() {\n    this.position++;\n\n    if (this.position < this.text.length) {\n      this.current_char = this.text.charAt(this.position);\n    } else {\n      this.current_char = undefined;\n    }\n  }\n\n  /**\n   * retrieves next character without advancing position\n   * @param steps number of steps to take\n   */\n  public peek(steps: number = 1): string | undefined {\n    if (this.position + steps >= this.text.length) {\n      return undefined;\n    } else {\n      return this.text.charAt(this.position + steps);\n    }\n  }\n\n  /**\n   * retrieves the next token by ignoring whitespaces\n   */\n  public peekToken(): string {\n    let pos = this.position + 1;\n    while (pos < this.text.length && isspace(this.text.charAt(pos))) {\n      pos += 1;\n    }\n    return this.text.charAt(pos);\n  }\n\n  /**\n   * skips all whitepsace in sequence\n   */\n  private ignore_whitespace(advance: boolean = true) {\n    if (advance) {\n      // stop at next token\n      while (this.current_char && isspace(this.current_char)) {\n        this.advance();\n      }\n    } else {\n      // stop before next token\n      let current = this.peek();\n      while (current && isspace(current)) {\n        this.advance();\n      }\n    }\n  }\n\n  /**\n   * converts numeric character sequence into a token\n   */\n  private tokenize_number(): number {\n    let result = this.current_char || \"\";\n    let next = this.peek();\n    // capture integer\n    while (next && isdigit(next)) {\n      this.advance();\n      result += this.current_char;\n      next = this.peek();\n    }\n\n    // check if decimal point\n    if (next && next == \".\") {\n      let tmpNext = this.peek(2);\n      this.advance();\n      // make sure next character is a digit, not an elipses or something like '1.'\n      if (tmpNext && isdigit(tmpNext)) {\n        result += this.current_char;\n        next = this.peek();\n\n        // append numbers after decimal point\n        while (next && isdigit(next)) {\n          this.advance();\n          result += this.current_char;\n          next = this.peek();\n        }\n      }\n    }\n\n    // convert to number and return\n    return Number(result);\n  }\n\n  /**\n   * retrieves next token in string\n   */\n  public next_token(): Token {\n    this.advance();\n    let token = this.tokenize();\n    return token;\n  }\n\n  /**\n   * compares characters and matches with associated token\n   */\n  private tokenize(): Token {\n    // ignore all spaces\n    if (this.current_char && isspace(this.current_char)) {\n      this.ignore_whitespace();\n    }\n\n    if (!this.current_char) {\n      // check if no more characters\n      return { type: TokenType.eof, value: \"eof\" };\n    } else if (isdigit(this.current_char)) {\n      // capture numeric token\n      return { type: TokenType.num, value: this.tokenize_number() };\n    } else if (isalnum(this.current_char)) {\n      // capture alphanumeric token\n      return this._id();\n    } else {\n      // look for each token\n      for (let type in TokenType) {\n        let tok: TokenType = TokenType[type as keyof typeof TokenType];\n        // if this character type is more than one, peek next\n        let char = this.current_char;\n        let n = TokenType[type].length;\n        for (let peekStep = 1; peekStep < n; peekStep++) {\n          char += this.peek(peekStep);\n        }\n        // if type is strictly equal to char, match and return\n        if (TokenType[type] == char) {\n          for (let i = 1; i < n; i++) {\n            this.advance();\n          }\n          return newToken(tok, type.toString());\n        }\n      }\n    }\n\n    // token wasn't recognized\n    throw new SymbolError(\"unexpected token: `\" + this.current_char + \"`\");\n  }\n}\n"]},"metadata":{},"sourceType":"module"}