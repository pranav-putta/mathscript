{"ast":null,"code":"import { global_functions, global_scope } from \"./global\";\nimport { Computable } from \"./computable\";\nimport { ArithmeticError, ParsingError, SymbolError, UndeclaredVariableError } from \"./errors\";\nimport { TokenType } from \"./token\";\nimport { UnevaluatedMatrix } from \"./computable/matrix\";\n/**\n * abstract syntax tree base class\n */\n\nexport class AbstractSyntaxTree {\n  /**\n   * abstract evaluate method. visits all nodes in postorder traversal\n   */\n\n  /**\n   * list of children\n   * @dev\n   */\n  get _children() {\n    return [];\n  }\n\n}\n/**\n * compound statements go here\n */\n\nexport class CompoundNode extends AbstractSyntaxTree {\n  constructor() {\n    super();\n    this.children = void 0;\n    this.children = [];\n  }\n\n  eval() {\n    let results = [];\n\n    for (let child of this.children) {\n      let val = child.eval();\n      results.push(val);\n    }\n\n    return results;\n  }\n\n  get _children() {\n    return this.children;\n  }\n\n}\n/**\n * assigns a variable to its value\n */\n\nexport class AssignNode extends AbstractSyntaxTree {\n  constructor(left, token, right) {\n    super();\n    this.left = void 0;\n    this.token = void 0;\n    this.right = void 0;\n    this.left = left;\n    this.token = token;\n    this.right = right;\n  }\n\n  eval() {\n    let name = this.left.value;\n    let val = this.right.eval();\n    global_scope[name] = val;\n    return `${name} = ${global_scope[name]}`;\n    console.log(`${name} = ${global_scope[name]}`);\n  }\n\n  get _children() {\n    return [this.left, this.right];\n  }\n\n}\n/**\n * computes a procedure\n */\n\nexport class ProcedureNode extends AbstractSyntaxTree {\n  constructor(token, args) {\n    super();\n    this.token = void 0;\n    this.name = void 0;\n    this.args = void 0;\n    this.token = token;\n    this.name = token.value;\n    this.args = args;\n  }\n\n  eval() {\n    let func = global_functions[this.name];\n    let result = func.apply(this, this.args);\n    console.log(result);\n    return result;\n  }\n\n}\n/**\n * empty node, doesn't do anything\n */\n\nexport class EmptyNode extends AbstractSyntaxTree {\n  eval() {\n    return;\n  }\n\n}\nexport class ComputableNode extends AbstractSyntaxTree {}\n/**\n * binary operator node\n * takes a (left, operator, right)\n */\n\nexport class BinaryOperatorNode extends ComputableNode {\n  /**\n   * left node in binary operation\n   */\n\n  /**\n   * right node in binary operation\n   */\n\n  /**\n   * operator\n   */\n  constructor(left, operator, right) {\n    super();\n    this.left = void 0;\n    this.right = void 0;\n    this.operator = void 0;\n    this.left = left;\n    this.right = right;\n    this.operator = operator;\n  }\n\n  eval() {\n    let l = this.left.eval();\n    let r = this.right.eval();\n\n    if (Computable.isComputable(l) && Computable.isComputable(r)) {\n      return Computable.compute(l, r, this.operator.type).result;\n    }\n\n    throw new ParsingError(`cannot operate on two non-computable values: ${l} and ${r}`);\n  }\n\n  get _children() {\n    return [this.left, this.right];\n  }\n\n}\n/**\n * holds a variable and its value\n */\n\nexport class VariableNode extends ComputableNode {\n  get value() {\n    return this._value;\n  }\n\n  constructor(token) {\n    super();\n    this._value = void 0;\n    this._value = token.value;\n  }\n\n  eval() {\n    let name = this.value;\n    let val = global_scope[name];\n\n    if (val) {\n      console.log(`${name} = ${val}`);\n      return val;\n    } else {\n      throw new UndeclaredVariableError(`${name} was not declared!`);\n    }\n  }\n\n}\n/**\n * stores a single value: number or matrix\n */\n\nexport class SingleValueNode extends ComputableNode {\n  constructor(value) {\n    super();\n    this.value = void 0;\n    this.value = value;\n  }\n\n  eval() {\n    // evaluate unevaluated matrix if not done already\n    if (UnevaluatedMatrix.isUnevaluatedMatrix(this.value)) {\n      this.value = this.value.evaluate();\n    }\n\n    return this.value;\n  }\n\n  get _children() {\n    return [];\n  }\n\n}\n/**\n * holds a unary operator\n */\n\nexport class UnaryOperatorNode extends ComputableNode {\n  constructor(token, next) {\n    super();\n    this.token = void 0;\n    this.next = void 0;\n    this.token = token;\n    this.next = next;\n  }\n\n  eval() {\n    if (this.token.type == TokenType.plus) {\n      // return next element as is\n      return this.next.eval();\n    } else if (this.token.type == TokenType.minus) {\n      // take negation of next element\n      let out = this.next.eval();\n\n      if (Computable.isNumeric(out)) {\n        return -1 * out;\n      } else if (Computable.isMatrix(out)) {\n        return out.mul(-1).result;\n      } else {\n        throw new ArithmeticError(\"couldn't evaluate negation of item\");\n      }\n    } else {\n      throw new SymbolError(\"unexpected unary operator: \" + this.token.type.toString());\n    }\n  }\n\n  get _children() {\n    return [this.next];\n  }\n\n}\nexport function isComputableNode(node) {\n  return node instanceof ComputableNode;\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/ast.ts"],"names":["global_functions","global_scope","Computable","ArithmeticError","ParsingError","SymbolError","UndeclaredVariableError","TokenType","UnevaluatedMatrix","AbstractSyntaxTree","_children","CompoundNode","constructor","children","eval","results","child","val","push","AssignNode","left","token","right","name","value","console","log","ProcedureNode","args","func","result","apply","EmptyNode","ComputableNode","BinaryOperatorNode","operator","l","r","isComputable","compute","type","VariableNode","_value","SingleValueNode","isUnevaluatedMatrix","evaluate","UnaryOperatorNode","next","plus","minus","out","isNumeric","isMatrix","mul","toString","isComputableNode","node"],"mappings":"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","sourcesContent":["import { global_functions, global_scope } from \"./global\";\nimport { Computable, Result } from \"./computable\";\nimport {\n  ArithmeticError,\n  MatrixError,\n  ParsingError,\n  SymbolError,\n  UndeclaredVariableError,\n} from \"./errors\";\nimport { SymbolToken, Token, TokenType } from \"./token\";\nimport { Queue } from \"./util\";\nimport { UnevaluatedMatrix } from \"./computable/matrix\";\n\n/**\n * abstract syntax tree base class\n */\nexport abstract class AbstractSyntaxTree {\n  /**\n   * abstract evaluate method. visits all nodes in postorder traversal\n   */\n  abstract eval(): any;\n  /**\n   * list of children\n   * @dev\n   */\n  get _children(): AbstractSyntaxTree[] {\n    return [];\n  }\n}\n\n/**\n * compound statements go here\n */\nexport class CompoundNode extends AbstractSyntaxTree {\n  private children: AST[];\n\n  constructor() {\n    super();\n    this.children = [];\n  }\n\n  eval() {\n    let results = [];\n    for (let child of this.children) {\n      let val = child.eval();\n      results.push(val);\n    }\n    return results;\n  }\n  get _children(): AbstractSyntaxTree[] {\n    return this.children;\n  }\n}\n\n/**\n * assigns a variable to its value\n */\nexport class AssignNode extends AbstractSyntaxTree {\n  private left: VariableNode;\n  private token: Token;\n  private right: AST;\n\n  constructor(left: VariableNode, token: Token, right: AST) {\n    super();\n    this.left = left;\n    this.token = token;\n    this.right = right;\n  }\n  eval() {\n    let name = this.left.value;\n    let val = this.right.eval();\n    global_scope[name] = val;\n    return `${name} = ${global_scope[name]}`;\n    console.log(`${name} = ${global_scope[name]}`);\n  }\n  get _children(): AbstractSyntaxTree[] {\n    return [this.left, this.right];\n  }\n}\n\n/**\n * computes a procedure\n */\nexport class ProcedureNode extends AbstractSyntaxTree {\n  private token: Token;\n  private name: string;\n  private args: AST[];\n\n  constructor(token: SymbolToken, args: AST[]) {\n    super();\n    this.token = token;\n    this.name = token.value;\n    this.args = args;\n  }\n\n  eval() {\n    let func = global_functions[this.name];\n    let result = func.apply(this, this.args);\n    console.log(result);\n    return result;\n  }\n}\n\n/**\n * empty node, doesn't do anything\n */\nexport class EmptyNode extends AbstractSyntaxTree {\n  eval() {\n    return;\n  }\n}\n\nexport abstract class ComputableNode extends AbstractSyntaxTree {\n  abstract eval(): Computable;\n}\n\n/**\n * binary operator node\n * takes a (left, operator, right)\n */\nexport class BinaryOperatorNode extends ComputableNode {\n  /**\n   * left node in binary operation\n   */\n  private left: AST;\n  /**\n   * right node in binary operation\n   */\n  private right: AST;\n  /**\n   * operator\n   */\n  private operator: Token;\n\n  constructor(left: AST, operator: Token, right: AST) {\n    super();\n    this.left = left;\n    this.right = right;\n    this.operator = operator;\n  }\n\n  public eval(): Computable {\n    let l = this.left.eval();\n    let r = this.right.eval();\n\n    if (Computable.isComputable(l) && Computable.isComputable(r)) {\n      return Computable.compute(l, r, this.operator.type).result;\n    }\n\n    throw new ParsingError(\n      `cannot operate on two non-computable values: ${l} and ${r}`\n    );\n  }\n\n  public get _children(): AST[] {\n    return [this.left, this.right];\n  }\n}\n\n/**\n * holds a variable and its value\n */\nexport class VariableNode extends ComputableNode {\n  private _value: string;\n\n  public get value(): string {\n    return this._value;\n  }\n\n  constructor(token: SymbolToken) {\n    super();\n    this._value = token.value;\n  }\n  eval() {\n    let name = this.value;\n    let val = global_scope[name];\n    if (val) {\n      console.log(`${name} = ${val}`);\n      return val;\n    } else {\n      throw new UndeclaredVariableError(`${name} was not declared!`);\n    }\n  }\n}\n\n/**\n * stores a single value: number or matrix\n */\nexport class SingleValueNode extends ComputableNode {\n  private value: Computable | UnevaluatedMatrix;\n\n  constructor(value: Computable | UnevaluatedMatrix) {\n    super();\n    this.value = value;\n  }\n\n  public eval(): Computable {\n    // evaluate unevaluated matrix if not done already\n    if (UnevaluatedMatrix.isUnevaluatedMatrix(this.value)) {\n      this.value = this.value.evaluate();\n    }\n\n    return this.value;\n  }\n\n  public get _children(): AST[] {\n    return [];\n  }\n}\n\n/**\n * holds a unary operator\n */\nexport class UnaryOperatorNode extends ComputableNode {\n  private token: Token;\n  private next: ComputableNode;\n\n  constructor(token: Token, next: ComputableNode) {\n    super();\n    this.token = token;\n    this.next = next;\n  }\n\n  public eval(): Computable {\n    if (this.token.type == TokenType.plus) {\n      // return next element as is\n      return this.next.eval();\n    } else if (this.token.type == TokenType.minus) {\n      // take negation of next element\n      let out = this.next.eval();\n      if (Computable.isNumeric(out)) {\n        return -1 * out;\n      } else if (Computable.isMatrix(out)) {\n        return out.mul(-1).result;\n      } else {\n        throw new ArithmeticError(\"couldn't evaluate negation of item\");\n      }\n    } else {\n      throw new SymbolError(\n        \"unexpected unary operator: \" + this.token.type.toString()\n      );\n    }\n  }\n\n  public get _children(): AST[] {\n    return [this.next];\n  }\n}\n\nexport function isComputableNode(node: AST): node is ComputableNode {\n  return node instanceof ComputableNode;\n}\n\nexport type AST = AbstractSyntaxTree;\nexport type CN = ComputableNode;\nexport type BinOp = BinaryOperatorNode;\nexport type SVN = SingleValueNode;\nexport type UnaryOp = UnaryOperatorNode;\n"]},"metadata":{},"sourceType":"module"}