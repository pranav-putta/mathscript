"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stringification_1 = require("../stringification");
class TypeMatcher {
    constructor(type) {
        this.type = type;
        this._testers = [];
        if (type === null || type === undefined) {
            throw new TypeError("type must not be null or undefined");
        }
        this._testers.push({
            stringify: () => `Any ${this.type.name}`,
            test: (value) => {
                if (type === String) {
                    return (typeof value === "string" || value instanceof this.type);
                }
                else if (type === Number) {
                    return (typeof value === "number" || value instanceof this.type);
                }
                else if (type === Boolean) {
                    return (typeof value === "boolean" ||
                        value instanceof this.type);
                }
                else {
                    return value instanceof this.type;
                }
            }
        });
    }
    test(value) {
        return this._testers.every(tester => tester.test(value));
    }
    stringify() {
        return this._testers.map(tester => tester.stringify()).join(" and ");
    }
    thatMatches(first, second) {
        if (null === first || undefined === first) {
            throw new TypeError("thatMatches requires none-null or non-undefined argument");
        }
        if (typeof first === "string") {
            return this._matchesKeyAndValue(first, second);
        }
        if (typeof first === "function") {
            return this._matchesDelegate(first);
        }
        if (typeof first === "object") {
            return this._matchesObjectLiteral(first);
        }
        throw new Error("Invalid arguments");
    }
    _matchesKeyAndValue(key, value) {
        this._testers.push({
            stringify: () => `with property '${key}' equal to '${stringification_1.stringify(value)}'`,
            test: (v) => {
                if (Object.getOwnPropertyNames(v).indexOf(key) < 0) {
                    return false;
                }
                return v[key] === value;
            }
        });
        return this._thisAsMatcherOrType();
    }
    _matchesDelegate(delegate) {
        this._testers.push({
            stringify: () => `matches '${delegate.toString()}'`,
            test: (v) => delegate(v)
        });
        return this._thisAsMatcherOrType();
    }
    _matchesObjectLiteral(properties) {
        this._testers.push({
            stringify: () => `matches '${stringification_1.stringify(properties)}'`,
            test: (v) => {
                const targetKeys = Object.getOwnPropertyNames(v);
                return Object.getOwnPropertyNames(properties).every(key => {
                    if (targetKeys.indexOf(key) < 0) {
                        return false;
                    }
                    return v[key] === properties[key];
                });
            }
        });
        return this._thisAsMatcherOrType();
    }
    _thisAsMatcherOrType() {
        return this;
    }
}
exports.TypeMatcher = TypeMatcher;
//# sourceMappingURL=type-matcher.js.map