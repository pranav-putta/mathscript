"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const alsatian_core_1 = require("../alsatian-core");
const errors_1 = require("../errors");
class TestItem {
    constructor(testFixture, test, testCase) {
        if (testFixture === null || testFixture === undefined) {
            throw new TypeError("testFixture must not be null or undefined.");
        }
        if (test === null || test === undefined) {
            throw new TypeError("test must not be null or undefined.");
        }
        if (testCase === null || testCase === undefined) {
            throw new TypeError("testCase must not be null or undefined.");
        }
        this._testFixture = testFixture;
        this._test = test;
        this._testCase = testCase;
    }
    get testCase() {
        return this._testCase;
    }
    get test() {
        return this._test;
    }
    get testFixture() {
        return this._testFixture;
    }
    run(timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._test.ignored) {
                return;
            }
            else {
                yield this._setup();
                try {
                    yield this._runTest(this._test.timeout || timeout);
                }
                catch (error) {
                    throw error;
                }
                finally {
                    yield this._teardown();
                }
            }
        });
    }
    _runTest(timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const timeoutCheck = setTimeout(() => {
                    reject(new errors_1.TestTimeoutError(timeout));
                }, timeout);
                try {
                    yield this._execute();
                    resolve();
                }
                catch (exception) {
                    reject(exception);
                }
                finally {
                    clearTimeout(timeoutCheck);
                }
            }));
        });
    }
    _execute() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._testFixture.fixture[this._test.key].apply(this._testFixture.fixture, this._testCase.caseArguments);
        });
    }
    _setup() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._runFunctionsByMetaDataKey(alsatian_core_1.METADATA_KEYS.SETUP);
        });
    }
    _teardown() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._runFunctionsByMetaDataKey(alsatian_core_1.METADATA_KEYS.TEARDOWN);
        });
    }
    _runFunctionsByMetaDataKey(metadataKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const functions = Reflect.getMetadata(metadataKey, this._testFixture.fixture);
            if (functions) {
                for (const func of functions) {
                    yield this._runFunctionFromMetadata(func);
                }
            }
        });
    }
    _runFunctionFromMetadata(funcMetadata) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._testFixture.fixture[funcMetadata.propertyKey].call(this.testFixture.fixture);
        });
    }
}
exports.TestItem = TestItem;
//# sourceMappingURL=test-item.js.map