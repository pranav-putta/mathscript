"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const alsatian_core_1 = require("../alsatian-core");
const test_plan_1 = require("./test-plan");
const test_set_run_info_1 = require("./test-set-run-info");
const warn_1 = require("../maintenance/warn");
class TestRunner {
    constructor(outputStream) {
        this._onTestCompleteCBs = [];
        if (outputStream !== undefined) {
            this._outputStream = outputStream;
        }
        else {
            this._outputStream = new alsatian_core_1.TestOutputStream();
        }
    }
    get outputStream() {
        return this._outputStream;
    }
    run(testSet, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const testPlan = new test_plan_1.TestPlan(testSet);
            if (testPlan.testItems.length === 0) {
                throw new Error("no tests to run.");
            }
            if (!timeout) {
                timeout = 500;
            }
            const testSetResults = new alsatian_core_1.TestSetResults();
            this._outputStream.emitVersion();
            this._outputStream.emitPlan(testPlan.testItems.length);
            const testSetRunInfo = new test_set_run_info_1.TestSetRunInfo(testPlan, testSetResults, timeout);
            yield this._runTests(testSetRunInfo, testSetResults);
        });
    }
    onTestComplete(testCompleteCB) {
        this._onTestCompleteCBs.push(testCompleteCB);
    }
    _runTests(testSetRunInfo, results) {
        return __awaiter(this, void 0, void 0, function* () {
            const testItems = testSetRunInfo.testPlan.testItems;
            const testFixtures = this._getTestFixtures(testItems);
            for (const testFixture of testFixtures) {
                const testFixtureItems = testItems.filter(testItem => testItem.testFixture === testFixture);
                yield this._setupFixture(testFixture.fixture);
                this._outputStream.emitFixture(testFixture);
                const testFixtureResults = results.addTestFixtureResult(testFixture);
                for (const testItem of testFixtureItems) {
                    const result = yield this._getTestItemResult(testItem, testSetRunInfo, testFixtureResults);
                    this._onTestCompleteCBs.forEach(onTestCompleteCB => {
                        onTestCompleteCB({
                            error: result.error,
                            outcome: result.outcome,
                            test: testItem.test,
                            testCase: testItem.testCase,
                            testFixture: testItem.testFixture,
                            testId: testSetRunInfo.testPlan.testItems.indexOf(testItem) + 1
                        });
                    });
                    this._outputStream.emitResult(testItems.indexOf(testItem) + 1, result);
                }
                yield this._teardownFixture(testFixture.fixture);
            }
            warn_1.Warner.warnings.forEach(warning => this.outputStream.emitWarning(warning));
            this._outputStream.end();
        });
    }
    _getTestFixtures(testItems) {
        return testItems
            .map(testItem => testItem.testFixture)
            .filter((fixture, index, array) => array.indexOf(fixture) === index);
    }
    _getTestItemResult(testItem, testSetRunInfo, testFixtureResults) {
        return __awaiter(this, void 0, void 0, function* () {
            let testResults = testFixtureResults.testResults.find(result => result.test === testItem.test);
            if (testResults === undefined) {
                testResults = testFixtureResults.addTestResult(testItem.test);
            }
            try {
                yield testItem.run(testSetRunInfo.timeout);
                return testResults.addTestCaseResult(testItem.testCase.caseArguments);
            }
            catch (e) {
                return testResults.addTestCaseResult(testItem.testCase.caseArguments, e);
            }
        });
    }
    _setupFixture(fixture) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._runFixtureFunctions(fixture, alsatian_core_1.METADATA_KEYS.SETUP_FIXTURE);
        });
    }
    _teardownFixture(fixture) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._runFixtureFunctions(fixture, alsatian_core_1.METADATA_KEYS.TEARDOWN_FIXTURE);
        });
    }
    _runFixtureFunctions(fixture, metadataKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const fixtureFunctions = Reflect.getMetadata(metadataKey, fixture);
            if (fixtureFunctions) {
                for (const fixtureFunction of fixtureFunctions) {
                    yield fixture[fixtureFunction.propertyKey].call(fixture);
                }
            }
        });
    }
}
exports.TestRunner = TestRunner;
//# sourceMappingURL=test-runner.js.map