"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const errors_1 = require("./errors");
const results_1 = require("./results");
const stringification_1 = require("./stringification");
const js_yaml_1 = require("js-yaml");
class TestOutputStream extends stream_1.Readable {
    _read() { }
    end() {
        this.push(null);
    }
    emitVersion() {
        this._writeOut("TAP version 13\n");
    }
    emitPlan(testCount) {
        this._writeOut(`1..${testCount}\n`);
    }
    emitFixture(fixture) {
        this._writeOut(`# FIXTURE ${fixture.description}\n`);
    }
    emitLog(...logs) {
        this._writeLogs(logs, "LOG");
    }
    emitWarning(...warnings) {
        this._writeLogs(warnings, "WARN");
    }
    emitResult(testId, result) {
        const outcome = result.outcome;
        if (outcome === results_1.TestOutcome.Pass) {
            this._emitPass(testId, result);
        }
        else if (outcome === results_1.TestOutcome.Fail ||
            outcome === results_1.TestOutcome.Error) {
            this._emitFail(testId, result);
        }
        else if (outcome === results_1.TestOutcome.Skip) {
            this._emitSkip(testId, result);
        }
        else {
            throw new TypeError(`Invalid test outcome: ${outcome}`);
        }
    }
    _writeLogs(logs, level) {
        this._writeOut(`# ${level}: ${logs.join(" ")}\n`);
    }
    _writeOut(message) {
        this.push(message);
    }
    _emitPass(testId, result) {
        this._writeOut(`ok ${testId} ${result.description}\n`);
    }
    _emitSkip(testId, result) {
        const test = result.testResults.test;
        const reasonString = test.ignoreReason ? ` ${test.ignoreReason}` : "";
        this._writeOut(`ok ${testId} ${result.description} # skip${reasonString}\n`);
    }
    _emitFail(testId, result) {
        this._writeOut(`not ok ${testId} ${result.description}\n`);
        if (result.error && result.error.name === errors_1.MatchError.name) {
            this._writeMatchErrorOutput(result.error, result.logs);
        }
        else {
            this._writeUnhandledErrorOutput(result.error, result.logs);
        }
    }
    _writeMatchErrorOutput(error, logs) {
        const sanitisedMessage = error.message
            .replace(/\\/g, "\\\\")
            .replace(/"/g, '\\"');
        const sanitisedActual = stringification_1.stringify(error.actual);
        const sanitisedExpected = stringification_1.stringify(error.expected);
        this._writeFailure(sanitisedMessage, sanitisedActual, sanitisedExpected, this.extrasWithLogs(error.extras, logs));
    }
    _writeUnhandledErrorOutput(error, logs) {
        this._writeFailure("The test threw an unhandled error.", "an unhandled error", "no unhandled errors to be thrown", error instanceof Error
            ? this.extrasWithLogs({
                type: error.name,
                message: error.message,
                stack: error.stack || "no stack found"
            }, logs)
            : undefined);
    }
    extrasWithLogs(extras, logs) {
        if (logs && logs.length) {
            return Object.assign({ logs: logs.map(x => x.value).join("\n") }, extras);
        }
        return extras;
    }
    _writeFailure(message, actual, expected, details) {
        const output = {
            message,
            severity: "fail",
            data: {
                got: actual,
                expect: expected,
                details
            }
        };
        if (output.data.details === undefined) {
            delete output.data.details;
        }
        this._writeOut(` ---\n${js_yaml_1.safeDump(output)
            .split("\n")
            .map(s => ` ${s}`)
            .join("\n")}...\n`);
    }
}
exports.TestOutputStream = TestOutputStream;
//# sourceMappingURL=test-output-stream.js.map