"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const diff_1 = require("./diff");
const empty_matcher_1 = require("./empty-matcher");
class ObjectMatcher extends empty_matcher_1.EmptyMatcher {
    toEqual(expectedValue) {
        if (Buffer.isBuffer(expectedValue) || Buffer.isBuffer(this.actualValue)) {
            this._checkTypeMatcherEqual(expectedValue, this.buffersEqual);
        }
        else {
            this._checkTypeMatcherEqual(expectedValue, this.objectsEqual);
        }
    }
    buffersEqual(expectedValue) {
        this._registerMatcher(this._checkBuffersAreEqual(expectedValue, this.actualValue) === this.shouldMatch, `Expected values ${!this.shouldMatch ? "not " : ""}to be equal`, expectedValue, {
            diff: diff_1.diff(expectedValue, this.actualValue)
        });
    }
    _checkBuffersAreEqual(buffer, other) {
        if (this._isBufferable(other)) {
            const otherBuffer = Buffer.isBuffer(other)
                ? other
                : Buffer.from(other);
            return buffer.equals(otherBuffer);
        }
        else {
            return false;
        }
    }
    _isBufferable(obj) {
        return ("string" === typeof obj ||
            Buffer.isBuffer(obj) ||
            Array.isArray(obj) ||
            obj instanceof ArrayBuffer ||
            (null != obj &&
                "object" === typeof obj &&
                obj.hasOwnProperty("length") &&
                "number" === typeof obj.length &&
                (obj.length === 0 || (obj.length > 0 && obj.length - 1 in obj))));
    }
    objectsEqual(expectedValue) {
        this._registerMatcher(this._checkObjectsAreDeepEqual(expectedValue, this.actualValue) === this.shouldMatch, `Expected objects ${!this.shouldMatch ? "not " : ""}to be equal`, expectedValue, {
            diff: diff_1.diff(expectedValue, this.actualValue)
        });
    }
    _checkObjectsAreDeepEqual(objectA, objectB) {
        if (Array.isArray(objectA) !== Array.isArray(objectB)) {
            return false;
        }
        const OBJECT_A_KEYS = Object.keys(objectA);
        const OBJECT_B_KEYS = Object.keys(objectB);
        if (OBJECT_A_KEYS.length !== OBJECT_B_KEYS.length) {
            return false;
        }
        for (const objectAKey of OBJECT_A_KEYS) {
            if (objectA[objectAKey] !== objectB[objectAKey]) {
                if (objectA[objectAKey] === null ||
                    typeof objectA[objectAKey] !== "object" ||
                    this._checkObjectsAreDeepEqual(objectA[objectAKey], objectB[objectAKey]) === false) {
                    return false;
                }
            }
        }
        return true;
    }
}
exports.ObjectMatcher = ObjectMatcher;
//# sourceMappingURL=object-matcher.js.map