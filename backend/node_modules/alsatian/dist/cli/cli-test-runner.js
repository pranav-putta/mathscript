"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tap_bark_1 = require("tap-bark");
const alsatian_core_1 = require("../core/alsatian-core");
class CliTestRunner {
    constructor(_testRunner) {
        this._testRunner = _testRunner;
        if (!_testRunner) {
            throw new TypeError("_testRunner must not be null or undefined.");
        }
    }
    static create() {
        const outputStream = new alsatian_core_1.TestOutputStream();
        const testRunner = new alsatian_core_1.TestRunner(outputStream);
        return new CliTestRunner(testRunner);
    }
    run(userArguments) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageJson = yield Promise.resolve().then(() => require("../package.json"));
            if (userArguments.versionRequested) {
                process.stdout.write("alsatian version " + packageJson.version);
                return;
            }
            if (userArguments.helpRequested) {
                this._printHelp(packageJson.version);
                return;
            }
            const testSet = alsatian_core_1.TestSet.create();
            testSet.addTestsFromFiles(userArguments.fileGlobs);
            if (userArguments.tap) {
                this._testRunner.outputStream.pipe(process.stdout);
            }
            else {
                this._createTapBarkReporter(userArguments.hideProgress);
            }
            try {
                yield this._testRunner.run(testSet, userArguments.timeout);
            }
            catch (error) {
                this._handleTestSetRunError(error);
            }
        });
    }
    _createTapBarkReporter(hideProgressArgument) {
        const hideProgress = (process.env.CI || hideProgressArgument);
        const bark = tap_bark_1.TapBark.create(hideProgress === false);
        this._testRunner.outputStream
            .pipe(bark.getPipeable())
            .pipe(process.stdout);
    }
    _handleTestSetRunError(error) {
        process.stderr.write(error.message + "\n");
        process.exit(1);
    }
    _printHelp(version) {
        process.stdout.write("\n\n" +
            "alsatian version " +
            version +
            "\n" +
            "=========================\n" +
            "CLI options\n" +
            "=========================\n" +
            "HELP:    --help / -h                      " +
            "(outputs CLI information)\n" +
            "VERSION: --version / -v                   " +
            "(outputs the version of the CLI)\n" +
            "TAP:     --tap / -T                       " +
            "(runs alsatian with TAP output)\n" +
            "TIMEOUT: --timeout [number] / -t [number] " +
            "(sets the timeout period for tests in milliseconds - default 500)\n" +
            "HIDE PROGRESS: --hide-progress / -H " +
            "(hides progress from console)\n" +
            "\n");
    }
}
exports.CliTestRunner = CliTestRunner;
//# sourceMappingURL=cli-test-runner.js.map