{"ast":null,"code":"import { VariableScope } from \"./ast\";\nimport { ParsingError, RuntimeError } from \"./errors\";\nimport { rref, transpose, det, sqrt, identity } from \"./lib\";\nimport { confidenceIntervalProportions } from \"./lib/functions\";\nimport { Stack } from \"./util\";\nlet global_scope = {};\nlet global_functions = {\n  rref: rref,\n  trans: transpose,\n  transpose: transpose,\n  det: det,\n  determinant: det,\n  q: sqrt,\n  sqrt: sqrt,\n  identity: identity,\n  cip: confidenceIntervalProportions\n};\nlet local_functions = {};\nlet function_stack = new Stack();\n/**\n * retrieve a variable from global or local scope\n * @param name variable name\n * @param scope variable scope\n */\n\nexport function findVariable(name, scope) {\n  let val = undefined;\n\n  if (scope == VariableScope.global) {\n    val = global_scope[name];\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n\n    if (currentBlock) {\n      val = currentBlock.variables[name];\n    } else {\n      throw new RuntimeError(\"function call stack was empty, something weird happened.\");\n    }\n  }\n\n  if (val) {\n    return val;\n  } else {\n    throw new RuntimeError(`variable ${name} wasn't declared!`);\n  }\n}\n/**\n * sets variable to local and global scope\n * @param name variable name\n * @param value variable value\n * @param scope variable scope\n */\n\nexport function assignVariable(name, value, scope) {\n  if (scope == VariableScope.global) {\n    global_scope[name] = value;\n    return value;\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n\n    if (currentBlock) {\n      currentBlock.variables[name] = value;\n      return value;\n    }\n  }\n\n  throw new RuntimeError(\"function call stack was empty, something weird happened\");\n}\n/**\n * generate a variables component\n * @param vars parameter nodes\n */\n\nfunction evaluateLocalFunctionParameters(params, vals) {\n  let variables = {};\n\n  if (params.length != vals.length) {\n    throw new RuntimeError(`expected ${params.length} parameters, but got ${vals.length}`);\n  }\n\n  for (let i = 0; i < params.length; i++) {\n    variables[params[i].name] = vals[i].eval();\n  }\n\n  return variables;\n}\n/**\n * execute a local function\n * @param func function to execute\n */\n\n\nfunction executeLocalFunction(f, args) {\n  let func = local_functions[f];\n  let params = evaluateLocalFunctionParameters(func.args, args);\n  function_stack.push({\n    functionName: func.name,\n    variables: params\n  });\n  let out;\n\n  for (let statement of func.exprs) {\n    out = statement.eval();\n  }\n\n  function_stack.pop();\n  return out;\n}\n/**\n * executes any function\n * @param f function name\n * @param args list of parameters\n */\n\n\nexport function executeFunction(f, args) {\n  if (f in global_functions) {\n    let func = global_functions[f];\n    let params = [];\n\n    for (let arg of args) {\n      params.push(arg.eval());\n    }\n\n    return func.apply(null, params);\n  } else if (f in local_functions) {\n    return executeLocalFunction(f, args);\n  } else {\n    throw new ParsingError(`function ${f} couldn't be found`);\n  }\n}\n/**\n * create a new function\n * @param func function node\n */\n\nexport function createUserDefinedFunction(func) {\n  if (func.name in global_functions) {\n    throw new ParsingError(\"conflicting function definition name: \" + func.name);\n  }\n\n  local_functions[func.name] = func;\n}\nexport function clearScopes() {\n  global_scope = {};\n  local_functions = {};\n  function_stack.clear();\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/mathscript/app/src/interpreter/global.ts"],"names":["VariableScope","ParsingError","RuntimeError","rref","transpose","det","sqrt","identity","confidenceIntervalProportions","Stack","global_scope","global_functions","trans","determinant","q","cip","local_functions","function_stack","findVariable","name","scope","val","undefined","global","procedure","currentBlock","peek","variables","assignVariable","value","evaluateLocalFunctionParameters","params","vals","length","i","eval","executeLocalFunction","f","args","func","push","functionName","out","statement","exprs","pop","executeFunction","arg","apply","createUserDefinedFunction","clearScopes","clear"],"mappings":"AAAA,SAIEA,aAJF,QAKO,OALP;AAOA,SAASC,YAAT,EAAuBC,YAAvB,QAA2C,UAA3C;AACA,SAASC,IAAT,EAAeC,SAAf,EAA0BC,GAA1B,EAA+BC,IAA/B,EAAqCC,QAArC,QAAqD,OAArD;AACA,SAASC,6BAAT,QAA8C,iBAA9C;AACA,SAASC,KAAT,QAAsB,QAAtB;AAkBA,IAAIC,YAAuB,GAAG,EAA9B;AACA,IAAIC,gBAAkC,GAAG;AACvCR,EAAAA,IAAI,EAAEA,IADiC;AAEvCS,EAAAA,KAAK,EAAER,SAFgC;AAGvCA,EAAAA,SAAS,EAAEA,SAH4B;AAIvCC,EAAAA,GAAG,EAAEA,GAJkC;AAKvCQ,EAAAA,WAAW,EAAER,GAL0B;AAMvCS,EAAAA,CAAC,EAAER,IANoC;AAOvCA,EAAAA,IAAI,EAAEA,IAPiC;AAQvCC,EAAAA,QAAQ,EAAEA,QAR6B;AASvCQ,EAAAA,GAAG,EAAEP;AATkC,CAAzC;AAWA,IAAIQ,eAAgC,GAAG,EAAvC;AACA,IAAIC,cAAoC,GAAG,IAAIR,KAAJ,EAA3C;AAEA;;;;;;AAKA,OAAO,SAASS,YAAT,CACLC,IADK,EAELC,KAFK,EAGY;AACjB,MAAIC,GAAG,GAAGC,SAAV;;AACA,MAAIF,KAAK,IAAIpB,aAAa,CAACuB,MAA3B,EAAmC;AACjCF,IAAAA,GAAG,GAAGX,YAAY,CAACS,IAAD,CAAlB;AACD,GAFD,MAEO,IAAIC,KAAK,IAAIpB,aAAa,CAACwB,SAA3B,EAAsC;AAC3C,QAAIC,YAAY,GAAGR,cAAc,CAACS,IAAf,EAAnB;;AACA,QAAID,YAAJ,EAAkB;AAChBJ,MAAAA,GAAG,GAAGI,YAAY,CAACE,SAAb,CAAuBR,IAAvB,CAAN;AACD,KAFD,MAEO;AACL,YAAM,IAAIjB,YAAJ,CACJ,0DADI,CAAN;AAGD;AACF;;AACD,MAAImB,GAAJ,EAAS;AACP,WAAOA,GAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAInB,YAAJ,CAAkB,YAAWiB,IAAK,mBAAlC,CAAN;AACD;AACF;AAED;;;;;;;AAMA,OAAO,SAASS,cAAT,CAAwBT,IAAxB,EAAsCU,KAAtC,EAAkDT,KAAlD,EAAwE;AAC7E,MAAIA,KAAK,IAAIpB,aAAa,CAACuB,MAA3B,EAAmC;AACjCb,IAAAA,YAAY,CAACS,IAAD,CAAZ,GAAqBU,KAArB;AACA,WAAOA,KAAP;AACD,GAHD,MAGO,IAAIT,KAAK,IAAIpB,aAAa,CAACwB,SAA3B,EAAsC;AAC3C,QAAIC,YAAY,GAAGR,cAAc,CAACS,IAAf,EAAnB;;AACA,QAAID,YAAJ,EAAkB;AAChBA,MAAAA,YAAY,CAACE,SAAb,CAAuBR,IAAvB,IAA+BU,KAA/B;AACA,aAAOA,KAAP;AACD;AACF;;AACD,QAAM,IAAI3B,YAAJ,CACJ,yDADI,CAAN;AAGD;AAED;;;;;AAIA,SAAS4B,+BAAT,CACEC,MADF,EAEEC,IAFF,EAGa;AACX,MAAIL,SAAoB,GAAG,EAA3B;;AACA,MAAII,MAAM,CAACE,MAAP,IAAiBD,IAAI,CAACC,MAA1B,EAAkC;AAChC,UAAM,IAAI/B,YAAJ,CACH,YAAW6B,MAAM,CAACE,MAAO,wBAAuBD,IAAI,CAACC,MAAO,EADzD,CAAN;AAGD;;AACD,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACE,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;AACtCP,IAAAA,SAAS,CAACI,MAAM,CAACG,CAAD,CAAN,CAAUf,IAAX,CAAT,GAA4Ba,IAAI,CAACE,CAAD,CAAJ,CAAQC,IAAR,EAA5B;AACD;;AACD,SAAOR,SAAP;AACD;AAED;;;;;;AAIA,SAASS,oBAAT,CAA8BC,CAA9B,EAAyCC,IAAzC,EAAsD;AACpD,MAAIC,IAAI,GAAGvB,eAAe,CAACqB,CAAD,CAA1B;AACA,MAAIN,MAAM,GAAGD,+BAA+B,CAACS,IAAI,CAACD,IAAN,EAAYA,IAAZ,CAA5C;AACArB,EAAAA,cAAc,CAACuB,IAAf,CAAoB;AAAEC,IAAAA,YAAY,EAAEF,IAAI,CAACpB,IAArB;AAA2BQ,IAAAA,SAAS,EAAEI;AAAtC,GAApB;AACA,MAAIW,GAAJ;;AACA,OAAK,IAAIC,SAAT,IAAsBJ,IAAI,CAACK,KAA3B,EAAkC;AAChCF,IAAAA,GAAG,GAAGC,SAAS,CAACR,IAAV,EAAN;AACD;;AACDlB,EAAAA,cAAc,CAAC4B,GAAf;AACA,SAAOH,GAAP;AACD;AAED;;;;;;;AAKA,OAAO,SAASI,eAAT,CAAyBT,CAAzB,EAAoCC,IAApC,EAAiD;AACtD,MAAID,CAAC,IAAI1B,gBAAT,EAA2B;AACzB,QAAI4B,IAAI,GAAG5B,gBAAgB,CAAC0B,CAAD,CAA3B;AACA,QAAIN,MAAoB,GAAG,EAA3B;;AACA,SAAK,IAAIgB,GAAT,IAAgBT,IAAhB,EAAsB;AACpBP,MAAAA,MAAM,CAACS,IAAP,CAAYO,GAAG,CAACZ,IAAJ,EAAZ;AACD;;AACD,WAAOI,IAAI,CAACS,KAAL,CAAW,IAAX,EAAiBjB,MAAjB,CAAP;AACD,GAPD,MAOO,IAAIM,CAAC,IAAIrB,eAAT,EAA0B;AAC/B,WAAOoB,oBAAoB,CAACC,CAAD,EAAIC,IAAJ,CAA3B;AACD,GAFM,MAEA;AACL,UAAM,IAAIrC,YAAJ,CAAkB,YAAWoC,CAAE,oBAA/B,CAAN;AACD;AACF;AAED;;;;;AAIA,OAAO,SAASY,yBAAT,CAAmCV,IAAnC,EAAkE;AACvE,MAAIA,IAAI,CAACpB,IAAL,IAAaR,gBAAjB,EAAmC;AACjC,UAAM,IAAIV,YAAJ,CACJ,2CAA2CsC,IAAI,CAACpB,IAD5C,CAAN;AAGD;;AACDH,EAAAA,eAAe,CAACuB,IAAI,CAACpB,IAAN,CAAf,GAA6BoB,IAA7B;AACD;AAED,OAAO,SAASW,WAAT,GAAuB;AAC5BxC,EAAAA,YAAY,GAAG,EAAf;AACAM,EAAAA,eAAe,GAAG,EAAlB;AACAC,EAAAA,cAAc,CAACkC,KAAf;AACD","sourcesContent":["import {\n  AST,\n  ProcedureDefinitionNode,\n  VariableNode,\n  VariableScope,\n} from \"./ast\";\nimport { Computable } from \"./computable\";\nimport { ParsingError, RuntimeError } from \"./errors\";\nimport { rref, transpose, det, sqrt, identity } from \"./lib\";\nimport { confidenceIntervalProportions } from \"./lib/functions\";\nimport { Stack } from \"./util\";\n\ntype Function = (...args: any[]) => any;\n\ninterface Variables {\n  [key: string]: any;\n}\ninterface GlobalProcedures {\n  [key: string]: Function;\n}\ninterface LocalProcedures {\n  [key: string]: ProcedureDefinitionNode;\n}\ninterface FunctionBlock {\n  functionName: string;\n  variables: Variables;\n}\n\nlet global_scope: Variables = {};\nlet global_functions: GlobalProcedures = {\n  rref: rref,\n  trans: transpose,\n  transpose: transpose,\n  det: det,\n  determinant: det,\n  q: sqrt,\n  sqrt: sqrt,\n  identity: identity,\n  cip: confidenceIntervalProportions,\n};\nlet local_functions: LocalProcedures = {};\nlet function_stack: Stack<FunctionBlock> = new Stack();\n\n/**\n * retrieve a variable from global or local scope\n * @param name variable name\n * @param scope variable scope\n */\nexport function findVariable(\n  name: string,\n  scope: VariableScope\n): any | undefined {\n  let val = undefined;\n  if (scope == VariableScope.global) {\n    val = global_scope[name];\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n    if (currentBlock) {\n      val = currentBlock.variables[name];\n    } else {\n      throw new RuntimeError(\n        \"function call stack was empty, something weird happened.\"\n      );\n    }\n  }\n  if (val) {\n    return val;\n  } else {\n    throw new RuntimeError(`variable ${name} wasn't declared!`);\n  }\n}\n\n/**\n * sets variable to local and global scope\n * @param name variable name\n * @param value variable value\n * @param scope variable scope\n */\nexport function assignVariable(name: string, value: any, scope: VariableScope) {\n  if (scope == VariableScope.global) {\n    global_scope[name] = value;\n    return value;\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n    if (currentBlock) {\n      currentBlock.variables[name] = value;\n      return value;\n    }\n  }\n  throw new RuntimeError(\n    \"function call stack was empty, something weird happened\"\n  );\n}\n\n/**\n * generate a variables component\n * @param vars parameter nodes\n */\nfunction evaluateLocalFunctionParameters(\n  params: VariableNode[],\n  vals: AST[]\n): Variables {\n  let variables: Variables = {};\n  if (params.length != vals.length) {\n    throw new RuntimeError(\n      `expected ${params.length} parameters, but got ${vals.length}`\n    );\n  }\n  for (let i = 0; i < params.length; i++) {\n    variables[params[i].name] = vals[i].eval();\n  }\n  return variables;\n}\n\n/**\n * execute a local function\n * @param func function to execute\n */\nfunction executeLocalFunction(f: string, args: AST[]) {\n  let func = local_functions[f];\n  let params = evaluateLocalFunctionParameters(func.args, args);\n  function_stack.push({ functionName: func.name, variables: params });\n  let out: any;\n  for (let statement of func.exprs) {\n    out = statement.eval();\n  }\n  function_stack.pop();\n  return out;\n}\n\n/**\n * executes any function\n * @param f function name\n * @param args list of parameters\n */\nexport function executeFunction(f: string, args: AST[]) {\n  if (f in global_functions) {\n    let func = global_functions[f];\n    let params: Computable[] = [];\n    for (let arg of args) {\n      params.push(arg.eval());\n    }\n    return func.apply(null, params);\n  } else if (f in local_functions) {\n    return executeLocalFunction(f, args);\n  } else {\n    throw new ParsingError(`function ${f} couldn't be found`);\n  }\n}\n\n/**\n * create a new function\n * @param func function node\n */\nexport function createUserDefinedFunction(func: ProcedureDefinitionNode) {\n  if (func.name in global_functions) {\n    throw new ParsingError(\n      \"conflicting function definition name: \" + func.name\n    );\n  }\n  local_functions[func.name] = func;\n}\n\nexport function clearScopes() {\n  global_scope = {};\n  local_functions = {};\n  function_stack.clear();\n}\n"]},"metadata":{},"sourceType":"module"}