{"ast":null,"code":"import { assignVariable, createUserDefinedFunction, executeFunction, findVariable } from \"./global\";\nimport { Numeric, UnevaluatedMatrix, isComputable, computeResult, isLogical } from \"./computable\";\nimport { ParsingError, RuntimeError, SymbolError, UndeclaredVariableError } from \"./errors\";\nimport { TokenType } from \"./token\";\n/**\n * abstract syntax tree base class\n */\n\nexport class AbstractSyntaxTree {}\n/**\n * compound statements go here\n */\n\nexport class CompoundNode extends AbstractSyntaxTree {\n  constructor(nodes = []) {\n    super();\n    this.children = void 0;\n    this.children = nodes;\n  }\n\n  eval() {\n    let results = [];\n\n    for (let child of this.children) {\n      try {\n        let val = child.eval();\n\n        if (val) {\n          results.push(val);\n        }\n      } catch (exception) {\n        results.push(exception.message);\n      }\n    }\n\n    return results;\n  }\n\n}\n/**\n * assigns a variable to its value\n */\n\nexport class AssignNode extends AbstractSyntaxTree {\n  constructor(left, token, right) {\n    super();\n    this.left = void 0;\n    this.right = void 0;\n    this.left = left;\n    this.right = right;\n  }\n\n  eval() {\n    let name = this.left.name;\n    let val = this.right.eval();\n    assignVariable(name, val, this.left.scope);\n    return `${name} = ${val}`;\n  }\n\n}\n/**\n * computes a procedure\n */\n\nexport class ProcedureCallNode extends AbstractSyntaxTree {\n  get args() {\n    return this._args;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  constructor(token, args) {\n    super();\n    this._name = void 0;\n    this._args = void 0;\n    this._name = token.value;\n    this._args = args;\n  }\n\n  eval() {\n    let result = executeFunction(this.name, this.args);\n    return result;\n  }\n\n}\nexport class ProcedureDefinitionNode extends AbstractSyntaxTree {\n  constructor(name, args, block) {\n    super();\n    this._name = void 0;\n    this._args = void 0;\n    this._exprs = void 0;\n    this._name = name;\n    this._args = args;\n    let newStatements = []; // make sure statements are not empty\n\n    for (let arg of block.children) {\n      if (!(arg instanceof EmptyNode)) {\n        newStatements.push(arg);\n      }\n    }\n\n    if (newStatements.length == 0) {\n      throw new ParsingError(`no definition for function '${this.name}'`);\n    }\n\n    this._exprs = newStatements;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get args() {\n    return this._args;\n  }\n\n  get exprs() {\n    return this._exprs;\n  }\n\n  eval() {\n    createUserDefinedFunction(this);\n    return `created function '${this.name}'`;\n  }\n\n}\n/**\n * empty node, doesn't do anything\n */\n\nexport class EmptyNode extends AbstractSyntaxTree {\n  eval() {\n    return;\n  }\n\n  static isEmptyNode(el) {\n    return el instanceof EmptyNode;\n  }\n\n}\n/**\n * node that returns a computable value when evaluated\n */\n\nexport class ComputableNode extends AbstractSyntaxTree {}\n/**\n * binary operator node\n * takes a (left, operator, right)\n */\n\nexport class BinaryOperatorNode extends ComputableNode {\n  /**\n   * left node in binary operation\n   */\n\n  /**\n   * right node in binary operation\n   */\n\n  /**\n   * operator\n   */\n  constructor(left, operator, right) {\n    super();\n    this.left = void 0;\n    this.right = void 0;\n    this.operator = void 0;\n    this.left = left;\n    this.right = right;\n    this.operator = operator;\n  }\n\n  eval() {\n    let l = this.left.eval();\n    let r = this.right.eval();\n\n    if (isComputable(l) && isComputable(r)) {\n      return computeResult(l, r, this.operator.type).result;\n    }\n\n    throw new ParsingError(`cannot operate on two non-computable values: ${l} and ${r}`);\n  }\n\n}\nexport class TernaryOperator extends ComputableNode {\n  constructor(b, t, f) {\n    super();\n    this.boolExpr = void 0;\n    this.trueExpr = void 0;\n    this.falseExpr = void 0;\n    this.boolExpr = b;\n    this.trueExpr = t;\n    this.falseExpr = f;\n  }\n\n  eval() {\n    let out = this.boolExpr.eval();\n\n    if (isLogical(out)) {\n      if (out.boolVal) {\n        return this.trueExpr.eval();\n      } else {\n        return this.falseExpr.eval();\n      }\n    } else {\n      throw new RuntimeError(\"ternary operator expects a boolean expression\");\n    }\n  }\n\n}\nexport let VariableScope;\n/**\n * holds a variable and its value\n */\n\n(function (VariableScope) {\n  VariableScope[VariableScope[\"global\"] = 0] = \"global\";\n  VariableScope[VariableScope[\"procedure\"] = 1] = \"procedure\";\n})(VariableScope || (VariableScope = {}));\n\nexport class VariableNode extends ComputableNode {\n  get name() {\n    return this._name;\n  }\n\n  get scope() {\n    return this._scope;\n  }\n\n  set scope(newScope) {\n    this._scope = newScope;\n  }\n\n  constructor(token, scope) {\n    super();\n    this._name = void 0;\n    this._scope = void 0;\n    this._name = token.value;\n    this._scope = scope;\n  }\n\n  eval() {\n    let name = this.name;\n    let val = findVariable(name, this.scope);\n\n    if (val) {\n      console.log(`${name} = ${val}`);\n      return val;\n    } else {\n      throw new UndeclaredVariableError(`${name} was not declared!`);\n    }\n  }\n  /**\n   * check if an array of nodes is a list of variables\n   * @param arr list of tree nodes\n   */\n\n\n  static isVariableArray(arr) {\n    for (let arg of arr) {\n      if (!(arg instanceof VariableNode)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n/**\n * stores a single value: number or matrix\n */\n\nexport class SingleValueNode extends ComputableNode {\n  constructor(value) {\n    super();\n    this.value = void 0;\n    this.value = value;\n  }\n\n  eval() {\n    // evaluate unevaluated matrix if not done already\n    if (UnevaluatedMatrix.isUnevaluatedMatrix(this.value)) {\n      this.value = this.value.evaluate();\n    }\n\n    return this.value;\n  }\n\n}\n/**\n * holds a unary operator\n */\n\nexport class UnaryOperatorNode extends ComputableNode {\n  constructor(token, next) {\n    super();\n    this.token = void 0;\n    this.next = void 0;\n    this.token = token;\n    this.next = next;\n  }\n\n  eval() {\n    if (this.token.type == TokenType.plus) {\n      return this.next.eval();\n    } else if (this.token.type == TokenType.minus) {\n      return this.next.eval().mul(new Numeric(-1)).result;\n    } else {\n      throw new SymbolError(\"unexpected unary operator: \" + this.token.type.toString());\n    }\n  }\n\n}\nexport function isComputableNode(node) {\n  return node instanceof ComputableNode;\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/app/src/interpreter/ast.ts"],"names":["assignVariable","createUserDefinedFunction","executeFunction","findVariable","Numeric","UnevaluatedMatrix","isComputable","computeResult","isLogical","ParsingError","RuntimeError","SymbolError","UndeclaredVariableError","TokenType","AbstractSyntaxTree","CompoundNode","constructor","nodes","children","eval","results","child","val","push","exception","message","AssignNode","left","token","right","name","scope","ProcedureCallNode","args","_args","_name","value","result","ProcedureDefinitionNode","block","_exprs","newStatements","arg","EmptyNode","length","exprs","isEmptyNode","el","ComputableNode","BinaryOperatorNode","operator","l","r","type","TernaryOperator","b","t","f","boolExpr","trueExpr","falseExpr","out","boolVal","VariableScope","VariableNode","_scope","newScope","console","log","isVariableArray","arr","SingleValueNode","isUnevaluatedMatrix","evaluate","UnaryOperatorNode","next","plus","minus","mul","toString","isComputableNode","node"],"mappings":"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","sourcesContent":["import {\n  assignVariable,\n  createUserDefinedFunction,\n  executeFunction,\n  findVariable,\n} from \"./global\";\nimport {\n  Computable,\n  Numeric,\n  UnevaluatedMatrix,\n  isComputable,\n  computeResult,\n  isLogical,\n} from \"./computable\";\nimport {\n  ParsingError,\n  RuntimeError,\n  SymbolError,\n  UndeclaredVariableError,\n} from \"./errors\";\nimport { SymbolToken, Token, TokenType } from \"./token\";\n\n/**\n * abstract syntax tree base class\n */\nexport abstract class AbstractSyntaxTree {\n  /**\n   * abstract evaluate method. visits all nodes in postorder traversal\n   */\n  abstract eval(): any;\n}\n\n/**\n * compound statements go here\n */\nexport class CompoundNode extends AbstractSyntaxTree {\n  children: AST[];\n\n  constructor(nodes: AST[] = []) {\n    super();\n    this.children = nodes;\n  }\n\n  eval() {\n    let results = [];\n    for (let child of this.children) {\n      try {\n        let val = child.eval();\n        if (val) {\n          results.push(val);\n        }\n      } catch (exception) {\n        results.push(exception.message);\n      }\n    }\n    return results;\n  }\n}\n\n/**\n * assigns a variable to its value\n */\nexport class AssignNode extends AbstractSyntaxTree {\n  private left: VariableNode;\n  private right: AST;\n\n  constructor(left: VariableNode, token: Token, right: AST) {\n    super();\n    this.left = left;\n    this.right = right;\n  }\n  eval() {\n    let name = this.left.name;\n    let val = this.right.eval();\n    assignVariable(name, val, this.left.scope);\n    return `${name} = ${val}`;\n  }\n}\n\n/**\n * computes a procedure\n */\nexport class ProcedureCallNode extends AbstractSyntaxTree {\n  private _name: string;\n  private _args: AST[];\n\n  public get args(): AST[] {\n    return this._args;\n  }\n\n  public get name(): string {\n    return this._name;\n  }\n\n  constructor(token: SymbolToken, args: AST[]) {\n    super();\n    this._name = token.value;\n    this._args = args;\n  }\n\n  eval() {\n    let result = executeFunction(this.name, this.args);\n    return result;\n  }\n}\n\nexport class ProcedureDefinitionNode extends AbstractSyntaxTree {\n  private _name: string;\n  private _args: VariableNode[];\n  private _exprs: AST[];\n\n  constructor(name: string, args: VariableNode[], block: CompoundNode) {\n    super();\n    this._name = name;\n    this._args = args;\n    let newStatements = [];\n    // make sure statements are not empty\n    for (let arg of block.children) {\n      if (!(arg instanceof EmptyNode)) {\n        newStatements.push(arg);\n      }\n    }\n    if (newStatements.length == 0) {\n      throw new ParsingError(`no definition for function '${this.name}'`);\n    }\n    this._exprs = newStatements;\n  }\n\n  public get name() {\n    return this._name;\n  }\n\n  public get args() {\n    return this._args;\n  }\n\n  public get exprs() {\n    return this._exprs;\n  }\n\n  eval(): string {\n    createUserDefinedFunction(this);\n    return `created function '${this.name}'`;\n  }\n}\n\n/**\n * empty node, doesn't do anything\n */\nexport class EmptyNode extends AbstractSyntaxTree {\n  eval() {\n    return;\n  }\n\n  static isEmptyNode(el: AST): el is EmptyNode {\n    return el instanceof EmptyNode;\n  }\n}\n/**\n * node that returns a computable value when evaluated\n */\nexport abstract class ComputableNode extends AbstractSyntaxTree {\n  abstract eval(): Computable;\n}\n\n/**\n * binary operator node\n * takes a (left, operator, right)\n */\nexport class BinaryOperatorNode extends ComputableNode {\n  /**\n   * left node in binary operation\n   */\n  private left: AST;\n  /**\n   * right node in binary operation\n   */\n  private right: AST;\n  /**\n   * operator\n   */\n  private operator: Token;\n\n  constructor(left: AST, operator: Token, right: AST) {\n    super();\n    this.left = left;\n    this.right = right;\n    this.operator = operator;\n  }\n\n  public eval(): Computable {\n    let l = this.left.eval();\n    let r = this.right.eval();\n\n    if (isComputable(l) && isComputable(r)) {\n      return computeResult(l, r, this.operator.type).result;\n    }\n\n    throw new ParsingError(\n      `cannot operate on two non-computable values: ${l} and ${r}`\n    );\n  }\n}\n\nexport class TernaryOperator extends ComputableNode {\n  private boolExpr: ComputableNode;\n  private trueExpr: ComputableNode;\n  private falseExpr: ComputableNode;\n\n  constructor(b: ComputableNode, t: ComputableNode, f: ComputableNode) {\n    super();\n    this.boolExpr = b;\n    this.trueExpr = t;\n    this.falseExpr = f;\n  }\n\n  eval(): Computable {\n    let out = this.boolExpr.eval();\n    if (isLogical(out)) {\n      if (out.boolVal) {\n        return this.trueExpr.eval();\n      } else {\n        return this.falseExpr.eval();\n      }\n    } else {\n      throw new RuntimeError(\"ternary operator expects a boolean expression\");\n    }\n  }\n}\n\nexport enum VariableScope {\n  global,\n  procedure,\n}\n/**\n * holds a variable and its value\n */\nexport class VariableNode extends ComputableNode {\n  private _name: string;\n  private _scope: VariableScope;\n\n  public get name(): string {\n    return this._name;\n  }\n\n  public get scope(): VariableScope {\n    return this._scope;\n  }\n\n  public set scope(newScope: VariableScope) {\n    this._scope = newScope;\n  }\n\n  constructor(token: SymbolToken, scope: VariableScope) {\n    super();\n    this._name = token.value;\n    this._scope = scope;\n  }\n  eval(): Computable {\n    let name = this.name;\n    let val = findVariable(name, this.scope);\n    if (val) {\n      console.log(`${name} = ${val}`);\n      return val;\n    } else {\n      throw new UndeclaredVariableError(`${name} was not declared!`);\n    }\n  }\n\n  /**\n   * check if an array of nodes is a list of variables\n   * @param arr list of tree nodes\n   */\n  static isVariableArray(arr: AST[]): arr is VariableNode[] {\n    for (let arg of arr) {\n      if (!(arg instanceof VariableNode)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n/**\n * stores a single value: number or matrix\n */\nexport class SingleValueNode extends ComputableNode {\n  private value: Computable | UnevaluatedMatrix;\n\n  constructor(value: Computable | UnevaluatedMatrix) {\n    super();\n    this.value = value;\n  }\n\n  public eval(): Computable {\n    // evaluate unevaluated matrix if not done already\n    if (UnevaluatedMatrix.isUnevaluatedMatrix(this.value)) {\n      this.value = this.value.evaluate();\n    }\n\n    return this.value;\n  }\n}\n\n/**\n * holds a unary operator\n */\nexport class UnaryOperatorNode extends ComputableNode {\n  private token: Token;\n  private next: ComputableNode;\n\n  constructor(token: Token, next: ComputableNode) {\n    super();\n    this.token = token;\n    this.next = next;\n  }\n\n  public eval(): Computable {\n    if (this.token.type == TokenType.plus) {\n      return this.next.eval();\n    } else if (this.token.type == TokenType.minus) {\n      return this.next.eval().mul(new Numeric(-1)).result;\n    } else {\n      throw new SymbolError(\n        \"unexpected unary operator: \" + this.token.type.toString()\n      );\n    }\n  }\n}\n\nexport function isComputableNode(node: AST): node is ComputableNode {\n  return node instanceof ComputableNode;\n}\n\nexport type AST = AbstractSyntaxTree;\nexport type CN = ComputableNode;\nexport type BinOp = BinaryOperatorNode;\nexport type SVN = SingleValueNode;\nexport type UnaryOp = UnaryOperatorNode;\n"]},"metadata":{},"sourceType":"module"}