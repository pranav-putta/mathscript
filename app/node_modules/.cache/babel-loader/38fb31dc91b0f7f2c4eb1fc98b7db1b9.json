{"ast":null,"code":"import { VariableScope } from \"./ast\";\nimport { ParsingError, RuntimeError } from \"./errors\";\nimport { rref, transpose, det, sqrt, identity } from \"./lib\";\nlet global_scope = {};\nlet global_functions = {\n  rref: rref,\n  trans: transpose,\n  transpose: transpose,\n  det: det,\n  determinant: det,\n  q: sqrt,\n  sqrt: sqrt,\n  identity: identity\n};\nlet local_functions = {};\nlet function_stack;\n/**\n * retrieve a variable from global or local scope\n * @param name variable name\n * @param scope variable scope\n */\n\nexport function findVariable(name, scope) {\n  let val = undefined;\n\n  if (scope == VariableScope.global) {\n    val = global_scope[name];\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n\n    if (currentBlock) {\n      val = currentBlock.variables[name];\n    } else {\n      throw new RuntimeError(\"function call stack was empty, something weird happened.\");\n    }\n  }\n\n  if (val) {\n    return val;\n  } else {\n    throw new RuntimeError(`variable ${name} wasn't declared!`);\n  }\n}\n/**\n * sets variable to local and global scope\n * @param name variable name\n * @param value variable value\n * @param scope variable scope\n */\n\nexport function assignVariable(name, value, scope) {\n  if (scope == VariableScope.global) {\n    global_scope[name] = value;\n    return value;\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n\n    if (currentBlock) {\n      currentBlock.variables[name] = value;\n      return value;\n    }\n  }\n\n  throw new RuntimeError(\"function call stack was empty, something weird happened\");\n}\n/**\n * execute a local function\n * @param func function to execute\n */\n\nfunction executeLocalFunction(f) {\n  let func = local_functions[f];\n  function_stack.push({\n    functionName: func.name,\n    variables: []\n  });\n  let out;\n\n  for (let statement of func.exprs) {\n    out = statement.eval();\n  }\n\n  function_stack.pop();\n  return out;\n}\n/**\n * executes any function\n * @param f function name\n * @param args list of parameters\n */\n\n\nexport function executeFunction(f, args) {\n  if (f in global_functions) {\n    let func = global_functions[f];\n    let params = [];\n\n    for (let arg of args) {\n      params.push(arg.eval());\n    }\n\n    return func.apply(null, params);\n  } else if (f in local_functions) {\n    executeLocalFunction(f);\n  } else {\n    throw new ParsingError(`function ${f} couldn't be found`);\n  }\n}\n/**\n * create a new function\n * @param func function node\n */\n\nexport function createUserDefinedFunction(func) {\n  if (func.name in global_functions) {\n    throw new ParsingError(\"conflicting function definition name: \" + func.name);\n  }\n\n  local_functions[func.name] = func;\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/app/src/interpreter/global.ts"],"names":["VariableScope","ParsingError","RuntimeError","rref","transpose","det","sqrt","identity","global_scope","global_functions","trans","determinant","q","local_functions","function_stack","findVariable","name","scope","val","undefined","global","procedure","currentBlock","peek","variables","assignVariable","value","executeLocalFunction","f","func","push","functionName","out","statement","exprs","eval","pop","executeFunction","args","params","arg","apply","createUserDefinedFunction"],"mappings":"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","sourcesContent":["import { AST, ProcedureDefinitionNode, VariableScope } from \"./ast\";\nimport { Computable } from \"./computable\";\nimport { ParsingError, RuntimeError } from \"./errors\";\nimport { rref, transpose, det, sqrt, identity } from \"./lib\";\nimport { Stack } from \"./util\";\n\ntype Function = (...args: any[]) => any;\n\ninterface Variables {\n  [key: string]: any;\n}\ninterface GlobalProcedures {\n  [key: string]: Function;\n}\ninterface LocalProcedures {\n  [key: string]: ProcedureDefinitionNode;\n}\ninterface FunctionBlock {\n  functionName: string;\n  variables: Variables;\n}\n\nlet global_scope: Variables = {};\nlet global_functions: GlobalProcedures = {\n  rref: rref,\n  trans: transpose,\n  transpose: transpose,\n  det: det,\n  determinant: det,\n  q: sqrt,\n  sqrt: sqrt,\n  identity: identity,\n};\nlet local_functions: LocalProcedures = {};\nlet function_stack: Stack<FunctionBlock>;\n\n/**\n * retrieve a variable from global or local scope\n * @param name variable name\n * @param scope variable scope\n */\nexport function findVariable(\n  name: string,\n  scope: VariableScope\n): any | undefined {\n  let val = undefined;\n  if (scope == VariableScope.global) {\n    val = global_scope[name];\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n    if (currentBlock) {\n      val = currentBlock.variables[name];\n    } else {\n      throw new RuntimeError(\n        \"function call stack was empty, something weird happened.\"\n      );\n    }\n  }\n  if (val) {\n    return val;\n  } else {\n    throw new RuntimeError(`variable ${name} wasn't declared!`);\n  }\n}\n\n/**\n * sets variable to local and global scope\n * @param name variable name\n * @param value variable value\n * @param scope variable scope\n */\nexport function assignVariable(name: string, value: any, scope: VariableScope) {\n  if (scope == VariableScope.global) {\n    global_scope[name] = value;\n    return value;\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n    if (currentBlock) {\n      currentBlock.variables[name] = value;\n      return value;\n    }\n  }\n  throw new RuntimeError(\n    \"function call stack was empty, something weird happened\"\n  );\n}\n\n/**\n * execute a local function\n * @param func function to execute\n */\nfunction executeLocalFunction(f: string) {\n  let func = local_functions[f];\n  function_stack.push({ functionName: func.name, variables: [] });\n  let out: any;\n  for (let statement of func.exprs) {\n    out = statement.eval();\n  }\n  function_stack.pop();\n  return out;\n}\n\n/**\n * executes any function\n * @param f function name\n * @param args list of parameters\n */\nexport function executeFunction(f: string, args: AST[]) {\n  if (f in global_functions) {\n    let func = global_functions[f];\n    let params: Computable[] = [];\n    for (let arg of args) {\n      params.push(arg.eval());\n    }\n    return func.apply(null, params);\n  } else if (f in local_functions) {\n    executeLocalFunction(f);\n  } else {\n    throw new ParsingError(`function ${f} couldn't be found`);\n  }\n}\n\n/**\n * create a new function\n * @param func function node\n */\nexport function createUserDefinedFunction(func: ProcedureDefinitionNode) {\n  if (func.name in global_functions) {\n    throw new ParsingError(\n      \"conflicting function definition name: \" + func.name\n    );\n  }\n  local_functions[func.name] = func;\n}\n"]},"metadata":{},"sourceType":"module"}