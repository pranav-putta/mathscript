{"ast":null,"code":"/**\n * supported token characters\n */\nvar TokenType;\n/**\n * holds a token of type with value\n * should not be used on its own, rather use aliases @type{SymbolToken, NumericToken, BooleanToken}\n */\n\n(function (TokenType) {\n  TokenType[TokenType[\"num\"] = 0] = \"num\";\n  TokenType[TokenType[\"reserved\"] = 1] = \"reserved\";\n  TokenType[TokenType[\"primitive\"] = 2] = \"primitive\";\n  TokenType[TokenType[\"id\"] = 3] = \"id\";\n  TokenType[TokenType[\"eof\"] = 4] = \"eof\";\n  TokenType[\"and_bool\"] = \"&&\";\n  TokenType[\"or_bool\"] = \"||\";\n  TokenType[\"rdiv\"] = \"//\";\n  TokenType[\"plus\"] = \"+\";\n  TokenType[\"minus\"] = \"-\";\n  TokenType[\"mul\"] = \"*\";\n  TokenType[\"pow\"] = \"^\";\n  TokenType[\"div\"] = \"/\";\n  TokenType[\"lparen\"] = \"(\";\n  TokenType[\"rparen\"] = \")\";\n  TokenType[\"lbracket\"] = \"[\";\n  TokenType[\"rbracket\"] = \"]\";\n  TokenType[\"larrow\"] = \"<\";\n  TokenType[\"rarrow\"] = \">\";\n  TokenType[\"semicolon\"] = \";\";\n  TokenType[\"comma\"] = \",\";\n  TokenType[\"assign\"] = \"=\";\n  TokenType[\"bar\"] = \"|\";\n  TokenType[\"dot\"] = \".\";\n  TokenType[\"endl\"] = \"\\n\";\n  TokenType[\"and\"] = \"&\";\n  TokenType[\"or\"] = \"|\";\n  TokenType[\"define\"] = \"=>\";\n})(TokenType || (TokenType = {}));\n\nfunction newToken(type, value) {\n  return {\n    type: type,\n    value: value || type.toString()\n  };\n}\n\nfunction isSymbolToken(token) {\n  return typeof token.value === \"string\";\n}\n\nfunction isNumericToken(token) {\n  return typeof token.value === \"number\" && token.type == TokenType.num;\n}\n\nexport { TokenType, isSymbolToken, isNumericToken, newToken };","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/app/src/interpreter/token.ts"],"names":["TokenType","newToken","type","value","toString","isSymbolToken","token","isNumericToken","num"],"mappings":"AAAA;;;IAGKA,S;AA+BL;;;;;WA/BKA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;AAAAA,EAAAA,S;GAAAA,S,KAAAA,S;;AA0DL,SAASC,QAAT,CAAkBC,IAAlB,EAAmCC,KAAnC,EAA6E;AAC3E,SAAO;AAAED,IAAAA,IAAI,EAAEA,IAAR;AAAcC,IAAAA,KAAK,EAAEA,KAAK,IAAID,IAAI,CAACE,QAAL;AAA9B,GAAP;AACD;;AAED,SAASC,aAAT,CAAuBC,KAAvB,EAA2D;AACzD,SAAO,OAAOA,KAAK,CAACH,KAAb,KAAuB,QAA9B;AACD;;AAED,SAASI,cAAT,CAAwBD,KAAxB,EAA6D;AAC3D,SAAO,OAAOA,KAAK,CAACH,KAAb,KAAuB,QAAvB,IAAmCG,KAAK,CAACJ,IAAN,IAAcF,SAAS,CAACQ,GAAlE;AACD;;AAED,SAASR,SAAT,EAAoBK,aAApB,EAAmCE,cAAnC,EAAmDN,QAAnD","sourcesContent":["/**\n * supported token characters\n */\nenum TokenType {\n  num,\n  reserved,\n  primitive,\n  id,\n  eof,\n  and_bool = \"&&\",\n  or_bool = \"||\",\n  rdiv = \"//\",\n  plus = \"+\",\n  minus = \"-\",\n  mul = \"*\",\n  pow = \"^\",\n  div = \"/\",\n  lparen = \"(\",\n  rparen = \")\",\n  lbracket = \"[\",\n  rbracket = \"]\",\n  larrow = \"<\",\n  rarrow = \">\",\n  semicolon = \";\",\n  comma = \",\",\n  assign = \"=\",\n  bar = \"|\",\n  dot = \".\",\n  endl = \"\\n\",\n  and = \"&\",\n  or = \"|\",\n  define = \"=>\",\n}\n\n/**\n * holds a token of type with value\n * should not be used on its own, rather use aliases @type{SymbolToken, NumericToken, BooleanToken}\n */\ninterface IToken<E> {\n  type: TokenType;\n  value: E;\n}\n\n/**\n * token holds a symbol like +, -, *, /, etc.\n */\nexport type SymbolToken = IToken<string>;\n/**\n * token holds a numeric value\n */\nexport type NumericToken = IToken<number>;\n/**\n * token holds a boolean value\n */\nexport type BooleanToken = IToken<boolean>;\n\n/**\n * supported tokens\n */\nexport type Token = SymbolToken | NumericToken | BooleanToken;\n\nfunction newToken(type: TokenType, value?: string | number | boolean): Token {\n  return { type: type, value: value || type.toString() };\n}\n\nfunction isSymbolToken(token: Token): token is SymbolToken {\n  return typeof token.value === \"string\";\n}\n\nfunction isNumericToken(token: Token): token is NumericToken {\n  return typeof token.value === \"number\" && token.type == TokenType.num;\n}\n\nexport { TokenType, isSymbolToken, isNumericToken, newToken };\n"]},"metadata":{},"sourceType":"module"}