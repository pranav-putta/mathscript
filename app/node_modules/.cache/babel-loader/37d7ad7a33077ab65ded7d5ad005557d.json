{"ast":null,"code":"import { ArithmeticError, MatrixError } from \"./errors\";\nimport { TokenType } from \"./token\";\nexport class Computable {\n  not_equals(other) {\n    return {\n      result: new Logical(!this.equals(other).result.boolVal)\n    };\n  }\n\n}\n/**\n * checks if given element is of type computable\n * @param el any element\n */\n\nexport function isComputable(el) {\n  return el instanceof Computable;\n}\nexport function computeResult(a, b, operator) {\n  switch (operator) {\n    case TokenType.plus:\n      return a.add(b);\n\n    case TokenType.minus:\n      return a.sub(b);\n\n    case TokenType.mul:\n      return a.mul(b);\n\n    case TokenType.div:\n      return a.div(b);\n\n    case TokenType.rdiv:\n      return a.rdiv(b);\n\n    case TokenType.pow:\n      return a.pow(b);\n\n    case TokenType.larrow:\n      return a.less(b);\n\n    case TokenType.rarrow:\n      return a.more(b);\n\n    case TokenType.eq:\n      return a.equals(b);\n\n    case TokenType.not_bool:\n      return a.not_equals(b);\n\n    case TokenType.more_eq:\n      return a.more(b).result.or(a.equals(b).result);\n\n    case TokenType.less_eq:\n      return a.less(b).result.or(a.equals(b).result);\n  }\n\n  if (operator == TokenType.and_bool || operator == TokenType.or_bool || operator == TokenType.not) {\n    if (isLogical(a) && isLogical(b)) {\n      switch (operator) {\n        case TokenType.and_bool:\n          return a.and(b);\n\n        case TokenType.or_bool:\n          return a.or(b);\n      }\n    } else {\n      throw new ArithmeticError(\"boolean operator exepcts bool expression\");\n    }\n  }\n\n  throw new ArithmeticError(\"unsupported operation \" + operator.toString());\n}\nexport class UnevaluatedMatrix {\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(nodes) {\n    this.matrix = void 0;\n    this.dimR = void 0;\n    this.dimC = void 0;\n    // raw node matrix\n    this.matrix = nodes;\n    this.dimR = nodes.length;\n    this.dimC = this.dimR > 0 ? nodes[0].length : 0; // verify each row is the same length\n\n    for (let row of nodes) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n  /**\n   * evaluates matrix from raw nodes\n   */\n\n\n  evaluate() {\n    let arr = new Array();\n\n    for (let row = 0; row < this.dimR; row++) {\n      arr.push([]);\n\n      for (let col = 0; col < this.dimC; col++) {\n        let val = this.matrix[row][col].eval();\n\n        if (isNumeric(val)) {\n          arr[row].push(val.value);\n        } else {\n          throw new SyntaxError(\"couldn't evaluate matrix! expected numbers.\");\n        }\n      }\n    }\n\n    return new Matrix(arr);\n  }\n\n  static isUnevaluatedMatrix(m) {\n    return m instanceof UnevaluatedMatrix;\n  }\n\n}\nexport class Matrix extends Computable {\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(rows) {\n    super();\n    this.matrix = void 0;\n    this.dimR = void 0;\n    this.dimC = void 0;\n    this.matrix = rows;\n    this.dimR = rows.length;\n    this.dimC = this.dimR > 0 ? rows[0].length : 0; // verify each row is the same length\n\n    for (let row of rows) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n\n  checkDimensions(other) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(`can't perform operations on matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n    }\n  }\n\n  expectedMatrixError() {\n    throw new ArithmeticError(\"expected a matrix for calculations.\");\n  }\n\n  expectedMatrixOrNumericError() {\n    throw new ArithmeticError(\"expected a matrix or numeric for calculations.\");\n  }\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n\n\n  add(other) {\n    let arr = new Array();\n\n    if (isMatrix(other)) {\n      // add two matricies together\n      this.checkDimensions(other);\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // add constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return {\n      result: new Matrix(arr)\n    };\n  }\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n\n\n  sub(other) {\n    let arr = new Array();\n\n    if (isMatrix(other)) {\n      // subtract two matricies together\n      this.checkDimensions(other);\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // subtract constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return {\n      result: new Matrix(arr)\n    };\n  }\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n\n\n  el_mul(other) {\n    if (this.dimC == other.dimC && this.dimR == other.dimR) {\n      let arr = new Array();\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.matrix[i][j]);\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    } else {\n      throw new MatrixError(\"cannot do element-wise multiplication on different sized matricies\");\n    }\n  }\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n\n\n  mul(other) {\n    if (isMatrix(other)) {\n      // multiply two matricies\n      // check dimensions are proper\n      if (this.dimC != other.dimR) {\n        if (this.dimC == other.dimC && this.dimR == other.dimR) {\n          return {\n            result: this.mul(other.transpose().result).result,\n            message: \"inferred to take dot product.\"\n          };\n        }\n\n        throw new MatrixError(`can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n      }\n\n      let newMatrix = new Array();\n\n      for (let i = 0; i < this.dimR; i++) {\n        newMatrix.push([]);\n\n        for (let j = 0; j < other.dimC; j++) {\n          let temp = 0;\n\n          for (let k = 0; k < this.dimC; k++) {\n            temp += this.matrix[i][k] * other.matrix[k][j];\n          }\n\n          newMatrix[i].push(temp);\n        }\n      }\n\n      if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n        return {\n          result: new Numeric(newMatrix[0][0])\n        };\n      } else {\n        return {\n          result: new Matrix(newMatrix)\n        };\n      }\n    } else if (isNumeric(other)) {\n      let arr = new Array(); // multiply constant to each element\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.value);\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    }\n\n    this.expectedMatrixOrNumericError();\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  div(other) {\n    if (isNumeric(other)) {\n      let arr = new Array(); // multiply constant to each element\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] / other.value);\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    }\n\n    this.expectedMatrixError();\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  rdiv(other) {\n    if (isNumeric(other)) {\n      let arr = new Array(); // multiply constant to each element\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(Math.floor(this.matrix[i][j] / other.value));\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    }\n\n    this.expectedMatrixError();\n  }\n  /**\n   * take power\n   * @param other\n   */\n\n\n  pow(other) {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"only square matricies can be raised to the power\");\n    }\n\n    if (isNumeric(other)) {\n      let newMatrix = this;\n\n      for (let i = 0; i < other.value; i++) {\n        let tmp = newMatrix.mul(this).result;\n\n        if (isMatrix(tmp)) {\n          newMatrix = tmp;\n        } else {\n          throw new MatrixError(\"multiplication failed: \" + tmp);\n        }\n      }\n\n      return {\n        result: newMatrix\n      };\n    } else {\n      throw new MatrixError(\"matrix power is not supported\");\n    }\n  }\n\n  transpose(save = false) {\n    let arr = new Array();\n\n    for (let i = 0; i < this.dimC; i++) {\n      arr.push([]);\n\n      for (let j = 0; j < this.dimR; j++) {\n        arr[i].push(this.matrix[j][i]);\n      }\n    }\n\n    if (save) {\n      this.matrix = arr;\n      let tmp = this.dimR;\n      this.dimR = this.dimC;\n      this.dimC = tmp;\n      return {\n        result: this\n      };\n    }\n\n    return {\n      result: new Matrix(arr)\n    };\n  }\n\n  determinant() {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"cannot take determinant of non-square matrix\");\n    }\n\n    let n = this.dimR;\n    let M = this.matrix;\n\n    if (n == 2) {\n      return M[0][0] * M[1][1] - M[0][1] * M[1][0];\n    } else {\n      let d = 0;\n\n      for (let i = 0; i < n; i++) {\n        // create a sub matrix\n        let subMatrix = [];\n\n        for (let r = 0; r < n; r++) {\n          subMatrix.push([]);\n\n          for (let c = 0; c < n; c++) {\n            if (c != i) {\n              subMatrix[r].push(this.matrix[r][c]);\n            }\n          }\n        }\n\n        d += M[0][i] * new Matrix(subMatrix).determinant();\n      }\n\n      return d;\n    }\n  }\n\n  subMatrix(startRow, endRow = this.dimR - 1, startCol, endCol = this.dimC - 1) {\n    let arr = new Array();\n\n    for (let i = startRow; i <= endRow; i++) {\n      arr.push([]);\n\n      for (let j = startCol; j <= endCol; j++) {\n        arr[i].push(this.matrix[i][j]);\n      }\n    }\n\n    return new Matrix(arr);\n  }\n\n  less(other) {\n    throw new Error(\"matrix not implemented for < operator.\");\n  }\n\n  more(other) {\n    throw new Error(\"matrix not implemented for > operator.\");\n  }\n\n  bitwiseAnd(other) {\n    if (isMatrix(other)) {\n      if (other.dimC != this.dimC || other.dimR != this.dimR) {\n        throw new MatrixError(\"can't operate on matricies of different dimensions\");\n      }\n\n      let newArr = [];\n\n      for (let i = 0; i < this.dimR; i++) {\n        for (let j = 0; j < this.dimC; j++) {\n          newArr[i][j] = this.matrix[i][j] & other.matrix[i][j];\n        }\n      }\n\n      return {\n        result: new Matrix(newArr)\n      };\n    } else if (isNumeric(other)) {\n      let newArr = [];\n\n      for (let i = 0; i < this.dimR; i++) {\n        for (let j = 0; j < this.dimC; j++) {\n          newArr[i][j] = this.matrix[i][j] & other.value;\n        }\n      }\n\n      return {\n        result: new Matrix(newArr)\n      };\n    }\n\n    this.expectedMatrixOrNumericError();\n  }\n\n  bitwiseOr(other) {\n    if (isMatrix(other)) {} else if (isNumeric(other)) {}\n\n    this.expectedMatrixOrNumericError();\n  }\n\n  equals(other) {\n    if (isMatrix(other)) {\n      if (this.dimR == other.dimR && this.dimC == other.dimC) {\n        for (let i = 0; i < this.dimR; i++) {\n          for (let j = 0; j < this.dimC; j++) {\n            if (this.matrix[i][j] != other.matrix[i][j]) {\n              return {\n                result: new Logical(false)\n              };\n            }\n          }\n        }\n\n        return {\n          result: new Logical(true)\n        };\n      } else {\n        throw new MatrixError(\"matrix dimensions must be the same!\");\n      }\n    }\n\n    this.expectedMatrixError();\n  }\n\n  toString() {\n    let m = this.matrix;\n    let str = \"\";\n\n    if (m.length == 1) {\n      str += \"< \";\n\n      for (let i = 0; i < this.dimC; i++) {\n        str += m[0][i];\n\n        if (i != m[0].length - 1) {\n          str += \" \";\n        }\n      }\n\n      str += \" >\";\n    } else {\n      str += \"[\";\n\n      for (let i = 0; i < this.dimR; i++) {\n        if (i != 0) {\n          str += \" \";\n        }\n\n        str += \"[ \";\n\n        for (let j = 0; j < this.dimC; j++) {\n          str += m[i][j] + \" \";\n        }\n\n        str += \"]\";\n\n        if (i != this.dimR - 1) {\n          str += \"\\n\";\n        }\n      }\n\n      str += \"]\";\n      str += `  { ${this.dimR} x ${this.dimC} }`;\n    }\n\n    return str;\n  }\n\n}\nexport function isMatrix(el) {\n  return el instanceof Matrix;\n}\nexport class Numeric extends Computable {\n  constructor(val) {\n    super();\n    this.value = void 0;\n    this.value = val;\n  }\n\n  error() {\n    throw new ArithmeticError(\"cannot add numeric with non-numeric\");\n  }\n\n  add(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value + other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.add(this);\n    }\n\n    this.error();\n  }\n\n  sub(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value - other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.mul(new Numeric(-1)).result.add(this);\n    }\n\n    this.error();\n  }\n\n  mul(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value * other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.mul(this);\n    }\n\n    this.error();\n  }\n\n  div(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value / other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.div(this);\n    }\n\n    this.error();\n  }\n\n  rdiv(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(Math.floor(this.value / other.value))\n      };\n    } else if (isMatrix(other)) {\n      return other.rdiv(this);\n    }\n\n    this.error();\n  }\n\n  pow(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(Math.pow(this.value, other.value))\n      };\n    }\n\n    this.error();\n  }\n\n  less(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Logical(this.value < other.value)\n      };\n    }\n\n    this.error();\n  }\n\n  more(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Logical(this.value > other.value)\n      };\n    }\n\n    this.error();\n  }\n\n  equals(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Logical(this.value == other.value)\n      };\n    }\n\n    this.error();\n  }\n\n  bitwiseAnd(other) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  bitwiseOr(other) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  toString() {\n    return this.value.toString();\n  }\n\n}\nexport function isNumeric(el) {\n  return el instanceof Numeric;\n}\n\n/**\n * boolean computable value\n */\nexport class Logical extends Numeric {\n  get boolVal() {\n    return this._boolVal;\n  }\n\n  constructor(value) {\n    super(value ? 1 : 0);\n    this._boolVal = void 0;\n    this._boolVal = value;\n  }\n\n  add(other) {\n    return other.add(new Numeric(this.value));\n  }\n\n  sub(other) {\n    return other.add(new Numeric(this.value * -1));\n  }\n\n  mul(other) {\n    return other.mul(new Numeric(this.value));\n  }\n\n  div(other) {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  rdiv(other) {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  pow(other) {\n    throw new ArithmeticError(\"boolean powers not supported\");\n  }\n\n  or(other) {\n    return {\n      result: new Logical(this.boolVal || other.boolVal)\n    };\n  }\n\n  and(other) {\n    return {\n      result: new Logical(this.boolVal && other.boolVal)\n    };\n  }\n\n  xor(other) {\n    return {\n      result: new Logical(this.boolVal !== other.boolVal)\n    };\n  }\n\n  nand(other) {\n    return {\n      result: new Logical(this.boolVal == other.boolVal && !this.boolVal)\n    };\n  }\n\n  not(other) {\n    return {\n      result: new Logical(this.boolVal != other.boolVal)\n    };\n  }\n\n  less(other) {\n    throw new Error(\"boolean not implemented for < operator.\");\n  }\n\n  more(other) {\n    throw new Error(\"boolean not implemented for > operator.\");\n  }\n\n  equals(other) {\n    if (isLogical(other)) {\n      return {\n        result: new Logical(this.value == other.value)\n      };\n    }\n\n    throw new ArithmeticError(\"cannot equate booleans and other types\");\n  }\n\n  toString() {\n    return new String(this.boolVal).toString();\n  }\n\n}\nexport function isLogical(el) {\n  return el instanceof Logical;\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/mathscript/app/src/interpreter/computable.ts"],"names":["ArithmeticError","MatrixError","TokenType","Computable","not_equals","other","result","Logical","equals","boolVal","isComputable","el","computeResult","a","b","operator","plus","add","minus","sub","mul","div","rdiv","pow","larrow","less","rarrow","more","eq","not_bool","more_eq","or","less_eq","and_bool","or_bool","not","isLogical","and","toString","UnevaluatedMatrix","constructor","nodes","matrix","dimR","dimC","length","row","evaluate","arr","Array","push","col","val","eval","isNumeric","value","SyntaxError","Matrix","isUnevaluatedMatrix","m","rows","checkDimensions","expectedMatrixError","expectedMatrixOrNumericError","isMatrix","i","j","el_mul","transpose","message","newMatrix","temp","k","Numeric","Math","floor","tmp","save","determinant","n","M","d","subMatrix","r","c","startRow","endRow","startCol","endCol","Error","bitwiseAnd","newArr","bitwiseOr","str","error","_boolVal","xor","nand","String"],"mappings":"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","sourcesContent":["import { ComputableNode } from \"./ast\";\nimport { ArithmeticError, MatrixError } from \"./errors\";\nimport { TokenType } from \"./token\";\n\nexport interface Result {\n  result: Computable;\n  message?: string;\n}\n\nexport abstract class Computable {\n  public abstract add(other: Computable): Result;\n  public abstract sub(other: Computable): Result;\n  public abstract mul(other: Computable): Result;\n  public abstract div(other: Computable): Result;\n  public abstract rdiv(other: Computable): Result;\n  public abstract pow(other: Computable): Result;\n  public abstract less(other: Computable): LogicalResult;\n  public abstract more(other: Computable): LogicalResult;\n  public abstract equals(other: Computable): LogicalResult;\n  public abstract bitwiseAnd(other: Computable): Result;\n  public abstract bitwiseOr(other: Computable): Result;\n  public not_equals(other: Computable): Result {\n    return { result: new Logical(!this.equals(other).result.boolVal) };\n  }\n}\n\n/**\n * checks if given element is of type computable\n * @param el any element\n */\nexport function isComputable(el: any): el is Computable {\n  return el instanceof Computable;\n}\n\nexport function computeResult(\n  a: Computable,\n  b: Computable,\n  operator: TokenType\n): Result {\n  switch (operator) {\n    case TokenType.plus:\n      return a.add(b);\n    case TokenType.minus:\n      return a.sub(b);\n    case TokenType.mul:\n      return a.mul(b);\n    case TokenType.div:\n      return a.div(b);\n    case TokenType.rdiv:\n      return a.rdiv(b);\n    case TokenType.pow:\n      return a.pow(b);\n    case TokenType.larrow:\n      return a.less(b);\n    case TokenType.rarrow:\n      return a.more(b);\n    case TokenType.eq:\n      return a.equals(b);\n    case TokenType.not_bool:\n      return a.not_equals(b);\n    case TokenType.more_eq:\n      return a.more(b).result.or(a.equals(b).result);\n    case TokenType.less_eq:\n      return a.less(b).result.or(a.equals(b).result);\n  }\n  if (\n    operator == TokenType.and_bool ||\n    operator == TokenType.or_bool ||\n    operator == TokenType.not\n  ) {\n    if (isLogical(a) && isLogical(b)) {\n      switch (operator) {\n        case TokenType.and_bool:\n          return a.and(b);\n        case TokenType.or_bool:\n          return a.or(b);\n      }\n    } else {\n      throw new ArithmeticError(\"boolean operator exepcts bool expression\");\n    }\n  }\n  throw new ArithmeticError(\"unsupported operation \" + operator.toString());\n}\n\nexport interface MatrixResult extends Result {\n  result: Matrix;\n}\n\nexport class UnevaluatedMatrix {\n  private matrix: ComputableNode[][];\n  private dimR: number;\n  private dimC: number;\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(nodes: ComputableNode[][]) {\n    // raw node matrix\n    this.matrix = nodes;\n    this.dimR = nodes.length;\n    this.dimC = this.dimR > 0 ? nodes[0].length : 0;\n\n    // verify each row is the same length\n    for (let row of nodes) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n\n  /**\n   * evaluates matrix from raw nodes\n   */\n  public evaluate(): Matrix {\n    let arr: number[][] = new Array();\n    for (let row = 0; row < this.dimR; row++) {\n      arr.push([]);\n      for (let col = 0; col < this.dimC; col++) {\n        let val = this.matrix[row][col].eval();\n        if (isNumeric(val)) {\n          arr[row].push(val.value);\n        } else {\n          throw new SyntaxError(\"couldn't evaluate matrix! expected numbers.\");\n        }\n      }\n    }\n    return new Matrix(arr);\n  }\n\n  public static isUnevaluatedMatrix(m: any): m is UnevaluatedMatrix {\n    return m instanceof UnevaluatedMatrix;\n  }\n}\n\nexport class Matrix extends Computable {\n  matrix: number[][];\n  dimR: number;\n  dimC: number;\n\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(rows: number[][]) {\n    super();\n\n    this.matrix = rows;\n    this.dimR = rows.length;\n    this.dimC = this.dimR > 0 ? rows[0].length : 0;\n\n    // verify each row is the same length\n    for (let row of rows) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n\n  private checkDimensions(other: Matrix) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(\n        `can't perform operations on matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n      );\n    }\n  }\n\n  private expectedMatrixError(): never {\n    throw new ArithmeticError(\"expected a matrix for calculations.\");\n  }\n\n  private expectedMatrixOrNumericError(): never {\n    throw new ArithmeticError(\"expected a matrix or numeric for calculations.\");\n  }\n\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n  public add(other: Computable): MatrixResult {\n    let arr: number[][] = new Array();\n    if (isMatrix(other)) {\n      // add two matricies together\n      this.checkDimensions(other);\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // add constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return { result: new Matrix(arr) };\n  }\n\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n  public sub(other: Computable): MatrixResult {\n    let arr: number[][] = new Array();\n\n    if (isMatrix(other)) {\n      // subtract two matricies together\n      this.checkDimensions(other);\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // subtract constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return { result: new Matrix(arr) };\n  }\n\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n  public el_mul(other: Matrix): MatrixResult {\n    if (this.dimC == other.dimC && this.dimR == other.dimR) {\n      let arr: number[][] = new Array();\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.matrix[i][j]);\n        }\n      }\n      return { result: new Matrix(arr) };\n    } else {\n      throw new MatrixError(\n        \"cannot do element-wise multiplication on different sized matricies\"\n      );\n    }\n  }\n\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n  public mul(other: Computable): Result {\n    if (isMatrix(other)) {\n      // multiply two matricies\n      // check dimensions are proper\n      if (this.dimC != other.dimR) {\n        if (this.dimC == other.dimC && this.dimR == other.dimR) {\n          return {\n            result: this.mul(other.transpose().result).result,\n            message: \"inferred to take dot product.\",\n          };\n        }\n        throw new MatrixError(\n          `can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n        );\n      }\n      let newMatrix: number[][] = new Array();\n      for (let i = 0; i < this.dimR; i++) {\n        newMatrix.push([]);\n        for (let j = 0; j < other.dimC; j++) {\n          let temp = 0;\n          for (let k = 0; k < this.dimC; k++) {\n            temp += this.matrix[i][k] * other.matrix[k][j];\n          }\n          newMatrix[i].push(temp);\n        }\n      }\n      if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n        return { result: new Numeric(newMatrix[0][0]) };\n      } else {\n        return { result: new Matrix(newMatrix) };\n      }\n    } else if (isNumeric(other)) {\n      let arr: number[][] = new Array();\n      // multiply constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.value);\n        }\n      }\n      return { result: new Matrix(arr) };\n    }\n    this.expectedMatrixOrNumericError();\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public div(other: Computable): MatrixResult {\n    if (isNumeric(other)) {\n      let arr: number[][] = new Array();\n      // multiply constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] / other.value);\n        }\n      }\n      return { result: new Matrix(arr) };\n    }\n    this.expectedMatrixError();\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public rdiv(other: Computable): MatrixResult {\n    if (isNumeric(other)) {\n      let arr: number[][] = new Array();\n      // multiply constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(Math.floor(this.matrix[i][j] / other.value));\n        }\n      }\n      return { result: new Matrix(arr) };\n    }\n    this.expectedMatrixError();\n  }\n\n  /**\n   * take power\n   * @param other\n   */\n  public pow(other: Computable): MatrixResult {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"only square matricies can be raised to the power\");\n    }\n    if (isNumeric(other)) {\n      let newMatrix: Matrix = this;\n      for (let i = 0; i < other.value; i++) {\n        let tmp = newMatrix.mul(this).result;\n        if (isMatrix(tmp)) {\n          newMatrix = tmp;\n        } else {\n          throw new MatrixError(\"multiplication failed: \" + tmp);\n        }\n      }\n      return { result: newMatrix };\n    } else {\n      throw new MatrixError(\"matrix power is not supported\");\n    }\n  }\n\n  public transpose(save: boolean = false): MatrixResult {\n    let arr: number[][] = new Array();\n    for (let i = 0; i < this.dimC; i++) {\n      arr.push([]);\n      for (let j = 0; j < this.dimR; j++) {\n        arr[i].push(this.matrix[j][i]);\n      }\n    }\n\n    if (save) {\n      this.matrix = arr;\n      let tmp = this.dimR;\n      this.dimR = this.dimC;\n      this.dimC = tmp;\n      return { result: this };\n    }\n    return { result: new Matrix(arr) };\n  }\n\n  public determinant(): number {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"cannot take determinant of non-square matrix\");\n    }\n\n    let n = this.dimR;\n    let M = this.matrix;\n    if (n == 2) {\n      return M[0][0] * M[1][1] - M[0][1] * M[1][0];\n    } else {\n      let d = 0;\n      for (let i = 0; i < n; i++) {\n        // create a sub matrix\n        let subMatrix: number[][] = [];\n        for (let r = 0; r < n; r++) {\n          subMatrix.push([]);\n          for (let c = 0; c < n; c++) {\n            if (c != i) {\n              subMatrix[r].push(this.matrix[r][c]);\n            }\n          }\n        }\n\n        d += M[0][i] * new Matrix(subMatrix).determinant();\n      }\n      return d;\n    }\n  }\n\n  public subMatrix(\n    startRow: number,\n    endRow: number = this.dimR - 1,\n    startCol: number,\n    endCol: number = this.dimC - 1\n  ): Matrix {\n    let arr: number[][] = new Array();\n    for (let i = startRow; i <= endRow; i++) {\n      arr.push([]);\n      for (let j = startCol; j <= endCol; j++) {\n        arr[i].push(this.matrix[i][j]);\n      }\n    }\n    return new Matrix(arr);\n  }\n\n  public less(other: Computable): LogicalResult {\n    throw new Error(\"matrix not implemented for < operator.\");\n  }\n  public more(other: Computable): LogicalResult {\n    throw new Error(\"matrix not implemented for > operator.\");\n  }\n\n  public bitwiseAnd(other: Computable): Result {\n    if (isMatrix(other)) {\n      if (other.dimC != this.dimC || other.dimR != this.dimR) {\n        throw new MatrixError(\n          \"can't operate on matricies of different dimensions\"\n        );\n      }\n      let newArr: number[][] = [];\n      for (let i = 0; i < this.dimR; i++) {\n        for (let j = 0; j < this.dimC; j++) {\n          newArr[i][j] = this.matrix[i][j] & other.matrix[i][j];\n        }\n      }\n      return { result: new Matrix(newArr) };\n    } else if (isNumeric(other)) {\n      let newArr: number[][] = [];\n      for (let i = 0; i < this.dimR; i++) {\n        for (let j = 0; j < this.dimC; j++) {\n          newArr[i][j] = this.matrix[i][j] & other.value;\n        }\n      }\n      return { result: new Matrix(newArr) };\n    }\n    this.expectedMatrixOrNumericError();\n  }\n  public bitwiseOr(other: Computable): Result {\n    if (isMatrix(other)) {\n    } else if (isNumeric(other)) {\n    }\n    this.expectedMatrixOrNumericError();\n  }\n\n  public equals(other: Computable): LogicalResult {\n    if (isMatrix(other)) {\n      if (this.dimR == other.dimR && this.dimC == other.dimC) {\n        for (let i = 0; i < this.dimR; i++) {\n          for (let j = 0; j < this.dimC; j++) {\n            if (this.matrix[i][j] != other.matrix[i][j]) {\n              return { result: new Logical(false) };\n            }\n          }\n        }\n        return { result: new Logical(true) };\n      } else {\n        throw new MatrixError(\"matrix dimensions must be the same!\");\n      }\n    }\n    this.expectedMatrixError();\n  }\n\n  public toString(): string {\n    let m = this.matrix;\n    let str = \"\";\n    if (m.length == 1) {\n      str += \"< \";\n      for (let i = 0; i < this.dimC; i++) {\n        str += m[0][i];\n        if (i != m[0].length - 1) {\n          str += \" \";\n        }\n      }\n      str += \" >\";\n    } else {\n      str += \"[\";\n      for (let i = 0; i < this.dimR; i++) {\n        if (i != 0) {\n          str += \" \";\n        }\n        str += \"[ \";\n        for (let j = 0; j < this.dimC; j++) {\n          str += m[i][j] + \" \";\n        }\n        str += \"]\";\n        if (i != this.dimR - 1) {\n          str += \"\\n\";\n        }\n      }\n      str += \"]\";\n      str += `  { ${this.dimR} x ${this.dimC} }`;\n    }\n\n    return str;\n  }\n}\n\nexport function isMatrix(el: any): el is Matrix {\n  return el instanceof Matrix;\n}\n\nexport class Numeric extends Computable {\n  value: number;\n\n  constructor(val: number) {\n    super();\n    this.value = val;\n  }\n\n  private error(): never {\n    throw new ArithmeticError(\"cannot add numeric with non-numeric\");\n  }\n\n  public add(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value + other.value) };\n    } else if (isMatrix(other)) {\n      return other.add(this);\n    }\n    this.error();\n  }\n\n  public sub(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value - other.value) };\n    } else if (isMatrix(other)) {\n      return other.mul(new Numeric(-1)).result.add(this);\n    }\n    this.error();\n  }\n\n  public mul(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value * other.value) };\n    } else if (isMatrix(other)) {\n      return other.mul(this);\n    }\n    this.error();\n  }\n\n  public div(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value / other.value) };\n    } else if (isMatrix(other)) {\n      return other.div(this);\n    }\n    this.error();\n  }\n\n  public rdiv(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(Math.floor(this.value / other.value)) };\n    } else if (isMatrix(other)) {\n      return other.rdiv(this);\n    }\n    this.error();\n  }\n\n  public pow(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(Math.pow(this.value, other.value)) };\n    }\n    this.error();\n  }\n\n  public less(other: Computable): LogicalResult {\n    if (isNumeric(other)) {\n      return { result: new Logical(this.value < other.value) };\n    }\n    this.error();\n  }\n  public more(other: Computable): LogicalResult {\n    if (isNumeric(other)) {\n      return { result: new Logical(this.value > other.value) };\n    }\n    this.error();\n  }\n  public equals(other: Computable): LogicalResult {\n    if (isNumeric(other)) {\n      return { result: new Logical(this.value == other.value) };\n    }\n    this.error();\n  }\n\n  public bitwiseAnd(other: Computable): Result {\n    throw new Error(\"Method not implemented.\");\n  }\n  public bitwiseOr(other: Computable): Result {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  public toString(): string {\n    return this.value.toString();\n  }\n}\n\nexport function isNumeric(el: any): el is Numeric {\n  return el instanceof Numeric;\n}\n\nexport interface LogicalResult extends Result {\n  result: Logical;\n}\n/**\n * boolean computable value\n */\nexport class Logical extends Numeric {\n  private _boolVal: boolean;\n\n  public get boolVal() {\n    return this._boolVal;\n  }\n\n  constructor(value: boolean) {\n    super(value ? 1 : 0);\n    this._boolVal = value;\n  }\n\n  public add(other: Computable): Result {\n    return other.add(new Numeric(this.value));\n  }\n  public sub(other: Computable): Result {\n    return other.add(new Numeric(this.value * -1));\n  }\n  public mul(other: Computable): Result {\n    return other.mul(new Numeric(this.value));\n  }\n  public div(other: Computable): Result {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  public rdiv(other: Computable): Result {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n  public pow(other: Computable): Result {\n    throw new ArithmeticError(\"boolean powers not supported\");\n  }\n\n  public or(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal || other.boolVal) };\n  }\n\n  public and(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal && other.boolVal) };\n  }\n\n  public xor(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal !== other.boolVal) };\n  }\n\n  public nand(other: Logical): LogicalResult {\n    return {\n      result: new Logical(this.boolVal == other.boolVal && !this.boolVal),\n    };\n  }\n\n  public not(other: Logical): LogicalResult {\n    return {\n      result: new Logical(this.boolVal != other.boolVal),\n    };\n  }\n\n  public less(other: Computable): LogicalResult {\n    throw new Error(\"boolean not implemented for < operator.\");\n  }\n  public more(other: Computable): LogicalResult {\n    throw new Error(\"boolean not implemented for > operator.\");\n  }\n\n  public equals(other: Computable): LogicalResult {\n    if (isLogical(other)) {\n      return { result: new Logical(this.value == other.value) };\n    }\n    throw new ArithmeticError(\"cannot equate booleans and other types\");\n  }\n\n  public toString(): string {\n    return new String(this.boolVal).toString();\n  }\n}\n\nexport function isLogical(el: any): el is Logical {\n  return el instanceof Logical;\n}\n"]},"metadata":{},"sourceType":"module"}