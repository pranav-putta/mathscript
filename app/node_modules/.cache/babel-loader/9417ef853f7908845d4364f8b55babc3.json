{"ast":null,"code":"import { VariableScope } from \"./ast\";\nimport { ParsingError, RuntimeError } from \"./errors\";\nimport { rref, transpose, det, sqrt, identity } from \"./lib\";\nimport { Stack } from \"./util\";\nlet global_scope = {};\nlet global_functions = {\n  rref: rref,\n  trans: transpose,\n  transpose: transpose,\n  det: det,\n  determinant: det,\n  q: sqrt,\n  sqrt: sqrt,\n  identity: identity\n};\nlet local_functions = {};\nlet function_stack = new Stack();\n/**\n * retrieve a variable from global or local scope\n * @param name variable name\n * @param scope variable scope\n */\n\nexport function findVariable(name, scope) {\n  let val = undefined;\n\n  if (scope == VariableScope.global) {\n    val = global_scope[name];\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n\n    if (currentBlock) {\n      val = currentBlock.variables[name];\n    } else {\n      throw new RuntimeError(\"function call stack was empty, something weird happened.\");\n    }\n  }\n\n  if (val) {\n    return val;\n  } else {\n    throw new RuntimeError(`variable ${name} wasn't declared!`);\n  }\n}\n/**\n * sets variable to local and global scope\n * @param name variable name\n * @param value variable value\n * @param scope variable scope\n */\n\nexport function assignVariable(name, value, scope) {\n  if (scope == VariableScope.global) {\n    global_scope[name] = value;\n    return value;\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n\n    if (currentBlock) {\n      currentBlock.variables[name] = value;\n      return value;\n    }\n  }\n\n  throw new RuntimeError(\"function call stack was empty, something weird happened\");\n}\n/**\n * generate a variables component\n * @param vars parameter nodes\n */\n\nfunction generateDefaultParameters(vars) {\n  let variables = {};\n\n  for (let v of vars) {\n    variables[v.name] = 0;\n  }\n\n  return variables;\n}\n/**\n * execute a local function\n * @param func function to execute\n */\n\n\nfunction executeLocalFunction(f) {\n  let func = local_functions[f];\n  let params = generateDefaultParameters(func.args);\n  function_stack.push({\n    functionName: func.name,\n    variables: params\n  });\n  let out;\n\n  for (let statement of func.exprs) {\n    out = statement.eval();\n  }\n\n  function_stack.pop();\n  return out;\n}\n/**\n * executes any function\n * @param f function name\n * @param args list of parameters\n */\n\n\nexport function executeFunction(f, args) {\n  if (f in global_functions) {\n    let func = global_functions[f];\n    let params = [];\n\n    for (let arg of args) {\n      params.push(arg.eval());\n    }\n\n    return func.apply(null, params);\n  } else if (f in local_functions) {\n    executeLocalFunction(f);\n  } else {\n    throw new ParsingError(`function ${f} couldn't be found`);\n  }\n}\n/**\n * create a new function\n * @param func function node\n */\n\nexport function createUserDefinedFunction(func) {\n  if (func.name in global_functions) {\n    throw new ParsingError(\"conflicting function definition name: \" + func.name);\n  }\n\n  local_functions[func.name] = func;\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/app/src/interpreter/global.ts"],"names":["VariableScope","ParsingError","RuntimeError","rref","transpose","det","sqrt","identity","Stack","global_scope","global_functions","trans","determinant","q","local_functions","function_stack","findVariable","name","scope","val","undefined","global","procedure","currentBlock","peek","variables","assignVariable","value","generateDefaultParameters","vars","v","executeLocalFunction","f","func","params","args","push","functionName","out","statement","exprs","eval","pop","executeFunction","arg","apply","createUserDefinedFunction"],"mappings":"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","sourcesContent":["import {\n  AST,\n  ProcedureDefinitionNode,\n  VariableNode,\n  VariableScope,\n} from \"./ast\";\nimport { Computable } from \"./computable\";\nimport { ParsingError, RuntimeError } from \"./errors\";\nimport { rref, transpose, det, sqrt, identity } from \"./lib\";\nimport { Stack } from \"./util\";\n\ntype Function = (...args: any[]) => any;\n\ninterface Variables {\n  [key: string]: any;\n}\ninterface GlobalProcedures {\n  [key: string]: Function;\n}\ninterface LocalProcedures {\n  [key: string]: ProcedureDefinitionNode;\n}\ninterface FunctionBlock {\n  functionName: string;\n  variables: Variables;\n}\n\nlet global_scope: Variables = {};\nlet global_functions: GlobalProcedures = {\n  rref: rref,\n  trans: transpose,\n  transpose: transpose,\n  det: det,\n  determinant: det,\n  q: sqrt,\n  sqrt: sqrt,\n  identity: identity,\n};\nlet local_functions: LocalProcedures = {};\nlet function_stack: Stack<FunctionBlock> = new Stack();\n\n/**\n * retrieve a variable from global or local scope\n * @param name variable name\n * @param scope variable scope\n */\nexport function findVariable(\n  name: string,\n  scope: VariableScope\n): any | undefined {\n  let val = undefined;\n  if (scope == VariableScope.global) {\n    val = global_scope[name];\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n    if (currentBlock) {\n      val = currentBlock.variables[name];\n    } else {\n      throw new RuntimeError(\n        \"function call stack was empty, something weird happened.\"\n      );\n    }\n  }\n  if (val) {\n    return val;\n  } else {\n    throw new RuntimeError(`variable ${name} wasn't declared!`);\n  }\n}\n\n/**\n * sets variable to local and global scope\n * @param name variable name\n * @param value variable value\n * @param scope variable scope\n */\nexport function assignVariable(name: string, value: any, scope: VariableScope) {\n  if (scope == VariableScope.global) {\n    global_scope[name] = value;\n    return value;\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n    if (currentBlock) {\n      currentBlock.variables[name] = value;\n      return value;\n    }\n  }\n  throw new RuntimeError(\n    \"function call stack was empty, something weird happened\"\n  );\n}\n\n/**\n * generate a variables component\n * @param vars parameter nodes\n */\nfunction generateDefaultParameters(vars: VariableNode[]): Variables {\n  let variables: Variables = {};\n  for (let v of vars) {\n    variables[v.name] = 0;\n  }\n  return variables;\n}\n\n/**\n * execute a local function\n * @param func function to execute\n */\nfunction executeLocalFunction(f: string) {\n  let func = local_functions[f];\n  let params = generateDefaultParameters(func.args);\n  function_stack.push({ functionName: func.name, variables: params });\n  let out: any;\n  for (let statement of func.exprs) {\n    out = statement.eval();\n  }\n  function_stack.pop();\n  return out;\n}\n\n/**\n * executes any function\n * @param f function name\n * @param args list of parameters\n */\nexport function executeFunction(f: string, args: AST[]) {\n  if (f in global_functions) {\n    let func = global_functions[f];\n    let params: Computable[] = [];\n    for (let arg of args) {\n      params.push(arg.eval());\n    }\n    return func.apply(null, params);\n  } else if (f in local_functions) {\n    executeLocalFunction(f);\n  } else {\n    throw new ParsingError(`function ${f} couldn't be found`);\n  }\n}\n\n/**\n * create a new function\n * @param func function node\n */\nexport function createUserDefinedFunction(func: ProcedureDefinitionNode) {\n  if (func.name in global_functions) {\n    throw new ParsingError(\n      \"conflicting function definition name: \" + func.name\n    );\n  }\n  local_functions[func.name] = func;\n}\n"]},"metadata":{},"sourceType":"module"}