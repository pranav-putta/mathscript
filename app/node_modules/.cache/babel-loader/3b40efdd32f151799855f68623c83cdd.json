{"ast":null,"code":"import { ArithmeticError, MatrixError } from \"./errors\";\nimport { TokenType } from \"./token\";\nexport class Computable {}\n/**\n * checks if given element is of type computable\n * @param el any element\n */\n\nexport function isComputable(el) {\n  return el instanceof Computable;\n}\nexport function computeResult(a, b, operator) {\n  switch (operator) {\n    case TokenType.plus:\n      return a.add(b);\n\n    case TokenType.minus:\n      return a.sub(b);\n\n    case TokenType.mul:\n      return a.mul(b);\n\n    case TokenType.div:\n      return a.div(b);\n\n    case TokenType.rdiv:\n      return a.rdiv(b);\n\n    case TokenType.pow:\n      return a.pow(b);\n\n    case TokenType.larrow:\n      return a.less(b);\n\n    case TokenType.rarrow:\n      return a.more(b);\n\n    case TokenType.eq:\n      return a.equals(b);\n\n    case TokenType.more_eq:\n      return a.more(b).result.or(a.equals(b).result);\n\n    case TokenType.less_eq:\n      return a.less(b).result.or(a.equals(b).result);\n  }\n\n  if (operator == TokenType.and_bool || operator == TokenType.or_bool || operator == TokenType.not || operator == TokenType.not_bool) {\n    if (isLogical(a) && isLogical(b)) {\n      switch (operator) {\n        case TokenType.and_bool:\n          return a.and(b);\n\n        case TokenType.or_bool:\n          return a.or(b);\n\n        case TokenType.not_bool:\n          return a.not(b);\n      }\n    } else {\n      throw new ArithmeticError(\"boolean operator exepcts bool expression\");\n    }\n  }\n\n  throw new ArithmeticError(\"unsupported operation \" + operator.toString());\n}\nexport class UnevaluatedMatrix {\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(nodes) {\n    this.matrix = void 0;\n    this.dimR = void 0;\n    this.dimC = void 0;\n    // raw node matrix\n    this.matrix = nodes;\n    this.dimR = nodes.length;\n    this.dimC = this.dimR > 0 ? nodes[0].length : 0; // verify each row is the same length\n\n    for (let row of nodes) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n  /**\n   * evaluates matrix from raw nodes\n   */\n\n\n  evaluate() {\n    let arr = new Array();\n\n    for (let row = 0; row < this.dimR; row++) {\n      arr.push([]);\n\n      for (let col = 0; col < this.dimC; col++) {\n        let val = this.matrix[row][col].eval();\n\n        if (isNumeric(val)) {\n          arr[row].push(val.value);\n        } else {\n          throw new SyntaxError(\"couldn't evaluate matrix! expected numbers.\");\n        }\n      }\n    }\n\n    return new Matrix(arr);\n  }\n\n  static isUnevaluatedMatrix(m) {\n    return m instanceof UnevaluatedMatrix;\n  }\n\n}\nexport class Matrix extends Computable {\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(rows) {\n    super();\n    this.matrix = void 0;\n    this.dimR = void 0;\n    this.dimC = void 0;\n    this.matrix = rows;\n    this.dimR = rows.length;\n    this.dimC = this.dimR > 0 ? rows[0].length : 0; // verify each row is the same length\n\n    for (let row of rows) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n\n  checkDimensions(other) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(`can't perform operations on matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n    }\n  }\n\n  expectedMatrixError() {\n    throw new ArithmeticError(\"expected a matrix for calculations.\");\n  }\n\n  expectedMatrixOrNumericError() {\n    throw new ArithmeticError(\"expected a matrix or numeric for calculations.\");\n  }\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n\n\n  add(other) {\n    let arr = new Array();\n\n    if (isMatrix(other)) {\n      // add two matricies together\n      this.checkDimensions(other);\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // add constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return {\n      result: new Matrix(arr)\n    };\n  }\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n\n\n  sub(other) {\n    let arr = new Array();\n\n    if (isMatrix(other)) {\n      // subtract two matricies together\n      this.checkDimensions(other);\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // subtract constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return {\n      result: new Matrix(arr)\n    };\n  }\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n\n\n  el_mul(other) {\n    if (this.dimC == other.dimC && this.dimR == other.dimR) {\n      let arr = new Array();\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.matrix[i][j]);\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    } else {\n      throw new MatrixError(\"cannot do element-wise multiplication on different sized matricies\");\n    }\n  }\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n\n\n  mul(other) {\n    if (isMatrix(other)) {\n      // multiply two matricies\n      // check dimensions are proper\n      if (this.dimC != other.dimR) {\n        if (this.dimC == other.dimC && this.dimR == other.dimR) {\n          return {\n            result: this.mul(other.transpose().result).result,\n            message: \"inferred to take dot product.\"\n          };\n        }\n\n        throw new MatrixError(`can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n      }\n\n      let newMatrix = new Array();\n\n      for (let i = 0; i < this.dimR; i++) {\n        newMatrix.push([]);\n\n        for (let j = 0; j < other.dimC; j++) {\n          let temp = 0;\n\n          for (let k = 0; k < this.dimC; k++) {\n            temp += this.matrix[i][k] * other.matrix[k][j];\n          }\n\n          newMatrix[i].push(temp);\n        }\n\n        if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n          return {\n            result: new Numeric(newMatrix[0][0])\n          };\n        } else {\n          return {\n            result: new Matrix(newMatrix)\n          };\n        }\n      }\n    } else if (isNumeric(other)) {\n      let arr = new Array(); // multiply constant to each element\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.value);\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    }\n\n    this.expectedMatrixOrNumericError();\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  div(other) {\n    if (isNumeric(other)) {\n      let arr = new Array(); // multiply constant to each element\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] / other.value);\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    }\n\n    this.expectedMatrixError();\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  rdiv(other) {\n    if (isNumeric(other)) {\n      let arr = new Array(); // multiply constant to each element\n\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(Math.floor(this.matrix[i][j] / other.value));\n        }\n      }\n\n      return {\n        result: new Matrix(arr)\n      };\n    }\n\n    this.expectedMatrixError();\n  }\n  /**\n   * take power\n   * @param other\n   */\n\n\n  pow(other) {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"only square matricies can be raised to the power\");\n    }\n\n    if (isNumeric(other)) {\n      let newMatrix = this;\n\n      for (let i = 0; i < other.value; i++) {\n        let tmp = newMatrix.mul(this).result;\n\n        if (isMatrix(tmp)) {\n          newMatrix = tmp;\n        } else {\n          throw new MatrixError(\"multiplication failed: \" + tmp);\n        }\n      }\n\n      return {\n        result: newMatrix\n      };\n    } else {\n      throw new MatrixError(\"matrix power is not supported\");\n    }\n  }\n\n  transpose(save = false) {\n    let arr = new Array();\n\n    for (let i = 0; i < this.dimC; i++) {\n      arr.push([]);\n\n      for (let j = 0; j < this.dimR; j++) {\n        arr[i].push(this.matrix[j][i]);\n      }\n    }\n\n    if (save) {\n      this.matrix = arr;\n      let tmp = this.dimR;\n      this.dimR = this.dimC;\n      this.dimC = tmp;\n      return {\n        result: this\n      };\n    }\n\n    return {\n      result: new Matrix(arr)\n    };\n  }\n\n  determinant() {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"cannot take determinant of non-square matrix\");\n    }\n\n    let n = this.dimR;\n    let M = this.matrix;\n\n    if (n == 2) {\n      return M[0][0] * M[1][1] - M[0][1] * M[1][0];\n    } else {\n      let d = 0;\n\n      for (let i = 0; i < n; i++) {\n        // create a sub matrix\n        let subMatrix = [];\n\n        for (let r = 0; r < n; r++) {\n          subMatrix.push([]);\n\n          for (let c = 0; c < n; c++) {\n            if (c != i) {\n              subMatrix[r].push(this.matrix[r][c]);\n            }\n          }\n        }\n\n        d += M[0][i] * new Matrix(subMatrix).determinant();\n      }\n\n      return d;\n    }\n  }\n\n  subMatrix(startRow, endRow = this.dimR - 1, startCol, endCol = this.dimC - 1) {\n    let arr = new Array();\n\n    for (let i = startRow; i <= endRow; i++) {\n      arr.push([]);\n\n      for (let j = startCol; j <= endCol; j++) {\n        arr[i].push(this.matrix[i][j]);\n      }\n    }\n\n    return new Matrix(arr);\n  }\n\n  less(other) {\n    throw new Error(\"matrix not implemented for < operator.\");\n  }\n\n  more(other) {\n    throw new Error(\"matrix not implemented for > operator.\");\n  }\n\n  bitwiseAnd(other) {\n    if (isMatrix(other)) {\n      if (other.dimC != this.dimC || other.dimR != this.dimR) {\n        throw new MatrixError(\"can't operate on matricies of different dimensions\");\n      }\n\n      let newArr = [];\n\n      for (let i = 0; i < this.dimR; i++) {\n        for (let j = 0; j < this.dimC; j++) {\n          newArr[i][j] = this.matrix[i][j] & other.matrix[i][j];\n        }\n      }\n\n      return {\n        result: new Matrix(newArr)\n      };\n    } else if (isNumeric(other)) {\n      let newArr = [];\n\n      for (let i = 0; i < this.dimR; i++) {\n        for (let j = 0; j < this.dimC; j++) {\n          newArr[i][j] = this.matrix[i][j] & other.value;\n        }\n      }\n\n      return {\n        result: new Matrix(newArr)\n      };\n    }\n\n    this.expectedMatrixOrNumericError();\n  }\n\n  bitwiseOr(other) {\n    if (isMatrix(other)) {} else if (isNumeric(other)) {}\n\n    this.expectedMatrixOrNumericError();\n  }\n\n  equals(other) {\n    if (isMatrix(other)) {\n      if (this.dimR == other.dimR && this.dimC == other.dimC) {\n        for (let i = 0; i < this.dimR; i++) {\n          for (let j = 0; j < this.dimC; j++) {\n            if (this.matrix[i][j] != other.matrix[i][j]) {\n              return {\n                result: new Logical(false)\n              };\n            }\n          }\n        }\n\n        return {\n          result: new Logical(true)\n        };\n      } else {\n        throw new MatrixError(\"matrix dimensions must be the same!\");\n      }\n    }\n\n    this.expectedMatrixError();\n  }\n\n  toString() {\n    let m = this.matrix;\n    let str = \"\";\n\n    if (m.length == 1) {\n      str += \"< \";\n\n      for (let i = 0; i < this.dimC; i++) {\n        str += m[0][i];\n\n        if (i != m[0].length - 1) {\n          str += \" \";\n        }\n      }\n\n      str += \" >\";\n    } else {\n      str += \"[\";\n\n      for (let i = 0; i < this.dimR; i++) {\n        if (i != 0) {\n          str += \" \";\n        }\n\n        str += \"[ \";\n\n        for (let j = 0; j < this.dimC; j++) {\n          str += m[i][j] + \" \";\n        }\n\n        str += \"]\";\n\n        if (i != this.dimR - 1) {\n          str += \"\\n\";\n        }\n      }\n\n      str += \"]\";\n      str += `  { ${this.dimR} x ${this.dimC} }`;\n    }\n\n    return str;\n  }\n\n}\nexport function isMatrix(el) {\n  return el instanceof Matrix;\n}\nexport class Numeric extends Computable {\n  constructor(val) {\n    super();\n    this.value = void 0;\n    this.value = val;\n  }\n\n  error() {\n    throw new ArithmeticError(\"cannot add numeric with non-numeric\");\n  }\n\n  add(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value + other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.add(this);\n    }\n\n    this.error();\n  }\n\n  sub(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value - other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.mul(new Numeric(-1)).result.add(this);\n    }\n\n    this.error();\n  }\n\n  mul(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value * other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.mul(this);\n    }\n\n    this.error();\n  }\n\n  div(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(this.value / other.value)\n      };\n    } else if (isMatrix(other)) {\n      return other.div(this);\n    }\n\n    this.error();\n  }\n\n  rdiv(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(Math.floor(this.value / other.value))\n      };\n    } else if (isMatrix(other)) {\n      return other.rdiv(this);\n    }\n\n    this.error();\n  }\n\n  pow(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Numeric(Math.pow(this.value, other.value))\n      };\n    }\n\n    this.error();\n  }\n\n  less(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Logical(this.value < other.value)\n      };\n    }\n\n    this.error();\n  }\n\n  more(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Logical(this.value > other.value)\n      };\n    }\n\n    this.error();\n  }\n\n  equals(other) {\n    if (isNumeric(other)) {\n      return {\n        result: new Logical(this.value == other.value)\n      };\n    }\n\n    this.error();\n  }\n\n  bitwiseAnd(other) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  bitwiseOr(other) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  toString() {\n    return this.value.toString();\n  }\n\n}\nexport function isNumeric(el) {\n  return el instanceof Numeric;\n}\n\n/**\n * boolean computable value\n */\nexport class Logical extends Numeric {\n  get boolVal() {\n    return this._boolVal;\n  }\n\n  constructor(value) {\n    super(value ? 1 : 0);\n    this._boolVal = void 0;\n    this._boolVal = value;\n  }\n\n  add(other) {\n    return other.add(new Numeric(this.value));\n  }\n\n  sub(other) {\n    return other.add(new Numeric(this.value * -1));\n  }\n\n  mul(other) {\n    return other.mul(new Numeric(this.value));\n  }\n\n  div(other) {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  rdiv(other) {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  pow(other) {\n    throw new ArithmeticError(\"boolean powers not supported\");\n  }\n\n  or(other) {\n    return {\n      result: new Logical(this.boolVal || other.boolVal)\n    };\n  }\n\n  and(other) {\n    return {\n      result: new Logical(this.boolVal && other.boolVal)\n    };\n  }\n\n  xor(other) {\n    return {\n      result: new Logical(this.boolVal !== other.boolVal)\n    };\n  }\n\n  nand(other) {\n    return {\n      result: new Logical(this.boolVal == other.boolVal && !this.boolVal)\n    };\n  }\n\n  not(other) {\n    return {\n      result: new Logical(this.boolVal != other.boolVal)\n    };\n  }\n\n  less(other) {\n    throw new Error(\"boolean not implemented for < operator.\");\n  }\n\n  more(other) {\n    throw new Error(\"boolean not implemented for > operator.\");\n  }\n\n  equals(other) {\n    if (isLogical(other)) {\n      return {\n        result: new Logical(this.value == other.value)\n      };\n    }\n\n    throw new ArithmeticError(\"cannot equate booleans and other types\");\n  }\n\n  toString() {\n    return new String(this.boolVal).toString();\n  }\n\n}\nexport function isLogical(el) {\n  return el instanceof Logical;\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/app/src/interpreter/computable.ts"],"names":["ArithmeticError","MatrixError","TokenType","Computable","isComputable","el","computeResult","a","b","operator","plus","add","minus","sub","mul","div","rdiv","pow","larrow","less","rarrow","more","eq","equals","more_eq","result","or","less_eq","and_bool","or_bool","not","not_bool","isLogical","and","toString","UnevaluatedMatrix","constructor","nodes","matrix","dimR","dimC","length","row","evaluate","arr","Array","push","col","val","eval","isNumeric","value","SyntaxError","Matrix","isUnevaluatedMatrix","m","rows","checkDimensions","other","expectedMatrixError","expectedMatrixOrNumericError","isMatrix","i","j","el_mul","transpose","message","newMatrix","temp","k","Numeric","Math","floor","tmp","save","determinant","n","M","d","subMatrix","r","c","startRow","endRow","startCol","endCol","Error","bitwiseAnd","newArr","bitwiseOr","Logical","str","error","boolVal","_boolVal","xor","nand","String"],"mappings":"AACA,SAASA,eAAT,EAA0BC,WAA1B,QAA6C,UAA7C;AACA,SAASC,SAAT,QAA0B,SAA1B;AAOA,OAAO,MAAeC,UAAf,CAA0B;AAcjC;;;;;AAIA,OAAO,SAASC,YAAT,CAAsBC,EAAtB,EAAiD;AACtD,SAAOA,EAAE,YAAYF,UAArB;AACD;AAED,OAAO,SAASG,aAAT,CACLC,CADK,EAELC,CAFK,EAGLC,QAHK,EAIG;AACR,UAAQA,QAAR;AACE,SAAKP,SAAS,CAACQ,IAAf;AACE,aAAOH,CAAC,CAACI,GAAF,CAAMH,CAAN,CAAP;;AACF,SAAKN,SAAS,CAACU,KAAf;AACE,aAAOL,CAAC,CAACM,GAAF,CAAML,CAAN,CAAP;;AACF,SAAKN,SAAS,CAACY,GAAf;AACE,aAAOP,CAAC,CAACO,GAAF,CAAMN,CAAN,CAAP;;AACF,SAAKN,SAAS,CAACa,GAAf;AACE,aAAOR,CAAC,CAACQ,GAAF,CAAMP,CAAN,CAAP;;AACF,SAAKN,SAAS,CAACc,IAAf;AACE,aAAOT,CAAC,CAACS,IAAF,CAAOR,CAAP,CAAP;;AACF,SAAKN,SAAS,CAACe,GAAf;AACE,aAAOV,CAAC,CAACU,GAAF,CAAMT,CAAN,CAAP;;AACF,SAAKN,SAAS,CAACgB,MAAf;AACE,aAAOX,CAAC,CAACY,IAAF,CAAOX,CAAP,CAAP;;AACF,SAAKN,SAAS,CAACkB,MAAf;AACE,aAAOb,CAAC,CAACc,IAAF,CAAOb,CAAP,CAAP;;AACF,SAAKN,SAAS,CAACoB,EAAf;AACE,aAAOf,CAAC,CAACgB,MAAF,CAASf,CAAT,CAAP;;AACF,SAAKN,SAAS,CAACsB,OAAf;AACE,aAAOjB,CAAC,CAACc,IAAF,CAAOb,CAAP,EAAUiB,MAAV,CAAiBC,EAAjB,CAAoBnB,CAAC,CAACgB,MAAF,CAASf,CAAT,EAAYiB,MAAhC,CAAP;;AACF,SAAKvB,SAAS,CAACyB,OAAf;AACE,aAAOpB,CAAC,CAACY,IAAF,CAAOX,CAAP,EAAUiB,MAAV,CAAiBC,EAAjB,CAAoBnB,CAAC,CAACgB,MAAF,CAASf,CAAT,EAAYiB,MAAhC,CAAP;AAtBJ;;AAwBA,MACEhB,QAAQ,IAAIP,SAAS,CAAC0B,QAAtB,IACAnB,QAAQ,IAAIP,SAAS,CAAC2B,OADtB,IAEApB,QAAQ,IAAIP,SAAS,CAAC4B,GAFtB,IAGArB,QAAQ,IAAIP,SAAS,CAAC6B,QAJxB,EAKE;AACA,QAAIC,SAAS,CAACzB,CAAD,CAAT,IAAgByB,SAAS,CAACxB,CAAD,CAA7B,EAAkC;AAChC,cAAQC,QAAR;AACE,aAAKP,SAAS,CAAC0B,QAAf;AACE,iBAAOrB,CAAC,CAAC0B,GAAF,CAAMzB,CAAN,CAAP;;AACF,aAAKN,SAAS,CAAC2B,OAAf;AACE,iBAAOtB,CAAC,CAACmB,EAAF,CAAKlB,CAAL,CAAP;;AACF,aAAKN,SAAS,CAAC6B,QAAf;AACE,iBAAOxB,CAAC,CAACuB,GAAF,CAAMtB,CAAN,CAAP;AANJ;AAQD,KATD,MASO;AACL,YAAM,IAAIR,eAAJ,CAAoB,0CAApB,CAAN;AACD;AACF;;AACD,QAAM,IAAIA,eAAJ,CAAoB,2BAA2BS,QAAQ,CAACyB,QAAT,EAA/C,CAAN;AACD;AAMD,OAAO,MAAMC,iBAAN,CAAwB;AAI7B;;;;;AAKAC,EAAAA,WAAW,CAACC,KAAD,EAA4B;AAAA,SAR/BC,MAQ+B;AAAA,SAP/BC,IAO+B;AAAA,SAN/BC,IAM+B;AACrC;AACA,SAAKF,MAAL,GAAcD,KAAd;AACA,SAAKE,IAAL,GAAYF,KAAK,CAACI,MAAlB;AACA,SAAKD,IAAL,GAAY,KAAKD,IAAL,GAAY,CAAZ,GAAgBF,KAAK,CAAC,CAAD,CAAL,CAASI,MAAzB,GAAkC,CAA9C,CAJqC,CAMrC;;AACA,SAAK,IAAIC,GAAT,IAAgBL,KAAhB,EAAuB;AACrB,UAAIK,GAAG,CAACD,MAAJ,IAAc,KAAKD,IAAvB,EAA6B;AAC3B,cAAM,IAAIvC,WAAJ,CAAgB,8BAAhB,CAAN;AACD;AACF;AACF;AAED;;;;;AAGO0C,EAAAA,QAAP,GAA0B;AACxB,QAAIC,GAAe,GAAG,IAAIC,KAAJ,EAAtB;;AACA,SAAK,IAAIH,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,KAAKH,IAA7B,EAAmCG,GAAG,EAAtC,EAA0C;AACxCE,MAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,WAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,KAAKP,IAA7B,EAAmCO,GAAG,EAAtC,EAA0C;AACxC,YAAIC,GAAG,GAAG,KAAKV,MAAL,CAAYI,GAAZ,EAAiBK,GAAjB,EAAsBE,IAAtB,EAAV;;AACA,YAAIC,SAAS,CAACF,GAAD,CAAb,EAAoB;AAClBJ,UAAAA,GAAG,CAACF,GAAD,CAAH,CAASI,IAAT,CAAcE,GAAG,CAACG,KAAlB;AACD,SAFD,MAEO;AACL,gBAAM,IAAIC,WAAJ,CAAgB,6CAAhB,CAAN;AACD;AACF;AACF;;AACD,WAAO,IAAIC,MAAJ,CAAWT,GAAX,CAAP;AACD;;AAED,SAAcU,mBAAd,CAAkCC,CAAlC,EAAkE;AAChE,WAAOA,CAAC,YAAYpB,iBAApB;AACD;;AA5C4B;AA+C/B,OAAO,MAAMkB,MAAN,SAAqBlD,UAArB,CAAgC;AAKrC;;;;;AAKAiC,EAAAA,WAAW,CAACoB,IAAD,EAAmB;AAC5B;AAD4B,SAT9BlB,MAS8B;AAAA,SAR9BC,IAQ8B;AAAA,SAP9BC,IAO8B;AAG5B,SAAKF,MAAL,GAAckB,IAAd;AACA,SAAKjB,IAAL,GAAYiB,IAAI,CAACf,MAAjB;AACA,SAAKD,IAAL,GAAY,KAAKD,IAAL,GAAY,CAAZ,GAAgBiB,IAAI,CAAC,CAAD,CAAJ,CAAQf,MAAxB,GAAiC,CAA7C,CAL4B,CAO5B;;AACA,SAAK,IAAIC,GAAT,IAAgBc,IAAhB,EAAsB;AACpB,UAAId,GAAG,CAACD,MAAJ,IAAc,KAAKD,IAAvB,EAA6B;AAC3B,cAAM,IAAIvC,WAAJ,CAAgB,8BAAhB,CAAN;AACD;AACF;AACF;;AAEOwD,EAAAA,eAAR,CAAwBC,KAAxB,EAAuC;AACrC,QAAI,KAAKnB,IAAL,IAAamB,KAAK,CAACnB,IAAnB,IAA2B,KAAKC,IAAL,IAAakB,KAAK,CAAClB,IAAlD,EAAwD;AACtD,YAAM,IAAIvC,WAAJ,CACH,mEAAkE,KAAKsC,IAAK,MAAK,KAAKC,IAAK,UAASkB,KAAK,CAACnB,IAAK,MAAKmB,KAAK,CAAClB,IAAK,GAD5H,CAAN;AAGD;AACF;;AAEOmB,EAAAA,mBAAR,GAAqC;AACnC,UAAM,IAAI3D,eAAJ,CAAoB,qCAApB,CAAN;AACD;;AAEO4D,EAAAA,4BAAR,GAA8C;AAC5C,UAAM,IAAI5D,eAAJ,CAAoB,gDAApB,CAAN;AACD;AAED;;;;;;AAIOW,EAAAA,GAAP,CAAW+C,KAAX,EAA4C;AAC1C,QAAId,GAAe,GAAG,IAAIC,KAAJ,EAAtB;;AACA,QAAIgB,QAAQ,CAACH,KAAD,CAAZ,EAAqB;AACnB;AACA,WAAKD,eAAL,CAAqBC,KAArB;;AACA,WAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClClB,QAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,aAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCnB,UAAAA,GAAG,CAACkB,CAAD,CAAH,CAAOhB,IAAP,CAAY,KAAKR,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,IAAoBL,KAAK,CAACpB,MAAN,CAAawB,CAAb,EAAgBC,CAAhB,CAAhC;AACD;AACF;AACF,KATD,MASO,IAAIb,SAAS,CAACQ,KAAD,CAAb,EAAsB;AAC3B;AACA,WAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClClB,QAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,aAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCnB,UAAAA,GAAG,CAACkB,CAAD,CAAH,CAAOhB,IAAP,CAAY,KAAKR,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,IAAoBL,KAAK,CAACP,KAAtC;AACD;AACF;AACF,KARM,MAQA;AACL,WAAKS,4BAAL;AACD;;AAED,WAAO;AAAEnC,MAAAA,MAAM,EAAE,IAAI4B,MAAJ,CAAWT,GAAX;AAAV,KAAP;AACD;AAED;;;;;;AAIO/B,EAAAA,GAAP,CAAW6C,KAAX,EAA4C;AAC1C,QAAId,GAAe,GAAG,IAAIC,KAAJ,EAAtB;;AAEA,QAAIgB,QAAQ,CAACH,KAAD,CAAZ,EAAqB;AACnB;AACA,WAAKD,eAAL,CAAqBC,KAArB;;AACA,WAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClClB,QAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,aAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCnB,UAAAA,GAAG,CAACkB,CAAD,CAAH,CAAOhB,IAAP,CAAY,KAAKR,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,IAAoBL,KAAK,CAACpB,MAAN,CAAawB,CAAb,EAAgBC,CAAhB,CAAhC;AACD;AACF;AACF,KATD,MASO,IAAIb,SAAS,CAACQ,KAAD,CAAb,EAAsB;AAC3B;AACA,WAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClClB,QAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,aAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCnB,UAAAA,GAAG,CAACkB,CAAD,CAAH,CAAOhB,IAAP,CAAY,KAAKR,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,IAAoBL,KAAK,CAACP,KAAtC;AACD;AACF;AACF,KARM,MAQA;AACL,WAAKS,4BAAL;AACD;;AAED,WAAO;AAAEnC,MAAAA,MAAM,EAAE,IAAI4B,MAAJ,CAAWT,GAAX;AAAV,KAAP;AACD;AAED;;;;;;AAIOoB,EAAAA,MAAP,CAAcN,KAAd,EAA2C;AACzC,QAAI,KAAKlB,IAAL,IAAakB,KAAK,CAAClB,IAAnB,IAA2B,KAAKD,IAAL,IAAamB,KAAK,CAACnB,IAAlD,EAAwD;AACtD,UAAIK,GAAe,GAAG,IAAIC,KAAJ,EAAtB;;AACA,WAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClClB,QAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,aAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCnB,UAAAA,GAAG,CAACkB,CAAD,CAAH,CAAOhB,IAAP,CAAY,KAAKR,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,IAAoBL,KAAK,CAACpB,MAAN,CAAawB,CAAb,EAAgBC,CAAhB,CAAhC;AACD;AACF;;AACD,aAAO;AAAEtC,QAAAA,MAAM,EAAE,IAAI4B,MAAJ,CAAWT,GAAX;AAAV,OAAP;AACD,KATD,MASO;AACL,YAAM,IAAI3C,WAAJ,CACJ,oEADI,CAAN;AAGD;AACF;AAED;;;;;;AAIOa,EAAAA,GAAP,CAAW4C,KAAX,EAAsC;AACpC,QAAIG,QAAQ,CAACH,KAAD,CAAZ,EAAqB;AACnB;AACA;AACA,UAAI,KAAKlB,IAAL,IAAakB,KAAK,CAACnB,IAAvB,EAA6B;AAC3B,YAAI,KAAKC,IAAL,IAAakB,KAAK,CAAClB,IAAnB,IAA2B,KAAKD,IAAL,IAAamB,KAAK,CAACnB,IAAlD,EAAwD;AACtD,iBAAO;AACLd,YAAAA,MAAM,EAAE,KAAKX,GAAL,CAAS4C,KAAK,CAACO,SAAN,GAAkBxC,MAA3B,EAAmCA,MADtC;AAELyC,YAAAA,OAAO,EAAE;AAFJ,WAAP;AAID;;AACD,cAAM,IAAIjE,WAAJ,CACH,yDAAwD,KAAKsC,IAAK,MAAK,KAAKC,IAAK,UAASkB,KAAK,CAACnB,IAAK,MAAKmB,KAAK,CAAClB,IAAK,GADlH,CAAN;AAGD;;AACD,UAAI2B,SAAqB,GAAG,IAAItB,KAAJ,EAA5B;;AACA,WAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCK,QAAAA,SAAS,CAACrB,IAAV,CAAe,EAAf;;AACA,aAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAAClB,IAA1B,EAAgCuB,CAAC,EAAjC,EAAqC;AACnC,cAAIK,IAAI,GAAG,CAAX;;AACA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK7B,IAAzB,EAA+B6B,CAAC,EAAhC,EAAoC;AAClCD,YAAAA,IAAI,IAAI,KAAK9B,MAAL,CAAYwB,CAAZ,EAAeO,CAAf,IAAoBX,KAAK,CAACpB,MAAN,CAAa+B,CAAb,EAAgBN,CAAhB,CAA5B;AACD;;AACDI,UAAAA,SAAS,CAACL,CAAD,CAAT,CAAahB,IAAb,CAAkBsB,IAAlB;AACD;;AAED,YAAID,SAAS,CAAC1B,MAAV,IAAoB,CAApB,IAAyB0B,SAAS,CAAC,CAAD,CAAT,CAAa1B,MAAb,IAAuB,CAApD,EAAuD;AACrD,iBAAO;AAAEhB,YAAAA,MAAM,EAAE,IAAI6C,OAAJ,CAAYH,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAZ;AAAV,WAAP;AACD,SAFD,MAEO;AACL,iBAAO;AAAE1C,YAAAA,MAAM,EAAE,IAAI4B,MAAJ,CAAWc,SAAX;AAAV,WAAP;AACD;AACF;AACF,KA/BD,MA+BO,IAAIjB,SAAS,CAACQ,KAAD,CAAb,EAAsB;AAC3B,UAAId,GAAe,GAAG,IAAIC,KAAJ,EAAtB,CAD2B,CAE3B;;AACA,WAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClClB,QAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,aAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCnB,UAAAA,GAAG,CAACkB,CAAD,CAAH,CAAOhB,IAAP,CAAY,KAAKR,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,IAAoBL,KAAK,CAACP,KAAtC;AACD;AACF;;AACD,aAAO;AAAE1B,QAAAA,MAAM,EAAE,IAAI4B,MAAJ,CAAWT,GAAX;AAAV,OAAP;AACD;;AACD,SAAKgB,4BAAL;AACD;AAED;;;;;;AAIO7C,EAAAA,GAAP,CAAW2C,KAAX,EAA4C;AAC1C,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,UAAId,GAAe,GAAG,IAAIC,KAAJ,EAAtB,CADoB,CAEpB;;AACA,WAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClClB,QAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,aAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCnB,UAAAA,GAAG,CAACkB,CAAD,CAAH,CAAOhB,IAAP,CAAY,KAAKR,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,IAAoBL,KAAK,CAACP,KAAtC;AACD;AACF;;AACD,aAAO;AAAE1B,QAAAA,MAAM,EAAE,IAAI4B,MAAJ,CAAWT,GAAX;AAAV,OAAP;AACD;;AACD,SAAKe,mBAAL;AACD;AAED;;;;;;AAIO3C,EAAAA,IAAP,CAAY0C,KAAZ,EAA6C;AAC3C,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,UAAId,GAAe,GAAG,IAAIC,KAAJ,EAAtB,CADoB,CAEpB;;AACA,WAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClClB,QAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,aAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCnB,UAAAA,GAAG,CAACkB,CAAD,CAAH,CAAOhB,IAAP,CAAYyB,IAAI,CAACC,KAAL,CAAW,KAAKlC,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,IAAoBL,KAAK,CAACP,KAArC,CAAZ;AACD;AACF;;AACD,aAAO;AAAE1B,QAAAA,MAAM,EAAE,IAAI4B,MAAJ,CAAWT,GAAX;AAAV,OAAP;AACD;;AACD,SAAKe,mBAAL;AACD;AAED;;;;;;AAIO1C,EAAAA,GAAP,CAAWyC,KAAX,EAA4C;AAC1C,QAAI,KAAKnB,IAAL,IAAa,KAAKC,IAAtB,EAA4B;AAC1B,YAAM,IAAIvC,WAAJ,CAAgB,kDAAhB,CAAN;AACD;;AACD,QAAIiD,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,UAAIS,SAAiB,GAAG,IAAxB;;AACA,WAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,KAAK,CAACP,KAA1B,EAAiCW,CAAC,EAAlC,EAAsC;AACpC,YAAIW,GAAG,GAAGN,SAAS,CAACrD,GAAV,CAAc,IAAd,EAAoBW,MAA9B;;AACA,YAAIoC,QAAQ,CAACY,GAAD,CAAZ,EAAmB;AACjBN,UAAAA,SAAS,GAAGM,GAAZ;AACD,SAFD,MAEO;AACL,gBAAM,IAAIxE,WAAJ,CAAgB,4BAA4BwE,GAA5C,CAAN;AACD;AACF;;AACD,aAAO;AAAEhD,QAAAA,MAAM,EAAE0C;AAAV,OAAP;AACD,KAXD,MAWO;AACL,YAAM,IAAIlE,WAAJ,CAAgB,+BAAhB,CAAN;AACD;AACF;;AAEMgE,EAAAA,SAAP,CAAiBS,IAAa,GAAG,KAAjC,EAAsD;AACpD,QAAI9B,GAAe,GAAG,IAAIC,KAAJ,EAAtB;;AACA,SAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKtB,IAAzB,EAA+BsB,CAAC,EAAhC,EAAoC;AAClClB,MAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,WAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKxB,IAAzB,EAA+BwB,CAAC,EAAhC,EAAoC;AAClCnB,QAAAA,GAAG,CAACkB,CAAD,CAAH,CAAOhB,IAAP,CAAY,KAAKR,MAAL,CAAYyB,CAAZ,EAAeD,CAAf,CAAZ;AACD;AACF;;AAED,QAAIY,IAAJ,EAAU;AACR,WAAKpC,MAAL,GAAcM,GAAd;AACA,UAAI6B,GAAG,GAAG,KAAKlC,IAAf;AACA,WAAKA,IAAL,GAAY,KAAKC,IAAjB;AACA,WAAKA,IAAL,GAAYiC,GAAZ;AACA,aAAO;AAAEhD,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AACD,WAAO;AAAEA,MAAAA,MAAM,EAAE,IAAI4B,MAAJ,CAAWT,GAAX;AAAV,KAAP;AACD;;AAEM+B,EAAAA,WAAP,GAA6B;AAC3B,QAAI,KAAKpC,IAAL,IAAa,KAAKC,IAAtB,EAA4B;AAC1B,YAAM,IAAIvC,WAAJ,CAAgB,8CAAhB,CAAN;AACD;;AAED,QAAI2E,CAAC,GAAG,KAAKrC,IAAb;AACA,QAAIsC,CAAC,GAAG,KAAKvC,MAAb;;AACA,QAAIsC,CAAC,IAAI,CAAT,EAAY;AACV,aAAOC,CAAC,CAAC,CAAD,CAAD,CAAK,CAAL,IAAUA,CAAC,CAAC,CAAD,CAAD,CAAK,CAAL,CAAV,GAAoBA,CAAC,CAAC,CAAD,CAAD,CAAK,CAAL,IAAUA,CAAC,CAAC,CAAD,CAAD,CAAK,CAAL,CAArC;AACD,KAFD,MAEO;AACL,UAAIC,CAAC,GAAG,CAAR;;AACA,WAAK,IAAIhB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,CAApB,EAAuBd,CAAC,EAAxB,EAA4B;AAC1B;AACA,YAAIiB,SAAqB,GAAG,EAA5B;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAApB,EAAuBI,CAAC,EAAxB,EAA4B;AAC1BD,UAAAA,SAAS,CAACjC,IAAV,CAAe,EAAf;;AACA,eAAK,IAAImC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,CAApB,EAAuBK,CAAC,EAAxB,EAA4B;AAC1B,gBAAIA,CAAC,IAAInB,CAAT,EAAY;AACViB,cAAAA,SAAS,CAACC,CAAD,CAAT,CAAalC,IAAb,CAAkB,KAAKR,MAAL,CAAY0C,CAAZ,EAAeC,CAAf,CAAlB;AACD;AACF;AACF;;AAEDH,QAAAA,CAAC,IAAID,CAAC,CAAC,CAAD,CAAD,CAAKf,CAAL,IAAU,IAAIT,MAAJ,CAAW0B,SAAX,EAAsBJ,WAAtB,EAAf;AACD;;AACD,aAAOG,CAAP;AACD;AACF;;AAEMC,EAAAA,SAAP,CACEG,QADF,EAEEC,MAAc,GAAG,KAAK5C,IAAL,GAAY,CAF/B,EAGE6C,QAHF,EAIEC,MAAc,GAAG,KAAK7C,IAAL,GAAY,CAJ/B,EAKU;AACR,QAAII,GAAe,GAAG,IAAIC,KAAJ,EAAtB;;AACA,SAAK,IAAIiB,CAAC,GAAGoB,QAAb,EAAuBpB,CAAC,IAAIqB,MAA5B,EAAoCrB,CAAC,EAArC,EAAyC;AACvClB,MAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;;AACA,WAAK,IAAIiB,CAAC,GAAGqB,QAAb,EAAuBrB,CAAC,IAAIsB,MAA5B,EAAoCtB,CAAC,EAArC,EAAyC;AACvCnB,QAAAA,GAAG,CAACkB,CAAD,CAAH,CAAOhB,IAAP,CAAY,KAAKR,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,CAAZ;AACD;AACF;;AACD,WAAO,IAAIV,MAAJ,CAAWT,GAAX,CAAP;AACD;;AAEMzB,EAAAA,IAAP,CAAYuC,KAAZ,EAA8C;AAC5C,UAAM,IAAI4B,KAAJ,CAAU,wCAAV,CAAN;AACD;;AACMjE,EAAAA,IAAP,CAAYqC,KAAZ,EAA8C;AAC5C,UAAM,IAAI4B,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAEMC,EAAAA,UAAP,CAAkB7B,KAAlB,EAA6C;AAC3C,QAAIG,QAAQ,CAACH,KAAD,CAAZ,EAAqB;AACnB,UAAIA,KAAK,CAAClB,IAAN,IAAc,KAAKA,IAAnB,IAA2BkB,KAAK,CAACnB,IAAN,IAAc,KAAKA,IAAlD,EAAwD;AACtD,cAAM,IAAItC,WAAJ,CACJ,oDADI,CAAN;AAGD;;AACD,UAAIuF,MAAkB,GAAG,EAAzB;;AACA,WAAK,IAAI1B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClC,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCyB,UAAAA,MAAM,CAAC1B,CAAD,CAAN,CAAUC,CAAV,IAAe,KAAKzB,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,IAAoBL,KAAK,CAACpB,MAAN,CAAawB,CAAb,EAAgBC,CAAhB,CAAnC;AACD;AACF;;AACD,aAAO;AAAEtC,QAAAA,MAAM,EAAE,IAAI4B,MAAJ,CAAWmC,MAAX;AAAV,OAAP;AACD,KAbD,MAaO,IAAItC,SAAS,CAACQ,KAAD,CAAb,EAAsB;AAC3B,UAAI8B,MAAkB,GAAG,EAAzB;;AACA,WAAK,IAAI1B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClC,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClCyB,UAAAA,MAAM,CAAC1B,CAAD,CAAN,CAAUC,CAAV,IAAe,KAAKzB,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,IAAoBL,KAAK,CAACP,KAAzC;AACD;AACF;;AACD,aAAO;AAAE1B,QAAAA,MAAM,EAAE,IAAI4B,MAAJ,CAAWmC,MAAX;AAAV,OAAP;AACD;;AACD,SAAK5B,4BAAL;AACD;;AACM6B,EAAAA,SAAP,CAAiB/B,KAAjB,EAA4C;AAC1C,QAAIG,QAAQ,CAACH,KAAD,CAAZ,EAAqB,CACpB,CADD,MACO,IAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB,CAC5B;;AACD,SAAKE,4BAAL;AACD;;AAEMrC,EAAAA,MAAP,CAAcmC,KAAd,EAAgD;AAC9C,QAAIG,QAAQ,CAACH,KAAD,CAAZ,EAAqB;AACnB,UAAI,KAAKnB,IAAL,IAAamB,KAAK,CAACnB,IAAnB,IAA2B,KAAKC,IAAL,IAAakB,KAAK,CAAClB,IAAlD,EAAwD;AACtD,aAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClC,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClC,gBAAI,KAAKzB,MAAL,CAAYwB,CAAZ,EAAeC,CAAf,KAAqBL,KAAK,CAACpB,MAAN,CAAawB,CAAb,EAAgBC,CAAhB,CAAzB,EAA6C;AAC3C,qBAAO;AAAEtC,gBAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,KAAZ;AAAV,eAAP;AACD;AACF;AACF;;AACD,eAAO;AAAEjE,UAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,IAAZ;AAAV,SAAP;AACD,OATD,MASO;AACL,cAAM,IAAIzF,WAAJ,CAAgB,qCAAhB,CAAN;AACD;AACF;;AACD,SAAK0D,mBAAL;AACD;;AAEMzB,EAAAA,QAAP,GAA0B;AACxB,QAAIqB,CAAC,GAAG,KAAKjB,MAAb;AACA,QAAIqD,GAAG,GAAG,EAAV;;AACA,QAAIpC,CAAC,CAACd,MAAF,IAAY,CAAhB,EAAmB;AACjBkD,MAAAA,GAAG,IAAI,IAAP;;AACA,WAAK,IAAI7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKtB,IAAzB,EAA+BsB,CAAC,EAAhC,EAAoC;AAClC6B,QAAAA,GAAG,IAAIpC,CAAC,CAAC,CAAD,CAAD,CAAKO,CAAL,CAAP;;AACA,YAAIA,CAAC,IAAIP,CAAC,CAAC,CAAD,CAAD,CAAKd,MAAL,GAAc,CAAvB,EAA0B;AACxBkD,UAAAA,GAAG,IAAI,GAAP;AACD;AACF;;AACDA,MAAAA,GAAG,IAAI,IAAP;AACD,KATD,MASO;AACLA,MAAAA,GAAG,IAAI,GAAP;;AACA,WAAK,IAAI7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClC,YAAIA,CAAC,IAAI,CAAT,EAAY;AACV6B,UAAAA,GAAG,IAAI,GAAP;AACD;;AACDA,QAAAA,GAAG,IAAI,IAAP;;AACA,aAAK,IAAI5B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvB,IAAzB,EAA+BuB,CAAC,EAAhC,EAAoC;AAClC4B,UAAAA,GAAG,IAAIpC,CAAC,CAACO,CAAD,CAAD,CAAKC,CAAL,IAAU,GAAjB;AACD;;AACD4B,QAAAA,GAAG,IAAI,GAAP;;AACA,YAAI7B,CAAC,IAAI,KAAKvB,IAAL,GAAY,CAArB,EAAwB;AACtBoD,UAAAA,GAAG,IAAI,IAAP;AACD;AACF;;AACDA,MAAAA,GAAG,IAAI,GAAP;AACAA,MAAAA,GAAG,IAAK,OAAM,KAAKpD,IAAK,MAAK,KAAKC,IAAK,IAAvC;AACD;;AAED,WAAOmD,GAAP;AACD;;AApYoC;AAuYvC,OAAO,SAAS9B,QAAT,CAAkBxD,EAAlB,EAAyC;AAC9C,SAAOA,EAAE,YAAYgD,MAArB;AACD;AAED,OAAO,MAAMiB,OAAN,SAAsBnE,UAAtB,CAAiC;AAGtCiC,EAAAA,WAAW,CAACY,GAAD,EAAc;AACvB;AADuB,SAFzBG,KAEyB;AAEvB,SAAKA,KAAL,GAAaH,GAAb;AACD;;AAEO4C,EAAAA,KAAR,GAAuB;AACrB,UAAM,IAAI5F,eAAJ,CAAoB,qCAApB,CAAN;AACD;;AAEMW,EAAAA,GAAP,CAAW+C,KAAX,EAAsC;AACpC,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,aAAO;AAAEjC,QAAAA,MAAM,EAAE,IAAI6C,OAAJ,CAAY,KAAKnB,KAAL,GAAaO,KAAK,CAACP,KAA/B;AAAV,OAAP;AACD,KAFD,MAEO,IAAIU,QAAQ,CAACH,KAAD,CAAZ,EAAqB;AAC1B,aAAOA,KAAK,CAAC/C,GAAN,CAAU,IAAV,CAAP;AACD;;AACD,SAAKiF,KAAL;AACD;;AAEM/E,EAAAA,GAAP,CAAW6C,KAAX,EAAsC;AACpC,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,aAAO;AAAEjC,QAAAA,MAAM,EAAE,IAAI6C,OAAJ,CAAY,KAAKnB,KAAL,GAAaO,KAAK,CAACP,KAA/B;AAAV,OAAP;AACD,KAFD,MAEO,IAAIU,QAAQ,CAACH,KAAD,CAAZ,EAAqB;AAC1B,aAAOA,KAAK,CAAC5C,GAAN,CAAU,IAAIwD,OAAJ,CAAY,CAAC,CAAb,CAAV,EAA2B7C,MAA3B,CAAkCd,GAAlC,CAAsC,IAAtC,CAAP;AACD;;AACD,SAAKiF,KAAL;AACD;;AAEM9E,EAAAA,GAAP,CAAW4C,KAAX,EAAsC;AACpC,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,aAAO;AAAEjC,QAAAA,MAAM,EAAE,IAAI6C,OAAJ,CAAY,KAAKnB,KAAL,GAAaO,KAAK,CAACP,KAA/B;AAAV,OAAP;AACD,KAFD,MAEO,IAAIU,QAAQ,CAACH,KAAD,CAAZ,EAAqB;AAC1B,aAAOA,KAAK,CAAC5C,GAAN,CAAU,IAAV,CAAP;AACD;;AACD,SAAK8E,KAAL;AACD;;AAEM7E,EAAAA,GAAP,CAAW2C,KAAX,EAAsC;AACpC,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,aAAO;AAAEjC,QAAAA,MAAM,EAAE,IAAI6C,OAAJ,CAAY,KAAKnB,KAAL,GAAaO,KAAK,CAACP,KAA/B;AAAV,OAAP;AACD,KAFD,MAEO,IAAIU,QAAQ,CAACH,KAAD,CAAZ,EAAqB;AAC1B,aAAOA,KAAK,CAAC3C,GAAN,CAAU,IAAV,CAAP;AACD;;AACD,SAAK6E,KAAL;AACD;;AAEM5E,EAAAA,IAAP,CAAY0C,KAAZ,EAAuC;AACrC,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,aAAO;AAAEjC,QAAAA,MAAM,EAAE,IAAI6C,OAAJ,CAAYC,IAAI,CAACC,KAAL,CAAW,KAAKrB,KAAL,GAAaO,KAAK,CAACP,KAA9B,CAAZ;AAAV,OAAP;AACD,KAFD,MAEO,IAAIU,QAAQ,CAACH,KAAD,CAAZ,EAAqB;AAC1B,aAAOA,KAAK,CAAC1C,IAAN,CAAW,IAAX,CAAP;AACD;;AACD,SAAK4E,KAAL;AACD;;AAEM3E,EAAAA,GAAP,CAAWyC,KAAX,EAAsC;AACpC,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,aAAO;AAAEjC,QAAAA,MAAM,EAAE,IAAI6C,OAAJ,CAAYC,IAAI,CAACtD,GAAL,CAAS,KAAKkC,KAAd,EAAqBO,KAAK,CAACP,KAA3B,CAAZ;AAAV,OAAP;AACD;;AACD,SAAKyC,KAAL;AACD;;AAEMzE,EAAAA,IAAP,CAAYuC,KAAZ,EAA8C;AAC5C,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,aAAO;AAAEjC,QAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,KAAKvC,KAAL,GAAaO,KAAK,CAACP,KAA/B;AAAV,OAAP;AACD;;AACD,SAAKyC,KAAL;AACD;;AACMvE,EAAAA,IAAP,CAAYqC,KAAZ,EAA8C;AAC5C,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,aAAO;AAAEjC,QAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,KAAKvC,KAAL,GAAaO,KAAK,CAACP,KAA/B;AAAV,OAAP;AACD;;AACD,SAAKyC,KAAL;AACD;;AACMrE,EAAAA,MAAP,CAAcmC,KAAd,EAAgD;AAC9C,QAAIR,SAAS,CAACQ,KAAD,CAAb,EAAsB;AACpB,aAAO;AAAEjC,QAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,KAAKvC,KAAL,IAAcO,KAAK,CAACP,KAAhC;AAAV,OAAP;AACD;;AACD,SAAKyC,KAAL;AACD;;AAEML,EAAAA,UAAP,CAAkB7B,KAAlB,EAA6C;AAC3C,UAAM,IAAI4B,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACMG,EAAAA,SAAP,CAAiB/B,KAAjB,EAA4C;AAC1C,UAAM,IAAI4B,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAEMpD,EAAAA,QAAP,GAA0B;AACxB,WAAO,KAAKiB,KAAL,CAAWjB,QAAX,EAAP;AACD;;AA5FqC;AA+FxC,OAAO,SAASgB,SAAT,CAAmB7C,EAAnB,EAA2C;AAChD,SAAOA,EAAE,YAAYiE,OAArB;AACD;;AAKD;;;AAGA,OAAO,MAAMoB,OAAN,SAAsBpB,OAAtB,CAA8B;AAGnC,MAAWuB,OAAX,GAAqB;AACnB,WAAO,KAAKC,QAAZ;AACD;;AAED1D,EAAAA,WAAW,CAACe,KAAD,EAAiB;AAC1B,UAAMA,KAAK,GAAG,CAAH,GAAO,CAAlB;AAD0B,SANpB2C,QAMoB;AAE1B,SAAKA,QAAL,GAAgB3C,KAAhB;AACD;;AAEMxC,EAAAA,GAAP,CAAW+C,KAAX,EAAsC;AACpC,WAAOA,KAAK,CAAC/C,GAAN,CAAU,IAAI2D,OAAJ,CAAY,KAAKnB,KAAjB,CAAV,CAAP;AACD;;AACMtC,EAAAA,GAAP,CAAW6C,KAAX,EAAsC;AACpC,WAAOA,KAAK,CAAC/C,GAAN,CAAU,IAAI2D,OAAJ,CAAY,KAAKnB,KAAL,GAAa,CAAC,CAA1B,CAAV,CAAP;AACD;;AACMrC,EAAAA,GAAP,CAAW4C,KAAX,EAAsC;AACpC,WAAOA,KAAK,CAAC5C,GAAN,CAAU,IAAIwD,OAAJ,CAAY,KAAKnB,KAAjB,CAAV,CAAP;AACD;;AACMpC,EAAAA,GAAP,CAAW2C,KAAX,EAAsC;AACpC,UAAM,IAAI1D,eAAJ,CAAoB,mCAApB,CAAN;AACD;;AAEMgB,EAAAA,IAAP,CAAY0C,KAAZ,EAAuC;AACrC,UAAM,IAAI1D,eAAJ,CAAoB,mCAApB,CAAN;AACD;;AACMiB,EAAAA,GAAP,CAAWyC,KAAX,EAAsC;AACpC,UAAM,IAAI1D,eAAJ,CAAoB,8BAApB,CAAN;AACD;;AAEM0B,EAAAA,EAAP,CAAUgC,KAAV,EAAyC;AACvC,WAAO;AAAEjC,MAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,KAAKG,OAAL,IAAgBnC,KAAK,CAACmC,OAAlC;AAAV,KAAP;AACD;;AAEM5D,EAAAA,GAAP,CAAWyB,KAAX,EAA0C;AACxC,WAAO;AAAEjC,MAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,KAAKG,OAAL,IAAgBnC,KAAK,CAACmC,OAAlC;AAAV,KAAP;AACD;;AAEME,EAAAA,GAAP,CAAWrC,KAAX,EAA0C;AACxC,WAAO;AAAEjC,MAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,KAAKG,OAAL,KAAiBnC,KAAK,CAACmC,OAAnC;AAAV,KAAP;AACD;;AAEMG,EAAAA,IAAP,CAAYtC,KAAZ,EAA2C;AACzC,WAAO;AACLjC,MAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,KAAKG,OAAL,IAAgBnC,KAAK,CAACmC,OAAtB,IAAiC,CAAC,KAAKA,OAAnD;AADH,KAAP;AAGD;;AAEM/D,EAAAA,GAAP,CAAW4B,KAAX,EAA0C;AACxC,WAAO;AACLjC,MAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,KAAKG,OAAL,IAAgBnC,KAAK,CAACmC,OAAlC;AADH,KAAP;AAGD;;AAEM1E,EAAAA,IAAP,CAAYuC,KAAZ,EAA8C;AAC5C,UAAM,IAAI4B,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACMjE,EAAAA,IAAP,CAAYqC,KAAZ,EAA8C;AAC5C,UAAM,IAAI4B,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAEM/D,EAAAA,MAAP,CAAcmC,KAAd,EAAgD;AAC9C,QAAI1B,SAAS,CAAC0B,KAAD,CAAb,EAAsB;AACpB,aAAO;AAAEjC,QAAAA,MAAM,EAAE,IAAIiE,OAAJ,CAAY,KAAKvC,KAAL,IAAcO,KAAK,CAACP,KAAhC;AAAV,OAAP;AACD;;AACD,UAAM,IAAInD,eAAJ,CAAoB,wCAApB,CAAN;AACD;;AAEMkC,EAAAA,QAAP,GAA0B;AACxB,WAAO,IAAI+D,MAAJ,CAAW,KAAKJ,OAAhB,EAAyB3D,QAAzB,EAAP;AACD;;AAxEkC;AA2ErC,OAAO,SAASF,SAAT,CAAmB3B,EAAnB,EAA2C;AAChD,SAAOA,EAAE,YAAYqF,OAArB;AACD","sourcesContent":["import { ComputableNode } from \"./ast\";\nimport { ArithmeticError, MatrixError } from \"./errors\";\nimport { TokenType } from \"./token\";\n\nexport interface Result {\n  result: Computable;\n  message?: string;\n}\n\nexport abstract class Computable {\n  public abstract add(other: Computable): Result;\n  public abstract sub(other: Computable): Result;\n  public abstract mul(other: Computable): Result;\n  public abstract div(other: Computable): Result;\n  public abstract rdiv(other: Computable): Result;\n  public abstract pow(other: Computable): Result;\n  public abstract less(other: Computable): LogicalResult;\n  public abstract more(other: Computable): LogicalResult;\n  public abstract equals(other: Computable): LogicalResult;\n  public abstract bitwiseAnd(other: Computable): Result;\n  public abstract bitwiseOr(other: Computable): Result;\n}\n\n/**\n * checks if given element is of type computable\n * @param el any element\n */\nexport function isComputable(el: any): el is Computable {\n  return el instanceof Computable;\n}\n\nexport function computeResult(\n  a: Computable,\n  b: Computable,\n  operator: TokenType\n): Result {\n  switch (operator) {\n    case TokenType.plus:\n      return a.add(b);\n    case TokenType.minus:\n      return a.sub(b);\n    case TokenType.mul:\n      return a.mul(b);\n    case TokenType.div:\n      return a.div(b);\n    case TokenType.rdiv:\n      return a.rdiv(b);\n    case TokenType.pow:\n      return a.pow(b);\n    case TokenType.larrow:\n      return a.less(b);\n    case TokenType.rarrow:\n      return a.more(b);\n    case TokenType.eq:\n      return a.equals(b);\n    case TokenType.more_eq:\n      return a.more(b).result.or(a.equals(b).result);\n    case TokenType.less_eq:\n      return a.less(b).result.or(a.equals(b).result);\n  }\n  if (\n    operator == TokenType.and_bool ||\n    operator == TokenType.or_bool ||\n    operator == TokenType.not ||\n    operator == TokenType.not_bool\n  ) {\n    if (isLogical(a) && isLogical(b)) {\n      switch (operator) {\n        case TokenType.and_bool:\n          return a.and(b);\n        case TokenType.or_bool:\n          return a.or(b);\n        case TokenType.not_bool:\n          return a.not(b);\n      }\n    } else {\n      throw new ArithmeticError(\"boolean operator exepcts bool expression\");\n    }\n  }\n  throw new ArithmeticError(\"unsupported operation \" + operator.toString());\n}\n\nexport interface MatrixResult extends Result {\n  result: Matrix;\n}\n\nexport class UnevaluatedMatrix {\n  private matrix: ComputableNode[][];\n  private dimR: number;\n  private dimC: number;\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(nodes: ComputableNode[][]) {\n    // raw node matrix\n    this.matrix = nodes;\n    this.dimR = nodes.length;\n    this.dimC = this.dimR > 0 ? nodes[0].length : 0;\n\n    // verify each row is the same length\n    for (let row of nodes) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n\n  /**\n   * evaluates matrix from raw nodes\n   */\n  public evaluate(): Matrix {\n    let arr: number[][] = new Array();\n    for (let row = 0; row < this.dimR; row++) {\n      arr.push([]);\n      for (let col = 0; col < this.dimC; col++) {\n        let val = this.matrix[row][col].eval();\n        if (isNumeric(val)) {\n          arr[row].push(val.value);\n        } else {\n          throw new SyntaxError(\"couldn't evaluate matrix! expected numbers.\");\n        }\n      }\n    }\n    return new Matrix(arr);\n  }\n\n  public static isUnevaluatedMatrix(m: any): m is UnevaluatedMatrix {\n    return m instanceof UnevaluatedMatrix;\n  }\n}\n\nexport class Matrix extends Computable {\n  matrix: number[][];\n  dimR: number;\n  dimC: number;\n\n  /**\n   * constructs a new matrix\n   * @param nodes optional: matrix as nodes if matrix unevaluated\n   * @param rows optional: matrix as numeric array if matrix evaluated\n   */\n  constructor(rows: number[][]) {\n    super();\n\n    this.matrix = rows;\n    this.dimR = rows.length;\n    this.dimC = this.dimR > 0 ? rows[0].length : 0;\n\n    // verify each row is the same length\n    for (let row of rows) {\n      if (row.length != this.dimC) {\n        throw new MatrixError(\"row dimensions did not match\");\n      }\n    }\n  }\n\n  private checkDimensions(other: Matrix) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(\n        `can't perform operations on matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n      );\n    }\n  }\n\n  private expectedMatrixError(): never {\n    throw new ArithmeticError(\"expected a matrix for calculations.\");\n  }\n\n  private expectedMatrixOrNumericError(): never {\n    throw new ArithmeticError(\"expected a matrix or numeric for calculations.\");\n  }\n\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n  public add(other: Computable): MatrixResult {\n    let arr: number[][] = new Array();\n    if (isMatrix(other)) {\n      // add two matricies together\n      this.checkDimensions(other);\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // add constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] + other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return { result: new Matrix(arr) };\n  }\n\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n  public sub(other: Computable): MatrixResult {\n    let arr: number[][] = new Array();\n\n    if (isMatrix(other)) {\n      // subtract two matricies together\n      this.checkDimensions(other);\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.matrix[i][j]);\n        }\n      }\n    } else if (isNumeric(other)) {\n      // subtract constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] - other.value);\n        }\n      }\n    } else {\n      this.expectedMatrixOrNumericError();\n    }\n\n    return { result: new Matrix(arr) };\n  }\n\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n  public el_mul(other: Matrix): MatrixResult {\n    if (this.dimC == other.dimC && this.dimR == other.dimR) {\n      let arr: number[][] = new Array();\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.matrix[i][j]);\n        }\n      }\n      return { result: new Matrix(arr) };\n    } else {\n      throw new MatrixError(\n        \"cannot do element-wise multiplication on different sized matricies\"\n      );\n    }\n  }\n\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n  public mul(other: Computable): Result {\n    if (isMatrix(other)) {\n      // multiply two matricies\n      // check dimensions are proper\n      if (this.dimC != other.dimR) {\n        if (this.dimC == other.dimC && this.dimR == other.dimR) {\n          return {\n            result: this.mul(other.transpose().result).result,\n            message: \"inferred to take dot product.\",\n          };\n        }\n        throw new MatrixError(\n          `can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n        );\n      }\n      let newMatrix: number[][] = new Array();\n      for (let i = 0; i < this.dimR; i++) {\n        newMatrix.push([]);\n        for (let j = 0; j < other.dimC; j++) {\n          let temp = 0;\n          for (let k = 0; k < this.dimC; k++) {\n            temp += this.matrix[i][k] * other.matrix[k][j];\n          }\n          newMatrix[i].push(temp);\n        }\n\n        if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n          return { result: new Numeric(newMatrix[0][0]) };\n        } else {\n          return { result: new Matrix(newMatrix) };\n        }\n      }\n    } else if (isNumeric(other)) {\n      let arr: number[][] = new Array();\n      // multiply constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] * other.value);\n        }\n      }\n      return { result: new Matrix(arr) };\n    }\n    this.expectedMatrixOrNumericError();\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public div(other: Computable): MatrixResult {\n    if (isNumeric(other)) {\n      let arr: number[][] = new Array();\n      // multiply constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(this.matrix[i][j] / other.value);\n        }\n      }\n      return { result: new Matrix(arr) };\n    }\n    this.expectedMatrixError();\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public rdiv(other: Computable): MatrixResult {\n    if (isNumeric(other)) {\n      let arr: number[][] = new Array();\n      // multiply constant to each element\n      for (let i = 0; i < this.dimR; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimC; j++) {\n          arr[i].push(Math.floor(this.matrix[i][j] / other.value));\n        }\n      }\n      return { result: new Matrix(arr) };\n    }\n    this.expectedMatrixError();\n  }\n\n  /**\n   * take power\n   * @param other\n   */\n  public pow(other: Computable): MatrixResult {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"only square matricies can be raised to the power\");\n    }\n    if (isNumeric(other)) {\n      let newMatrix: Matrix = this;\n      for (let i = 0; i < other.value; i++) {\n        let tmp = newMatrix.mul(this).result;\n        if (isMatrix(tmp)) {\n          newMatrix = tmp;\n        } else {\n          throw new MatrixError(\"multiplication failed: \" + tmp);\n        }\n      }\n      return { result: newMatrix };\n    } else {\n      throw new MatrixError(\"matrix power is not supported\");\n    }\n  }\n\n  public transpose(save: boolean = false): MatrixResult {\n    let arr: number[][] = new Array();\n    for (let i = 0; i < this.dimC; i++) {\n      arr.push([]);\n      for (let j = 0; j < this.dimR; j++) {\n        arr[i].push(this.matrix[j][i]);\n      }\n    }\n\n    if (save) {\n      this.matrix = arr;\n      let tmp = this.dimR;\n      this.dimR = this.dimC;\n      this.dimC = tmp;\n      return { result: this };\n    }\n    return { result: new Matrix(arr) };\n  }\n\n  public determinant(): number {\n    if (this.dimR != this.dimC) {\n      throw new MatrixError(\"cannot take determinant of non-square matrix\");\n    }\n\n    let n = this.dimR;\n    let M = this.matrix;\n    if (n == 2) {\n      return M[0][0] * M[1][1] - M[0][1] * M[1][0];\n    } else {\n      let d = 0;\n      for (let i = 0; i < n; i++) {\n        // create a sub matrix\n        let subMatrix: number[][] = [];\n        for (let r = 0; r < n; r++) {\n          subMatrix.push([]);\n          for (let c = 0; c < n; c++) {\n            if (c != i) {\n              subMatrix[r].push(this.matrix[r][c]);\n            }\n          }\n        }\n\n        d += M[0][i] * new Matrix(subMatrix).determinant();\n      }\n      return d;\n    }\n  }\n\n  public subMatrix(\n    startRow: number,\n    endRow: number = this.dimR - 1,\n    startCol: number,\n    endCol: number = this.dimC - 1\n  ): Matrix {\n    let arr: number[][] = new Array();\n    for (let i = startRow; i <= endRow; i++) {\n      arr.push([]);\n      for (let j = startCol; j <= endCol; j++) {\n        arr[i].push(this.matrix[i][j]);\n      }\n    }\n    return new Matrix(arr);\n  }\n\n  public less(other: Computable): LogicalResult {\n    throw new Error(\"matrix not implemented for < operator.\");\n  }\n  public more(other: Computable): LogicalResult {\n    throw new Error(\"matrix not implemented for > operator.\");\n  }\n\n  public bitwiseAnd(other: Computable): Result {\n    if (isMatrix(other)) {\n      if (other.dimC != this.dimC || other.dimR != this.dimR) {\n        throw new MatrixError(\n          \"can't operate on matricies of different dimensions\"\n        );\n      }\n      let newArr: number[][] = [];\n      for (let i = 0; i < this.dimR; i++) {\n        for (let j = 0; j < this.dimC; j++) {\n          newArr[i][j] = this.matrix[i][j] & other.matrix[i][j];\n        }\n      }\n      return { result: new Matrix(newArr) };\n    } else if (isNumeric(other)) {\n      let newArr: number[][] = [];\n      for (let i = 0; i < this.dimR; i++) {\n        for (let j = 0; j < this.dimC; j++) {\n          newArr[i][j] = this.matrix[i][j] & other.value;\n        }\n      }\n      return { result: new Matrix(newArr) };\n    }\n    this.expectedMatrixOrNumericError();\n  }\n  public bitwiseOr(other: Computable): Result {\n    if (isMatrix(other)) {\n    } else if (isNumeric(other)) {\n    }\n    this.expectedMatrixOrNumericError();\n  }\n\n  public equals(other: Computable): LogicalResult {\n    if (isMatrix(other)) {\n      if (this.dimR == other.dimR && this.dimC == other.dimC) {\n        for (let i = 0; i < this.dimR; i++) {\n          for (let j = 0; j < this.dimC; j++) {\n            if (this.matrix[i][j] != other.matrix[i][j]) {\n              return { result: new Logical(false) };\n            }\n          }\n        }\n        return { result: new Logical(true) };\n      } else {\n        throw new MatrixError(\"matrix dimensions must be the same!\");\n      }\n    }\n    this.expectedMatrixError();\n  }\n\n  public toString(): string {\n    let m = this.matrix;\n    let str = \"\";\n    if (m.length == 1) {\n      str += \"< \";\n      for (let i = 0; i < this.dimC; i++) {\n        str += m[0][i];\n        if (i != m[0].length - 1) {\n          str += \" \";\n        }\n      }\n      str += \" >\";\n    } else {\n      str += \"[\";\n      for (let i = 0; i < this.dimR; i++) {\n        if (i != 0) {\n          str += \" \";\n        }\n        str += \"[ \";\n        for (let j = 0; j < this.dimC; j++) {\n          str += m[i][j] + \" \";\n        }\n        str += \"]\";\n        if (i != this.dimR - 1) {\n          str += \"\\n\";\n        }\n      }\n      str += \"]\";\n      str += `  { ${this.dimR} x ${this.dimC} }`;\n    }\n\n    return str;\n  }\n}\n\nexport function isMatrix(el: any): el is Matrix {\n  return el instanceof Matrix;\n}\n\nexport class Numeric extends Computable {\n  value: number;\n\n  constructor(val: number) {\n    super();\n    this.value = val;\n  }\n\n  private error(): never {\n    throw new ArithmeticError(\"cannot add numeric with non-numeric\");\n  }\n\n  public add(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value + other.value) };\n    } else if (isMatrix(other)) {\n      return other.add(this);\n    }\n    this.error();\n  }\n\n  public sub(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value - other.value) };\n    } else if (isMatrix(other)) {\n      return other.mul(new Numeric(-1)).result.add(this);\n    }\n    this.error();\n  }\n\n  public mul(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value * other.value) };\n    } else if (isMatrix(other)) {\n      return other.mul(this);\n    }\n    this.error();\n  }\n\n  public div(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(this.value / other.value) };\n    } else if (isMatrix(other)) {\n      return other.div(this);\n    }\n    this.error();\n  }\n\n  public rdiv(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(Math.floor(this.value / other.value)) };\n    } else if (isMatrix(other)) {\n      return other.rdiv(this);\n    }\n    this.error();\n  }\n\n  public pow(other: Computable): Result {\n    if (isNumeric(other)) {\n      return { result: new Numeric(Math.pow(this.value, other.value)) };\n    }\n    this.error();\n  }\n\n  public less(other: Computable): LogicalResult {\n    if (isNumeric(other)) {\n      return { result: new Logical(this.value < other.value) };\n    }\n    this.error();\n  }\n  public more(other: Computable): LogicalResult {\n    if (isNumeric(other)) {\n      return { result: new Logical(this.value > other.value) };\n    }\n    this.error();\n  }\n  public equals(other: Computable): LogicalResult {\n    if (isNumeric(other)) {\n      return { result: new Logical(this.value == other.value) };\n    }\n    this.error();\n  }\n\n  public bitwiseAnd(other: Computable): Result {\n    throw new Error(\"Method not implemented.\");\n  }\n  public bitwiseOr(other: Computable): Result {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  public toString(): string {\n    return this.value.toString();\n  }\n}\n\nexport function isNumeric(el: any): el is Numeric {\n  return el instanceof Numeric;\n}\n\nexport interface LogicalResult extends Result {\n  result: Logical;\n}\n/**\n * boolean computable value\n */\nexport class Logical extends Numeric {\n  private _boolVal: boolean;\n\n  public get boolVal() {\n    return this._boolVal;\n  }\n\n  constructor(value: boolean) {\n    super(value ? 1 : 0);\n    this._boolVal = value;\n  }\n\n  public add(other: Computable): Result {\n    return other.add(new Numeric(this.value));\n  }\n  public sub(other: Computable): Result {\n    return other.add(new Numeric(this.value * -1));\n  }\n  public mul(other: Computable): Result {\n    return other.mul(new Numeric(this.value));\n  }\n  public div(other: Computable): Result {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n\n  public rdiv(other: Computable): Result {\n    throw new ArithmeticError(\"boolean division is not supported\");\n  }\n  public pow(other: Computable): Result {\n    throw new ArithmeticError(\"boolean powers not supported\");\n  }\n\n  public or(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal || other.boolVal) };\n  }\n\n  public and(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal && other.boolVal) };\n  }\n\n  public xor(other: Logical): LogicalResult {\n    return { result: new Logical(this.boolVal !== other.boolVal) };\n  }\n\n  public nand(other: Logical): LogicalResult {\n    return {\n      result: new Logical(this.boolVal == other.boolVal && !this.boolVal),\n    };\n  }\n\n  public not(other: Logical): LogicalResult {\n    return {\n      result: new Logical(this.boolVal != other.boolVal),\n    };\n  }\n\n  public less(other: Computable): LogicalResult {\n    throw new Error(\"boolean not implemented for < operator.\");\n  }\n  public more(other: Computable): LogicalResult {\n    throw new Error(\"boolean not implemented for > operator.\");\n  }\n\n  public equals(other: Computable): LogicalResult {\n    if (isLogical(other)) {\n      return { result: new Logical(this.value == other.value) };\n    }\n    throw new ArithmeticError(\"cannot equate booleans and other types\");\n  }\n\n  public toString(): string {\n    return new String(this.boolVal).toString();\n  }\n}\n\nexport function isLogical(el: any): el is Logical {\n  return el instanceof Logical;\n}\n"]},"metadata":{},"sourceType":"module"}