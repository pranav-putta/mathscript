{"ast":null,"code":"import { SymbolError } from \"./errors\";\nimport { TokenType, newToken } from \"./token\";\nimport { isspace, isdigit, isalnum } from \"./util\";\n\n/**\n * Lexer tokenizes raw input into @class{Token} objects\n */\nexport class Lexer {\n  /**\n   * raw input text\n   */\n\n  /**\n   * current tokenizing position\n   */\n\n  /**\n   * current character at position\n   */\n  constructor(text) {\n    this.reserved_keywords = {\n      true: newToken(TokenType.id, \"true\"),\n      false: newToken(TokenType.id, \"false\")\n    };\n    this.text = void 0;\n    this.position = void 0;\n    this.current_char = void 0;\n    this.text = text;\n    this.position = -1;\n  }\n\n  _id() {\n    let result = \"\";\n\n    while (this.current_char && isalnum(this.current_char)) {\n      result += this.current_char;\n      let next = this.peek();\n\n      if (next && isalnum(next)) {\n        this.advance();\n      } else {\n        break;\n      }\n    }\n\n    return this.reserved_keywords[result] || {\n      type: TokenType.id,\n      value: result\n    };\n  }\n  /**\n   * increments position and updates current_char\n   * sets current_char to undefined if position is out of bounds\n   */\n\n\n  advance() {\n    this.position++;\n\n    if (this.position < this.text.length) {\n      this.current_char = this.text.charAt(this.position);\n    } else {\n      this.current_char = undefined;\n    }\n  }\n  /**\n   * retrieves next character without advancing position\n   * @param steps number of steps to take\n   */\n\n\n  peek(steps = 1) {\n    if (this.position + steps >= this.text.length) {\n      return undefined;\n    } else {\n      return this.text.charAt(this.position + steps);\n    }\n  }\n  /**\n   * retrieves the next token by ignoring whitespaces\n   */\n\n\n  peekToken() {\n    let pos = this.position + 1;\n\n    while (pos < this.text.length && isspace(this.text.charAt(pos))) {\n      pos += 1;\n    }\n\n    return this.text.charAt(pos);\n  }\n  /**\n   * skips all whitepsace in sequence\n   */\n\n\n  ignore_whitespace(advance = true) {\n    if (advance) {\n      // stop at next token\n      while (this.current_char && isspace(this.current_char)) {\n        this.advance();\n      }\n    } else {\n      // stop before next token\n      let current = this.peek();\n\n      while (current && isspace(current)) {\n        this.advance();\n      }\n    }\n  }\n  /**\n   * converts numeric character sequence into a token\n   */\n\n\n  tokenize_number() {\n    let result = this.current_char || \"\";\n    let next = this.peek(); // capture integer\n\n    while (next && isdigit(next)) {\n      this.advance();\n      result += this.current_char;\n      next = this.peek();\n    } // check if decimal point\n\n\n    if (next && next == \".\") {\n      let tmpNext = this.peek(2); // make sure next character is a digit, not an elipses or something like '1.'\n\n      if (tmpNext && isdigit(tmpNext)) {\n        this.advance();\n        result += this.current_char;\n        next = this.peek(); // append numbers after decimal point\n\n        while (next && isdigit(next)) {\n          this.advance();\n          result += this.current_char;\n          next = this.peek();\n        }\n      }\n    } // convert to number and return\n\n\n    return Number(result);\n  }\n  /**\n   * retrieves next token in string\n   */\n\n\n  next_token() {\n    this.advance();\n    let token = this.tokenize();\n    return token;\n  }\n  /**\n   * compares characters and matches with associated token\n   */\n\n\n  tokenize() {\n    // ignore all spaces\n    if (this.current_char && isspace(this.current_char)) {\n      this.ignore_whitespace();\n    } // check if no more characters\n\n\n    if (!this.current_char) {\n      return {\n        type: TokenType.eof,\n        value: \"eof\"\n      };\n    }\n\n    if (isdigit(this.current_char)) {\n      // capture numeric token\n      return {\n        type: TokenType.num,\n        value: this.tokenize_number()\n      };\n    } else if (isalnum(this.current_char)) {\n      return this._id();\n    } else if (this.current_char == \"+\") {\n      return newToken(TokenType.plus);\n    } else if (this.current_char == \"-\") {\n      return newToken(TokenType.minus);\n    } else if (this.current_char == \"*\") {\n      return newToken(TokenType.mul);\n    } else if (this.current_char == \"/\") {\n      // check if token is rdiv\n      let next = this.peek();\n\n      if (next && next == \"/\") {\n        this.advance();\n        return newToken(TokenType.div);\n      }\n\n      return newToken(TokenType.rdiv);\n    } else if (this.current_char == \"(\") {\n      return newToken(TokenType.lparen);\n    } else if (this.current_char == \")\") {\n      return newToken(TokenType.rparen);\n    } else if (this.current_char == \"[\") {\n      return newToken(TokenType.lbracket);\n    } else if (this.current_char == \"]\") {\n      return newToken(TokenType.rbracket);\n    } else if (this.current_char == \"<\") {\n      return newToken(TokenType.larrow);\n    } else if (this.current_char == \">\") {\n      return newToken(TokenType.rarrow);\n    } else if (this.current_char == \";\") {\n      return newToken(TokenType.semicolon);\n    } else if (this.current_char == \",\") {\n      return newToken(TokenType.comma);\n    } else if (this.current_char == \"|\") {\n      return newToken(TokenType.bar);\n    } else if (this.current_char == \"=\" && this.peek() != \"=\") {\n      return newToken(TokenType.assign);\n    } else if (this.current_char == \".\" && this.peek() != \".\") {\n      return newToken(TokenType.dot);\n    } else if (this.current_char == \"\\n\") {\n      return newToken(TokenType.endl);\n    } else if (this.current_char == \"^\") {\n      return newToken(TokenType.pow);\n    } // token wasn't recognized\n\n\n    throw new SymbolError(\"unexpected token: `\" + this.current_char + \"`\");\n  }\n\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/lexer.ts"],"names":["SymbolError","TokenType","newToken","isspace","isdigit","isalnum","Lexer","constructor","text","reserved_keywords","true","id","false","position","current_char","_id","result","next","peek","advance","type","value","length","charAt","undefined","steps","peekToken","pos","ignore_whitespace","current","tokenize_number","tmpNext","Number","next_token","token","tokenize","eof","num","plus","minus","mul","div","rdiv","lparen","rparen","lbracket","rbracket","larrow","rarrow","semicolon","comma","bar","assign","dot","endl","pow"],"mappings":"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","sourcesContent":["import { SymbolError } from \"./errors\";\nimport { Token, TokenType, SymbolToken, newToken } from \"./token\";\nimport { isspace, isdigit, isalnum } from \"./util\";\n\ninterface Keywords {\n  [key: string]: Token;\n}\n\n/**\n * Lexer tokenizes raw input into @class{Token} objects\n */\nexport class Lexer {\n  private readonly reserved_keywords: Keywords = {\n    true: newToken(TokenType.id, \"true\"),\n    false: newToken(TokenType.id, \"false\"),\n  };\n  /**\n   * raw input text\n   */\n  private text: string;\n  /**\n   * current tokenizing position\n   */\n  private position: number;\n  /**\n   * current character at position\n   */\n  private current_char: string | undefined;\n\n  constructor(text: string) {\n    this.text = text;\n    this.position = -1;\n  }\n\n  private _id(): Token {\n    let result = \"\";\n    while (this.current_char && isalnum(this.current_char)) {\n      result += this.current_char;\n      let next = this.peek();\n      if (next && isalnum(next)) {\n        this.advance();\n      } else {\n        break;\n      }\n    }\n    return (\n      this.reserved_keywords[result] || { type: TokenType.id, value: result }\n    );\n  }\n\n  /**\n   * increments position and updates current_char\n   * sets current_char to undefined if position is out of bounds\n   */\n  private advance() {\n    this.position++;\n\n    if (this.position < this.text.length) {\n      this.current_char = this.text.charAt(this.position);\n    } else {\n      this.current_char = undefined;\n    }\n  }\n\n  /**\n   * retrieves next character without advancing position\n   * @param steps number of steps to take\n   */\n  public peek(steps: number = 1): string | undefined {\n    if (this.position + steps >= this.text.length) {\n      return undefined;\n    } else {\n      return this.text.charAt(this.position + steps);\n    }\n  }\n\n  /**\n   * retrieves the next token by ignoring whitespaces\n   */\n  public peekToken(): string {\n    let pos = this.position + 1;\n    while (pos < this.text.length && isspace(this.text.charAt(pos))) {\n      pos += 1;\n    }\n    return this.text.charAt(pos);\n  }\n\n  /**\n   * skips all whitepsace in sequence\n   */\n  private ignore_whitespace(advance: boolean = true) {\n    if (advance) {\n      // stop at next token\n      while (this.current_char && isspace(this.current_char)) {\n        this.advance();\n      }\n    } else {\n      // stop before next token\n      let current = this.peek();\n      while (current && isspace(current)) {\n        this.advance();\n      }\n    }\n  }\n\n  /**\n   * converts numeric character sequence into a token\n   */\n  private tokenize_number(): number {\n    let result = this.current_char || \"\";\n    let next = this.peek();\n    // capture integer\n    while (next && isdigit(next)) {\n      this.advance();\n      result += this.current_char;\n      next = this.peek();\n    }\n\n    // check if decimal point\n    if (next && next == \".\") {\n      let tmpNext = this.peek(2);\n      // make sure next character is a digit, not an elipses or something like '1.'\n      if (tmpNext && isdigit(tmpNext)) {\n        this.advance();\n        result += this.current_char;\n        next = this.peek();\n\n        // append numbers after decimal point\n        while (next && isdigit(next)) {\n          this.advance();\n          result += this.current_char;\n          next = this.peek();\n        }\n      }\n    }\n\n    // convert to number and return\n    return Number(result);\n  }\n\n  /**\n   * retrieves next token in string\n   */\n  public next_token(): Token {\n    this.advance();\n    let token = this.tokenize();\n    return token;\n  }\n\n  /**\n   * compares characters and matches with associated token\n   */\n  private tokenize(): Token {\n    // ignore all spaces\n    if (this.current_char && isspace(this.current_char)) {\n      this.ignore_whitespace();\n    }\n\n    // check if no more characters\n    if (!this.current_char) {\n      return { type: TokenType.eof, value: \"eof\" };\n    }\n\n    if (isdigit(this.current_char)) {\n      // capture numeric token\n      return { type: TokenType.num, value: this.tokenize_number() };\n    } else if (isalnum(this.current_char)) {\n      return this._id();\n    } else if (this.current_char == \"+\") {\n      return newToken(TokenType.plus);\n    } else if (this.current_char == \"-\") {\n      return newToken(TokenType.minus);\n    } else if (this.current_char == \"*\") {\n      return newToken(TokenType.mul);\n    } else if (this.current_char == \"/\") {\n      // check if token is rdiv\n      let next = this.peek();\n      if (next && next == \"/\") {\n        this.advance();\n        return newToken(TokenType.div);\n      }\n      return newToken(TokenType.rdiv);\n    } else if (this.current_char == \"(\") {\n      return newToken(TokenType.lparen);\n    } else if (this.current_char == \")\") {\n      return newToken(TokenType.rparen);\n    } else if (this.current_char == \"[\") {\n      return newToken(TokenType.lbracket);\n    } else if (this.current_char == \"]\") {\n      return newToken(TokenType.rbracket);\n    } else if (this.current_char == \"<\") {\n      return newToken(TokenType.larrow);\n    } else if (this.current_char == \">\") {\n      return newToken(TokenType.rarrow);\n    } else if (this.current_char == \";\") {\n      return newToken(TokenType.semicolon);\n    } else if (this.current_char == \",\") {\n      return newToken(TokenType.comma);\n    } else if (this.current_char == \"|\") {\n      return newToken(TokenType.bar);\n    } else if (this.current_char == \"=\" && this.peek() != \"=\") {\n      return newToken(TokenType.assign);\n    } else if (this.current_char == \".\" && this.peek() != \".\") {\n      return newToken(TokenType.dot);\n    } else if (this.current_char == \"\\n\") {\n      return newToken(TokenType.endl);\n    } else if (this.current_char == \"^\") {\n      return newToken(TokenType.pow);\n    }\n\n    // token wasn't recognized\n    throw new SymbolError(\"unexpected token: `\" + this.current_char + \"`\");\n  }\n}\n"]},"metadata":{},"sourceType":"module"}