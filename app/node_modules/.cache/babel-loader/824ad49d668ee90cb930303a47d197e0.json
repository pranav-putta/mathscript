{"ast":null,"code":"import { global_functions, global_scope } from \"./global\";\nimport { AComputable } from \"./computable\";\nimport { ArithmeticError, MatrixError, SymbolError, UndeclaredVariableError } from \"./errors\";\nimport { TokenType } from \"./token\";\nimport { Queue } from \"./util\";\n/**\n * abstract syntax tree base class\n */\n\nexport class AbstractSyntaxTree {}\n/**\n * compound statements go here\n */\n\nexport class CompoundNode extends AbstractSyntaxTree {\n  constructor() {\n    super();\n    this.children = void 0;\n    this.children = [];\n  }\n\n  eval() {\n    let results = [];\n\n    for (let child of this.children) {\n      let val = child.eval();\n      results.push(val);\n    }\n\n    return results;\n  }\n\n  get _children() {\n    return this.children;\n  }\n\n  get _node_value_string() {\n    return \"compound\";\n  }\n\n}\n/**\n * assigns a variable to its value\n */\n\nexport class AssignNode extends AbstractSyntaxTree {\n  constructor(left, token, right) {\n    super();\n    this.left = void 0;\n    this.token = void 0;\n    this.right = void 0;\n    this.left = left;\n    this.token = token;\n    this.right = right;\n  }\n\n  eval() {\n    let name = this.left.value;\n    let val = this.right.eval();\n    global_scope[name] = val;\n    return val;\n    console.log(`${name} = ${global_scope[name]}`);\n  }\n\n  get _children() {\n    return [this.left, this.right];\n  }\n\n  get _node_value_string() {\n    return \"=\";\n  }\n\n}\n/**\n * computes a procedure\n */\n\nexport class ProcedureNode extends AbstractSyntaxTree {\n  constructor(token, args) {\n    super();\n    this.token = void 0;\n    this.name = void 0;\n    this.args = void 0;\n    this.token = token;\n    this.name = token.value;\n    this.args = args;\n  }\n\n  eval() {\n    let func = global_functions[this.name];\n    let result = func.apply(this, this.args);\n    console.log(result);\n    return result;\n  }\n\n  get _children() {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  get _node_value_string() {\n    throw new Error(\"Method not implemented.\");\n  }\n\n}\n/**\n * empty node, doesn't do anything\n */\n\nexport class EmptyNode extends AbstractSyntaxTree {\n  eval() {\n    return;\n  }\n\n  get _children() {\n    return [];\n  }\n\n  get _node_value_string() {\n    return \"empty node\";\n  }\n\n}\nexport class ComputableNode extends AbstractSyntaxTree {}\n/**\n * binary operator node\n * takes a (left, operator, right)\n */\n\nexport class BinaryOperatorNode extends ComputableNode {\n  /**\n   * left node in binary operation\n   */\n\n  /**\n   * right node in binary operation\n   */\n\n  /**\n   * operator\n   */\n  constructor(left, operator, right) {\n    super();\n    this.left = void 0;\n    this.right = void 0;\n    this.operator = void 0;\n    this.left = left;\n    this.right = right;\n    this.operator = operator;\n  } // TODO: simplify commutative process\n\n\n  eval() {\n    var _result, _result3, _result4;\n\n    let l = this.left.eval();\n    let r = this.right.eval();\n    let result;\n\n    if (AComputable.isComputable(l) && AComputable.isComputable(r)) {\n      if (this.operator.type == TokenType.plus) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = {\n            result: l + r\n          };\n        } else if (AComputable.isMatrix(l) && (AComputable.isNumeric(r) || AComputable.isMatrix(r))) {\n          result = l.add(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          result = r.add(l);\n        }\n      } else if (this.operator.type == TokenType.minus) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = {\n            result: l - r\n          };\n        } else if (AComputable.isMatrix(l) && (AComputable.isNumeric(r) || AComputable.isMatrix(r))) {\n          result = l.sub(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          let tmp = r.mul(-1).result;\n\n          if (AComputable.isMatrix(tmp)) {\n            result = tmp.add(r);\n          } else {\n            throw new MatrixError(\"ummm... something went wrong\");\n          }\n        }\n      } else if (this.operator.type == TokenType.mul) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = {\n            result: l * r\n          };\n        } else if (AComputable.isMatrix(l) && (AComputable.isNumeric(r) || AComputable.isMatrix(r))) {\n          result = l.mul(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          result = r.mul(l);\n        }\n      } else if (this.operator.type == TokenType.div) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = {\n            result: l / r\n          };\n        } else if (AComputable.isMatrix(l) && (AComputable.isNumeric(r) || AComputable.isMatrix(r))) {\n          result = l.div(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          result = r.div(l);\n        }\n      } else if (this.operator.type == TokenType.rdiv) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = {\n            result: Math.floor(l / r)\n          };\n        } else if (AComputable.isMatrix(l) && (AComputable.isNumeric(r) || AComputable.isMatrix(r))) {\n          result = l.rdiv(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          result = r.rdiv(l);\n        }\n      } else if (this.operator.type == TokenType.pow) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = {\n            result: Math.pow(l, r)\n          };\n        } else if (AComputable.isMatrix(l) && (AComputable.isNumeric(r) || AComputable.isMatrix(r))) {\n          result = l.pow(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          result = r.pow(l);\n        }\n      }\n    }\n\n    if ((_result = result) === null || _result === void 0 ? void 0 : _result.message) {\n      var _result2;\n\n      console.log((_result2 = result) === null || _result2 === void 0 ? void 0 : _result2.message);\n    }\n\n    console.log((_result3 = result) === null || _result3 === void 0 ? void 0 : _result3.result.toString());\n    return (_result4 = result) === null || _result4 === void 0 ? void 0 : _result4.result;\n  }\n\n  get _children() {\n    return [this.left, this.right];\n  }\n\n  get _node_value_string() {\n    return this.operator.type.toString();\n  }\n\n}\n/**\n * holds a variable and its value\n */\n\nexport class VariableNode extends ComputableNode {\n  get value() {\n    return this._value;\n  }\n\n  constructor(token) {\n    super();\n    this.token = void 0;\n    this._value = void 0;\n    this.token = token;\n    this._value = token.value;\n  }\n\n  eval() {\n    let name = this.value;\n    let val = global_scope[name];\n\n    if (val) {\n      console.log(`${name} = ${val}`);\n      return val;\n    } else {\n      throw new UndeclaredVariableError(`${name} was not declared!`);\n    }\n  }\n\n  get _children() {\n    return [];\n  }\n\n  get _node_value_string() {\n    throw new Error(\"Method not implemented.\");\n  }\n\n}\n/**\n * stores a single value: number or matrix\n */\n\nexport class SingleValueNode extends ComputableNode {\n  constructor(value) {\n    super();\n    this.value = void 0;\n    this.value = value;\n  }\n\n  eval() {\n    if (AComputable.isNumeric(this.value)) {\n      return this.value;\n    } else if (AComputable.isMatrix(this.value)) {\n      this.value.evaluate();\n      return this.value;\n    } else {\n      throw new SyntaxError(\"invalid single value node!\");\n    }\n  }\n\n  get _children() {\n    return [];\n  }\n\n  get _node_value_string() {\n    return this.value.toString();\n  }\n\n}\n/**\n * holds a unary operator\n */\n\nexport class UnaryOperatorNode extends ComputableNode {\n  constructor(token, next) {\n    super();\n    this.token = void 0;\n    this.next = void 0;\n    this.token = token;\n    this.next = next;\n  }\n\n  eval() {\n    if (this.token.type == TokenType.plus) {\n      // return next element as is\n      return this.next.eval();\n    } else if (this.token.type == TokenType.minus) {\n      // take negation of next element\n      let out = this.next.eval();\n\n      if (AComputable.isNumeric(out)) {\n        return -1 * out;\n      } else if (AComputable.isMatrix(out)) {\n        return out.mul(-1).result;\n      } else {\n        throw new ArithmeticError(\"couldn't evaluate negation of item\");\n      }\n    } else {\n      throw new SymbolError(\"unexpected unary operator: \" + this.token.type.toString());\n    }\n  }\n\n  get _children() {\n    return [this.next];\n  }\n\n  get _node_value_string() {\n    return this.token.type.toString();\n  }\n\n}\nexport class util {\n  printTreeLevelOrder(tree) {\n    let queue = new Queue();\n    let currentLevel = 0;\n    let str = \"\";\n    let arrows = \"\";\n    let space = \" \";\n    let extraspace = \"  \"; // initialize first element\n\n    let node = {\n      node: tree,\n      level: currentLevel,\n      strLength: 0\n    }; // continue until node is null\n\n    while (node) {\n      if (node.level > currentLevel) {\n        process.stdout.write(str);\n        process.stdout.write(\"\\n\" + arrows + \"\\n\");\n        str = \"\";\n        arrows = \"\";\n        currentLevel = node.level;\n      }\n\n      let children = node.node._children;\n\n      switch (children.length) {\n        case 0:\n          arrows += \"   \";\n          break;\n\n        case 1:\n          while (arrows.length < node.strLength) {\n            arrows += \" \";\n          }\n\n          arrows += \"|\" + space;\n          break;\n\n        case 2:\n          while (arrows.length < node.strLength) {\n            arrows += \" \";\n          }\n\n          arrows += \"|\" + space + \"\\\\\" + extraspace;\n          break;\n      }\n\n      while (str.length < ((_node = node) === null || _node === void 0 ? void 0 : _node.strLength)) {\n        var _node;\n\n        str += \" \";\n      }\n\n      for (let x of children) {\n        queue.push({\n          node: x,\n          level: node.level + 1,\n          strLength: str.length\n        });\n      }\n\n      str += node.node._node_value_string + extraspace; // dequeue next element\n\n      node = queue.pop();\n    }\n\n    process.stdout.write(str);\n    process.stdout.write(\"\\n\");\n  }\n\n}\nexport function isComputableNode(node) {\n  return node instanceof ComputableNode;\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/ast.ts"],"names":["global_functions","global_scope","AComputable","ArithmeticError","MatrixError","SymbolError","UndeclaredVariableError","TokenType","Queue","AbstractSyntaxTree","CompoundNode","constructor","children","eval","results","child","val","push","_children","_node_value_string","AssignNode","left","token","right","name","value","console","log","ProcedureNode","args","func","result","apply","Error","EmptyNode","ComputableNode","BinaryOperatorNode","operator","l","r","isComputable","type","plus","isNumeric","isMatrix","add","minus","sub","tmp","mul","div","rdiv","Math","floor","pow","message","toString","VariableNode","_value","SingleValueNode","evaluate","SyntaxError","UnaryOperatorNode","next","out","util","printTreeLevelOrder","tree","queue","currentLevel","str","arrows","space","extraspace","node","level","strLength","process","stdout","write","length","x","pop","isComputableNode"],"mappings":"AAAA,SAASA,gBAAT,EAA2BC,YAA3B,QAA+C,UAA/C;AACA,SAASC,WAAT,QAAgD,cAAhD;AACA,SACEC,eADF,EAEEC,WAFF,EAGEC,WAHF,EAIEC,uBAJF,QAKO,UALP;AAMA,SAAyCC,SAAzC,QAA0D,SAA1D;AACA,SAASC,KAAT,QAAsB,QAAtB;AAEA;;;;AAGA,OAAO,MAAeC,kBAAf,CAAkC;AAkBzC;;;;AAGA,OAAO,MAAMC,YAAN,SAA2BD,kBAA3B,CAA8C;AAGnDE,EAAAA,WAAW,GAAG;AACZ;AADY,SAFNC,QAEM;AAEZ,SAAKA,QAAL,GAAgB,EAAhB;AACD;;AAEDC,EAAAA,IAAI,GAAG;AACL,QAAIC,OAAO,GAAG,EAAd;;AACA,SAAK,IAAIC,KAAT,IAAkB,KAAKH,QAAvB,EAAiC;AAC/B,UAAII,GAAG,GAAGD,KAAK,CAACF,IAAN,EAAV;AACAC,MAAAA,OAAO,CAACG,IAAR,CAAaD,GAAb;AACD;;AACD,WAAOF,OAAP;AACD;;AACD,MAAII,SAAJ,GAAsC;AACpC,WAAO,KAAKN,QAAZ;AACD;;AACD,MAAIO,kBAAJ,GAAiC;AAC/B,WAAO,UAAP;AACD;;AArBkD;AAwBrD;;;;AAGA,OAAO,MAAMC,UAAN,SAAyBX,kBAAzB,CAA4C;AAKjDE,EAAAA,WAAW,CAACU,IAAD,EAAqBC,KAArB,EAAmCC,KAAnC,EAA+C;AACxD;AADwD,SAJlDF,IAIkD;AAAA,SAHlDC,KAGkD;AAAA,SAFlDC,KAEkD;AAExD,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,KAAL,GAAaA,KAAb;AACD;;AACDV,EAAAA,IAAI,GAAG;AACL,QAAIW,IAAI,GAAG,KAAKH,IAAL,CAAUI,KAArB;AACA,QAAIT,GAAG,GAAG,KAAKO,KAAL,CAAWV,IAAX,EAAV;AACAZ,IAAAA,YAAY,CAACuB,IAAD,CAAZ,GAAqBR,GAArB;AACA,WAAOA,GAAP;AACAU,IAAAA,OAAO,CAACC,GAAR,CAAa,GAAEH,IAAK,MAAKvB,YAAY,CAACuB,IAAD,CAAO,EAA5C;AACD;;AACD,MAAIN,SAAJ,GAAsC;AACpC,WAAO,CAAC,KAAKG,IAAN,EAAY,KAAKE,KAAjB,CAAP;AACD;;AACD,MAAIJ,kBAAJ,GAAiC;AAC/B,WAAO,GAAP;AACD;;AAvBgD;AA0BnD;;;;AAGA,OAAO,MAAMS,aAAN,SAA4BnB,kBAA5B,CAA+C;AAKpDE,EAAAA,WAAW,CAACW,KAAD,EAAqBO,IAArB,EAAkC;AAC3C;AAD2C,SAJrCP,KAIqC;AAAA,SAHrCE,IAGqC;AAAA,SAFrCK,IAEqC;AAE3C,SAAKP,KAAL,GAAaA,KAAb;AACA,SAAKE,IAAL,GAAYF,KAAK,CAACG,KAAlB;AACA,SAAKI,IAAL,GAAYA,IAAZ;AACD;;AAEDhB,EAAAA,IAAI,GAAG;AACL,QAAIiB,IAAI,GAAG9B,gBAAgB,CAAC,KAAKwB,IAAN,CAA3B;AACA,QAAIO,MAAM,GAAGD,IAAI,CAACE,KAAL,CAAW,IAAX,EAAiB,KAAKH,IAAtB,CAAb;AACAH,IAAAA,OAAO,CAACC,GAAR,CAAYI,MAAZ;AACA,WAAOA,MAAP;AACD;;AACD,MAAIb,SAAJ,GAAsC;AACpC,UAAM,IAAIe,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACD,MAAId,kBAAJ,GAAiC;AAC/B,UAAM,IAAIc,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAvBmD;AA0BtD;;;;AAGA,OAAO,MAAMC,SAAN,SAAwBzB,kBAAxB,CAA2C;AAChDI,EAAAA,IAAI,GAAG;AACL;AACD;;AACD,MAAIK,SAAJ,GAAsC;AACpC,WAAO,EAAP;AACD;;AACD,MAAIC,kBAAJ,GAAiC;AAC/B,WAAO,YAAP;AACD;;AAT+C;AAYlD,OAAO,MAAegB,cAAf,SAAsC1B,kBAAtC,CAAyD;AAIhE;;;;;AAIA,OAAO,MAAM2B,kBAAN,SAAiCD,cAAjC,CAAgD;AACrD;;;;AAIA;;;;AAIA;;;AAKAxB,EAAAA,WAAW,CAACU,IAAD,EAAYgB,QAAZ,EAA6Bd,KAA7B,EAAyC;AAClD;AADkD,SAV5CF,IAU4C;AAAA,SAN5CE,KAM4C;AAAA,SAF5Cc,QAE4C;AAElD,SAAKhB,IAAL,GAAYA,IAAZ;AACA,SAAKE,KAAL,GAAaA,KAAb;AACA,SAAKc,QAAL,GAAgBA,QAAhB;AACD,GAnBoD,CAqBrD;;;AACOxB,EAAAA,IAAP,GAAmB;AAAA;;AACjB,QAAIyB,CAAC,GAAG,KAAKjB,IAAL,CAAUR,IAAV,EAAR;AACA,QAAI0B,CAAC,GAAG,KAAKhB,KAAL,CAAWV,IAAX,EAAR;AACA,QAAIkB,MAAJ;;AAEA,QAAI7B,WAAW,CAACsC,YAAZ,CAAyBF,CAAzB,KAA+BpC,WAAW,CAACsC,YAAZ,CAAyBD,CAAzB,CAAnC,EAAgE;AAC9D,UAAI,KAAKF,QAAL,CAAcI,IAAd,IAAsBlC,SAAS,CAACmC,IAApC,EAA0C;AACxC,YAAIxC,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,CAAhC,EAA0D;AACxDR,UAAAA,MAAM,GAAG;AAAEA,YAAAA,MAAM,EAAEO,CAAC,GAAGC;AAAd,WAAT;AACD,SAFD,MAEO,IACLrC,WAAW,CAAC0C,QAAZ,CAAqBN,CAArB,MACCpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,KAA4BrC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAD7B,CADK,EAGL;AACAR,UAAAA,MAAM,GAAGO,CAAC,CAACO,GAAF,CAAMN,CAAN,CAAT;AACD,SALM,MAKA,IAAIrC,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAAhC,EAAyD;AAC9DR,UAAAA,MAAM,GAAGQ,CAAC,CAACM,GAAF,CAAMP,CAAN,CAAT;AACD;AACF,OAXD,MAWO,IAAI,KAAKD,QAAL,CAAcI,IAAd,IAAsBlC,SAAS,CAACuC,KAApC,EAA2C;AAChD,YAAI5C,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,CAAhC,EAA0D;AACxDR,UAAAA,MAAM,GAAG;AAAEA,YAAAA,MAAM,EAAEO,CAAC,GAAGC;AAAd,WAAT;AACD,SAFD,MAEO,IACLrC,WAAW,CAAC0C,QAAZ,CAAqBN,CAArB,MACCpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,KAA4BrC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAD7B,CADK,EAGL;AACAR,UAAAA,MAAM,GAAGO,CAAC,CAACS,GAAF,CAAMR,CAAN,CAAT;AACD,SALM,MAKA,IAAIrC,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAAhC,EAAyD;AAC9D,cAAIS,GAAG,GAAGT,CAAC,CAACU,GAAF,CAAM,CAAC,CAAP,EAAUlB,MAApB;;AACA,cAAI7B,WAAW,CAAC0C,QAAZ,CAAqBI,GAArB,CAAJ,EAA+B;AAC7BjB,YAAAA,MAAM,GAAGiB,GAAG,CAACH,GAAJ,CAAQN,CAAR,CAAT;AACD,WAFD,MAEO;AACL,kBAAM,IAAInC,WAAJ,CAAgB,8BAAhB,CAAN;AACD;AACF;AACF,OAhBM,MAgBA,IAAI,KAAKiC,QAAL,CAAcI,IAAd,IAAsBlC,SAAS,CAAC0C,GAApC,EAAyC;AAC9C,YAAI/C,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,CAAhC,EAA0D;AACxDR,UAAAA,MAAM,GAAG;AAAEA,YAAAA,MAAM,EAAEO,CAAC,GAAGC;AAAd,WAAT;AACD,SAFD,MAEO,IACLrC,WAAW,CAAC0C,QAAZ,CAAqBN,CAArB,MACCpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,KAA4BrC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAD7B,CADK,EAGL;AACAR,UAAAA,MAAM,GAAGO,CAAC,CAACW,GAAF,CAAMV,CAAN,CAAT;AACD,SALM,MAKA,IAAIrC,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAAhC,EAAyD;AAC9DR,UAAAA,MAAM,GAAGQ,CAAC,CAACU,GAAF,CAAMX,CAAN,CAAT;AACD;AACF,OAXM,MAWA,IAAI,KAAKD,QAAL,CAAcI,IAAd,IAAsBlC,SAAS,CAAC2C,GAApC,EAAyC;AAC9C,YAAIhD,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,CAAhC,EAA0D;AACxDR,UAAAA,MAAM,GAAG;AAAEA,YAAAA,MAAM,EAAEO,CAAC,GAAGC;AAAd,WAAT;AACD,SAFD,MAEO,IACLrC,WAAW,CAAC0C,QAAZ,CAAqBN,CAArB,MACCpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,KAA4BrC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAD7B,CADK,EAGL;AACAR,UAAAA,MAAM,GAAGO,CAAC,CAACY,GAAF,CAAMX,CAAN,CAAT;AACD,SALM,MAKA,IAAIrC,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAAhC,EAAyD;AAC9DR,UAAAA,MAAM,GAAGQ,CAAC,CAACW,GAAF,CAAMZ,CAAN,CAAT;AACD;AACF,OAXM,MAWA,IAAI,KAAKD,QAAL,CAAcI,IAAd,IAAsBlC,SAAS,CAAC4C,IAApC,EAA0C;AAC/C,YAAIjD,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,CAAhC,EAA0D;AACxDR,UAAAA,MAAM,GAAG;AAAEA,YAAAA,MAAM,EAAEqB,IAAI,CAACC,KAAL,CAAWf,CAAC,GAAGC,CAAf;AAAV,WAAT;AACD,SAFD,MAEO,IACLrC,WAAW,CAAC0C,QAAZ,CAAqBN,CAArB,MACCpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,KAA4BrC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAD7B,CADK,EAGL;AACAR,UAAAA,MAAM,GAAGO,CAAC,CAACa,IAAF,CAAOZ,CAAP,CAAT;AACD,SALM,MAKA,IAAIrC,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAAhC,EAAyD;AAC9DR,UAAAA,MAAM,GAAGQ,CAAC,CAACY,IAAF,CAAOb,CAAP,CAAT;AACD;AACF,OAXM,MAWA,IAAI,KAAKD,QAAL,CAAcI,IAAd,IAAsBlC,SAAS,CAAC+C,GAApC,EAAyC;AAC9C,YAAIpD,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,CAAhC,EAA0D;AACxDR,UAAAA,MAAM,GAAG;AAAEA,YAAAA,MAAM,EAAEqB,IAAI,CAACE,GAAL,CAAShB,CAAT,EAAYC,CAAZ;AAAV,WAAT;AACD,SAFD,MAEO,IACLrC,WAAW,CAAC0C,QAAZ,CAAqBN,CAArB,MACCpC,WAAW,CAACyC,SAAZ,CAAsBJ,CAAtB,KAA4BrC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAD7B,CADK,EAGL;AACAR,UAAAA,MAAM,GAAGO,CAAC,CAACgB,GAAF,CAAMf,CAAN,CAAT;AACD,SALM,MAKA,IAAIrC,WAAW,CAACyC,SAAZ,CAAsBL,CAAtB,KAA4BpC,WAAW,CAAC0C,QAAZ,CAAqBL,CAArB,CAAhC,EAAyD;AAC9DR,UAAAA,MAAM,GAAGQ,CAAC,CAACe,GAAF,CAAMhB,CAAN,CAAT;AACD;AACF;AACF;;AAED,mBAAIP,MAAJ,4CAAI,QAAQwB,OAAZ,EAAqB;AAAA;;AACnB7B,MAAAA,OAAO,CAACC,GAAR,aAAYI,MAAZ,6CAAY,SAAQwB,OAApB;AACD;;AACD7B,IAAAA,OAAO,CAACC,GAAR,aAAYI,MAAZ,6CAAY,SAAQA,MAAR,CAAeyB,QAAf,EAAZ;AACA,uBAAOzB,MAAP,6CAAO,SAAQA,MAAf;AACD;;AAED,MAAWb,SAAX,GAA8B;AAC5B,WAAO,CAAC,KAAKG,IAAN,EAAY,KAAKE,KAAjB,CAAP;AACD;;AAED,MAAWJ,kBAAX,GAAwC;AACtC,WAAO,KAAKkB,QAAL,CAAcI,IAAd,CAAmBe,QAAnB,EAAP;AACD;;AAnHoD;AAsHvD;;;;AAGA,OAAO,MAAMC,YAAN,SAA2BtB,cAA3B,CAA0C;AAI/C,MAAWV,KAAX,GAA2B;AACzB,WAAO,KAAKiC,MAAZ;AACD;;AAED/C,EAAAA,WAAW,CAACW,KAAD,EAAqB;AAC9B;AAD8B,SAPxBA,KAOwB;AAAA,SANxBoC,MAMwB;AAE9B,SAAKpC,KAAL,GAAaA,KAAb;AACA,SAAKoC,MAAL,GAAcpC,KAAK,CAACG,KAApB;AACD;;AACDZ,EAAAA,IAAI,GAAG;AACL,QAAIW,IAAI,GAAG,KAAKC,KAAhB;AACA,QAAIT,GAAG,GAAGf,YAAY,CAACuB,IAAD,CAAtB;;AACA,QAAIR,GAAJ,EAAS;AACPU,MAAAA,OAAO,CAACC,GAAR,CAAa,GAAEH,IAAK,MAAKR,GAAI,EAA7B;AACA,aAAOA,GAAP;AACD,KAHD,MAGO;AACL,YAAM,IAAIV,uBAAJ,CAA6B,GAAEkB,IAAK,oBAApC,CAAN;AACD;AACF;;AACD,MAAIN,SAAJ,GAAsC;AACpC,WAAO,EAAP;AACD;;AACD,MAAIC,kBAAJ,GAAiC;AAC/B,UAAM,IAAIc,KAAJ,CAAU,yBAAV,CAAN;AACD;;AA5B8C;AA+BjD;;;;AAGA,OAAO,MAAM0B,eAAN,SAA8BxB,cAA9B,CAA6C;AAGlDxB,EAAAA,WAAW,CAACc,KAAD,EAAoB;AAC7B;AAD6B,SAFvBA,KAEuB;AAE7B,SAAKA,KAAL,GAAaA,KAAb;AACD;;AAEMZ,EAAAA,IAAP,GAA0B;AACxB,QAAIX,WAAW,CAACyC,SAAZ,CAAsB,KAAKlB,KAA3B,CAAJ,EAAuC;AACrC,aAAO,KAAKA,KAAZ;AACD,KAFD,MAEO,IAAIvB,WAAW,CAAC0C,QAAZ,CAAqB,KAAKnB,KAA1B,CAAJ,EAAsC;AAC3C,WAAKA,KAAL,CAAWmC,QAAX;AACA,aAAO,KAAKnC,KAAZ;AACD,KAHM,MAGA;AACL,YAAM,IAAIoC,WAAJ,CAAgB,4BAAhB,CAAN;AACD;AACF;;AAED,MAAW3C,SAAX,GAA8B;AAC5B,WAAO,EAAP;AACD;;AAED,MAAWC,kBAAX,GAAwC;AACtC,WAAO,KAAKM,KAAL,CAAW+B,QAAX,EAAP;AACD;;AAzBiD;AA4BpD;;;;AAGA,OAAO,MAAMM,iBAAN,SAAgC3B,cAAhC,CAA+C;AAIpDxB,EAAAA,WAAW,CAACW,KAAD,EAAeyC,IAAf,EAAqC;AAC9C;AAD8C,SAHxCzC,KAGwC;AAAA,SAFxCyC,IAEwC;AAE9C,SAAKzC,KAAL,GAAaA,KAAb;AACA,SAAKyC,IAAL,GAAYA,IAAZ;AACD;;AAEMlD,EAAAA,IAAP,GAA0B;AACxB,QAAI,KAAKS,KAAL,CAAWmB,IAAX,IAAmBlC,SAAS,CAACmC,IAAjC,EAAuC;AACrC;AACA,aAAO,KAAKqB,IAAL,CAAUlD,IAAV,EAAP;AACD,KAHD,MAGO,IAAI,KAAKS,KAAL,CAAWmB,IAAX,IAAmBlC,SAAS,CAACuC,KAAjC,EAAwC;AAC7C;AACA,UAAIkB,GAAG,GAAG,KAAKD,IAAL,CAAUlD,IAAV,EAAV;;AACA,UAAIX,WAAW,CAACyC,SAAZ,CAAsBqB,GAAtB,CAAJ,EAAgC;AAC9B,eAAO,CAAC,CAAD,GAAKA,GAAZ;AACD,OAFD,MAEO,IAAI9D,WAAW,CAAC0C,QAAZ,CAAqBoB,GAArB,CAAJ,EAA+B;AACpC,eAAOA,GAAG,CAACf,GAAJ,CAAQ,CAAC,CAAT,EAAYlB,MAAnB;AACD,OAFM,MAEA;AACL,cAAM,IAAI5B,eAAJ,CAAoB,oCAApB,CAAN;AACD;AACF,KAVM,MAUA;AACL,YAAM,IAAIE,WAAJ,CACJ,gCAAgC,KAAKiB,KAAL,CAAWmB,IAAX,CAAgBe,QAAhB,EAD5B,CAAN;AAGD;AACF;;AAED,MAAWtC,SAAX,GAA8B;AAC5B,WAAO,CAAC,KAAK6C,IAAN,CAAP;AACD;;AAED,MAAW5C,kBAAX,GAAwC;AACtC,WAAO,KAAKG,KAAL,CAAWmB,IAAX,CAAgBe,QAAhB,EAAP;AACD;;AArCmD;AA8CtD,OAAO,MAAMS,IAAN,CAAW;AAChBC,EAAAA,mBAAmB,CAACC,IAAD,EAAY;AAC7B,QAAIC,KAAuB,GAAG,IAAI5D,KAAJ,EAA9B;AACA,QAAI6D,YAAoB,GAAG,CAA3B;AACA,QAAIC,GAAG,GAAG,EAAV;AACA,QAAIC,MAAc,GAAG,EAArB;AACA,QAAIC,KAAK,GAAG,GAAZ;AACA,QAAIC,UAAU,GAAG,IAAjB,CAN6B,CAO7B;;AACA,QAAIC,IAA2B,GAAG;AAChCA,MAAAA,IAAI,EAAEP,IAD0B;AAEhCQ,MAAAA,KAAK,EAAEN,YAFyB;AAGhCO,MAAAA,SAAS,EAAE;AAHqB,KAAlC,CAR6B,CAa7B;;AACA,WAAOF,IAAP,EAAa;AACX,UAAIA,IAAI,CAACC,KAAL,GAAaN,YAAjB,EAA+B;AAC7BQ,QAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqBT,GAArB;AACAO,QAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqB,OAAOR,MAAP,GAAgB,IAArC;AACAD,QAAAA,GAAG,GAAG,EAAN;AACAC,QAAAA,MAAM,GAAG,EAAT;AACAF,QAAAA,YAAY,GAAGK,IAAI,CAACC,KAApB;AACD;;AACD,UAAI/D,QAAe,GAAG8D,IAAI,CAACA,IAAL,CAAUxD,SAAhC;;AACA,cAAQN,QAAQ,CAACoE,MAAjB;AACE,aAAK,CAAL;AACET,UAAAA,MAAM,IAAI,KAAV;AACA;;AACF,aAAK,CAAL;AACE,iBAAOA,MAAM,CAACS,MAAP,GAAgBN,IAAI,CAACE,SAA5B,EAAuC;AACrCL,YAAAA,MAAM,IAAI,GAAV;AACD;;AACDA,UAAAA,MAAM,IAAI,MAAMC,KAAhB;AACA;;AACF,aAAK,CAAL;AACE,iBAAOD,MAAM,CAACS,MAAP,GAAgBN,IAAI,CAACE,SAA5B,EAAuC;AACrCL,YAAAA,MAAM,IAAI,GAAV;AACD;;AACDA,UAAAA,MAAM,IAAI,MAAMC,KAAN,GAAc,IAAd,GAAqBC,UAA/B;AACA;AAfJ;;AAkBA,aAAOH,GAAG,CAACU,MAAJ,aAAaN,IAAb,0CAAa,MAAME,SAAnB,CAAP,EAAqC;AAAA;;AACnCN,QAAAA,GAAG,IAAI,GAAP;AACD;;AACD,WAAK,IAAIW,CAAT,IAAcrE,QAAd,EAAwB;AACtBwD,QAAAA,KAAK,CAACnD,IAAN,CAAW;AAAEyD,UAAAA,IAAI,EAAEO,CAAR;AAAWN,UAAAA,KAAK,EAAED,IAAI,CAACC,KAAL,GAAa,CAA/B;AAAkCC,UAAAA,SAAS,EAAEN,GAAG,CAACU;AAAjD,SAAX;AACD;;AACDV,MAAAA,GAAG,IAAII,IAAI,CAACA,IAAL,CAAUvD,kBAAV,GAA+BsD,UAAtC,CAjCW,CAmCX;;AACAC,MAAAA,IAAI,GAAGN,KAAK,CAACc,GAAN,EAAP;AACD;;AACDL,IAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqBT,GAArB;AACAO,IAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqB,IAArB;AACD;;AAvDe;AA0DlB,OAAO,SAASI,gBAAT,CAA0BT,IAA1B,EAA6D;AAClE,SAAOA,IAAI,YAAYvC,cAAvB;AACD","sourcesContent":["import { global_functions, global_scope } from \"./global\";\nimport { AComputable, Computable, Result } from \"./computable\";\nimport {\n  ArithmeticError,\n  MatrixError,\n  SymbolError,\n  UndeclaredVariableError,\n} from \"./errors\";\nimport { plus_token, SymbolToken, Token, TokenType } from \"./token\";\nimport { Queue } from \"./util\";\n\n/**\n * abstract syntax tree base class\n */\nexport abstract class AbstractSyntaxTree {\n  /**\n   * abstract evaluate method. visits all nodes in postorder traversal\n   */\n  abstract eval(): any;\n  /**\n   * list of children\n   * @dev\n   */\n  abstract get _children(): AbstractSyntaxTree[];\n\n  /**\n   * inherent value of node as a string\n   * @dev\n   */\n  abstract get _node_value_string(): string;\n}\n\n/**\n * compound statements go here\n */\nexport class CompoundNode extends AbstractSyntaxTree {\n  private children: AST[];\n\n  constructor() {\n    super();\n    this.children = [];\n  }\n\n  eval() {\n    let results = [];\n    for (let child of this.children) {\n      let val = child.eval();\n      results.push(val);\n    }\n    return results;\n  }\n  get _children(): AbstractSyntaxTree[] {\n    return this.children;\n  }\n  get _node_value_string(): string {\n    return \"compound\";\n  }\n}\n\n/**\n * assigns a variable to its value\n */\nexport class AssignNode extends AbstractSyntaxTree {\n  private left: VariableNode;\n  private token: Token;\n  private right: AST;\n\n  constructor(left: VariableNode, token: Token, right: AST) {\n    super();\n    this.left = left;\n    this.token = token;\n    this.right = right;\n  }\n  eval() {\n    let name = this.left.value;\n    let val = this.right.eval();\n    global_scope[name] = val;\n    return val;\n    console.log(`${name} = ${global_scope[name]}`);\n  }\n  get _children(): AbstractSyntaxTree[] {\n    return [this.left, this.right];\n  }\n  get _node_value_string(): string {\n    return \"=\";\n  }\n}\n\n/**\n * computes a procedure\n */\nexport class ProcedureNode extends AbstractSyntaxTree {\n  private token: Token;\n  private name: string;\n  private args: AST[];\n\n  constructor(token: SymbolToken, args: AST[]) {\n    super();\n    this.token = token;\n    this.name = token.value;\n    this.args = args;\n  }\n\n  eval() {\n    let func = global_functions[this.name];\n    let result = func.apply(this, this.args);\n    console.log(result);\n    return result;\n  }\n  get _children(): AbstractSyntaxTree[] {\n    throw new Error(\"Method not implemented.\");\n  }\n  get _node_value_string(): string {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n\n/**\n * empty node, doesn't do anything\n */\nexport class EmptyNode extends AbstractSyntaxTree {\n  eval() {\n    return;\n  }\n  get _children(): AbstractSyntaxTree[] {\n    return [];\n  }\n  get _node_value_string(): string {\n    return \"empty node\";\n  }\n}\n\nexport abstract class ComputableNode extends AbstractSyntaxTree {\n  abstract eval(): Computable;\n}\n\n/**\n * binary operator node\n * takes a (left, operator, right)\n */\nexport class BinaryOperatorNode extends ComputableNode {\n  /**\n   * left node in binary operation\n   */\n  private left: AST;\n  /**\n   * right node in binary operation\n   */\n  private right: AST;\n  /**\n   * operator\n   */\n  private operator: Token;\n\n  constructor(left: AST, operator: Token, right: AST) {\n    super();\n    this.left = left;\n    this.right = right;\n    this.operator = operator;\n  }\n\n  // TODO: simplify commutative process\n  public eval(): any {\n    let l = this.left.eval();\n    let r = this.right.eval();\n    let result: Result | undefined;\n\n    if (AComputable.isComputable(l) && AComputable.isComputable(r)) {\n      if (this.operator.type == TokenType.plus) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = { result: l + r };\n        } else if (\n          AComputable.isMatrix(l) &&\n          (AComputable.isNumeric(r) || AComputable.isMatrix(r))\n        ) {\n          result = l.add(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          result = r.add(l);\n        }\n      } else if (this.operator.type == TokenType.minus) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = { result: l - r };\n        } else if (\n          AComputable.isMatrix(l) &&\n          (AComputable.isNumeric(r) || AComputable.isMatrix(r))\n        ) {\n          result = l.sub(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          let tmp = r.mul(-1).result;\n          if (AComputable.isMatrix(tmp)) {\n            result = tmp.add(r);\n          } else {\n            throw new MatrixError(\"ummm... something went wrong\");\n          }\n        }\n      } else if (this.operator.type == TokenType.mul) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = { result: l * r };\n        } else if (\n          AComputable.isMatrix(l) &&\n          (AComputable.isNumeric(r) || AComputable.isMatrix(r))\n        ) {\n          result = l.mul(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          result = r.mul(l);\n        }\n      } else if (this.operator.type == TokenType.div) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = { result: l / r };\n        } else if (\n          AComputable.isMatrix(l) &&\n          (AComputable.isNumeric(r) || AComputable.isMatrix(r))\n        ) {\n          result = l.div(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          result = r.div(l);\n        }\n      } else if (this.operator.type == TokenType.rdiv) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = { result: Math.floor(l / r) };\n        } else if (\n          AComputable.isMatrix(l) &&\n          (AComputable.isNumeric(r) || AComputable.isMatrix(r))\n        ) {\n          result = l.rdiv(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          result = r.rdiv(l);\n        }\n      } else if (this.operator.type == TokenType.pow) {\n        if (AComputable.isNumeric(l) && AComputable.isNumeric(r)) {\n          result = { result: Math.pow(l, r) };\n        } else if (\n          AComputable.isMatrix(l) &&\n          (AComputable.isNumeric(r) || AComputable.isMatrix(r))\n        ) {\n          result = l.pow(r);\n        } else if (AComputable.isNumeric(l) && AComputable.isMatrix(r)) {\n          result = r.pow(l);\n        }\n      }\n    }\n\n    if (result?.message) {\n      console.log(result?.message);\n    }\n    console.log(result?.result.toString());\n    return result?.result;\n  }\n\n  public get _children(): AST[] {\n    return [this.left, this.right];\n  }\n\n  public get _node_value_string(): string {\n    return this.operator.type.toString();\n  }\n}\n\n/**\n * holds a variable and its value\n */\nexport class VariableNode extends ComputableNode {\n  private token: Token;\n  private _value: string;\n\n  public get value(): string {\n    return this._value;\n  }\n\n  constructor(token: SymbolToken) {\n    super();\n    this.token = token;\n    this._value = token.value;\n  }\n  eval() {\n    let name = this.value;\n    let val = global_scope[name];\n    if (val) {\n      console.log(`${name} = ${val}`);\n      return val;\n    } else {\n      throw new UndeclaredVariableError(`${name} was not declared!`);\n    }\n  }\n  get _children(): AbstractSyntaxTree[] {\n    return [];\n  }\n  get _node_value_string(): string {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n\n/**\n * stores a single value: number or matrix\n */\nexport class SingleValueNode extends ComputableNode {\n  private value: Computable;\n\n  constructor(value: Computable) {\n    super();\n    this.value = value;\n  }\n\n  public eval(): Computable {\n    if (AComputable.isNumeric(this.value)) {\n      return this.value;\n    } else if (AComputable.isMatrix(this.value)) {\n      this.value.evaluate();\n      return this.value;\n    } else {\n      throw new SyntaxError(\"invalid single value node!\");\n    }\n  }\n\n  public get _children(): AST[] {\n    return [];\n  }\n\n  public get _node_value_string(): string {\n    return this.value.toString();\n  }\n}\n\n/**\n * holds a unary operator\n */\nexport class UnaryOperatorNode extends ComputableNode {\n  private token: Token;\n  private next: ComputableNode;\n\n  constructor(token: Token, next: ComputableNode) {\n    super();\n    this.token = token;\n    this.next = next;\n  }\n\n  public eval(): Computable {\n    if (this.token.type == TokenType.plus) {\n      // return next element as is\n      return this.next.eval();\n    } else if (this.token.type == TokenType.minus) {\n      // take negation of next element\n      let out = this.next.eval();\n      if (AComputable.isNumeric(out)) {\n        return -1 * out;\n      } else if (AComputable.isMatrix(out)) {\n        return out.mul(-1).result;\n      } else {\n        throw new ArithmeticError(\"couldn't evaluate negation of item\");\n      }\n    } else {\n      throw new SymbolError(\n        \"unexpected unary operator: \" + this.token.type.toString()\n      );\n    }\n  }\n\n  public get _children(): AST[] {\n    return [this.next];\n  }\n\n  public get _node_value_string(): string {\n    return this.token.type.toString();\n  }\n}\n\ninterface NodeLevel {\n  node: AST;\n  level: number;\n  strLength: number;\n}\n\nexport class util {\n  printTreeLevelOrder(tree: AST) {\n    let queue: Queue<NodeLevel> = new Queue();\n    let currentLevel: number = 0;\n    let str = \"\";\n    let arrows: string = \"\";\n    let space = \" \";\n    let extraspace = \"  \";\n    // initialize first element\n    let node: NodeLevel | undefined = {\n      node: tree,\n      level: currentLevel,\n      strLength: 0,\n    };\n    // continue until node is null\n    while (node) {\n      if (node.level > currentLevel) {\n        process.stdout.write(str);\n        process.stdout.write(\"\\n\" + arrows + \"\\n\");\n        str = \"\";\n        arrows = \"\";\n        currentLevel = node.level;\n      }\n      let children: AST[] = node.node._children;\n      switch (children.length) {\n        case 0:\n          arrows += \"   \";\n          break;\n        case 1:\n          while (arrows.length < node.strLength) {\n            arrows += \" \";\n          }\n          arrows += \"|\" + space;\n          break;\n        case 2:\n          while (arrows.length < node.strLength) {\n            arrows += \" \";\n          }\n          arrows += \"|\" + space + \"\\\\\" + extraspace;\n          break;\n      }\n\n      while (str.length < node?.strLength) {\n        str += \" \";\n      }\n      for (let x of children) {\n        queue.push({ node: x, level: node.level + 1, strLength: str.length });\n      }\n      str += node.node._node_value_string + extraspace;\n\n      // dequeue next element\n      node = queue.pop();\n    }\n    process.stdout.write(str);\n    process.stdout.write(\"\\n\");\n  }\n}\n\nexport function isComputableNode(node: AST): node is ComputableNode {\n  return node instanceof ComputableNode;\n}\n\nexport type AST = AbstractSyntaxTree;\nexport type CN = ComputableNode;\nexport type BinOp = BinaryOperatorNode;\nexport type SVN = SingleValueNode;\nexport type UnaryOp = UnaryOperatorNode;\n"]},"metadata":{},"sourceType":"module"}