{"ast":null,"code":"import { SymbolError } from \"./errors\";\nimport { TokenType, newToken } from \"./token\";\nimport { isspace, isdigit, isalnum } from \"./util\";\n\n/**\n * Lexer tokenizes raw input into @class{Token} objects\n */\nexport class Lexer {\n  /**\n   * raw input text\n   */\n\n  /**\n   * current tokenizing position\n   */\n\n  /**\n   * current character at position\n   */\n  constructor(text) {\n    this.reserved_keywords = {};\n    this.text = void 0;\n    this.position = void 0;\n    this.current_char = void 0;\n    this.text = text;\n    this.position = -1;\n  }\n\n  _id() {\n    let result = \"\";\n\n    while (this.current_char && isalnum(this.current_char)) {\n      result += this.current_char;\n      let next = this.peek();\n\n      if (next && isalnum(next)) {\n        this.advance();\n      } else {\n        break;\n      }\n    }\n\n    return this.reserved_keywords[result] || {\n      type: TokenType.id,\n      value: result\n    };\n  }\n  /**\n   * increments position and updates current_char\n   * sets current_char to undefined if position is out of bounds\n   */\n\n\n  advance() {\n    this.position++;\n\n    if (this.position < this.text.length) {\n      this.current_char = this.text.charAt(this.position);\n    } else {\n      this.current_char = undefined;\n    }\n  }\n  /**\n   * retrieves next character without advancing position\n   * @param steps number of steps to take\n   */\n\n\n  peek(steps = 1) {\n    if (this.position + steps >= this.text.length) {\n      return undefined;\n    } else {\n      return this.text.charAt(this.position + steps);\n    }\n  }\n  /**\n   * retrieves the next token by ignoring whitespaces\n   */\n\n\n  peekToken() {\n    let pos = this.position + 1;\n\n    while (pos < this.text.length && isspace(this.text.charAt(pos))) {\n      pos += 1;\n    }\n\n    return this.text.charAt(pos);\n  }\n  /**\n   * skips all whitepsace in sequence\n   */\n\n\n  ignore_whitespace(advance = true) {\n    if (advance) {\n      // stop at next token\n      while (this.current_char && isspace(this.current_char)) {\n        this.advance();\n      }\n    } else {\n      // stop before next token\n      let current = this.peek();\n\n      while (current && isspace(current)) {\n        this.advance();\n      }\n    }\n  }\n  /**\n   * converts numeric character sequence into a token\n   */\n\n\n  tokenize_number() {\n    let result = this.current_char || \"\";\n    let next = this.peek(); // capture integer\n\n    while (next && isdigit(next)) {\n      this.advance();\n      result += this.current_char;\n      next = this.peek();\n    } // check if decimal point\n\n\n    if (next && next == \".\") {\n      let tmpNext = this.peek(2); // make sure next character is a digit, not an elipses or something like '1.'\n\n      if (tmpNext && isdigit(tmpNext)) {\n        this.advance();\n        result += this.current_char;\n        next = this.peek(); // append numbers after decimal point\n\n        while (next && isdigit(next)) {\n          this.advance();\n          result += this.current_char;\n          next = this.peek();\n        }\n      }\n    } // convert to number and return\n\n\n    return Number(result);\n  }\n  /**\n   * retrieves next token in string\n   */\n\n\n  next_token() {\n    this.advance();\n    let token = this.tokenize();\n    return token;\n  }\n  /**\n   * compares characters and matches with associated token\n   */\n\n\n  tokenize() {\n    // ignore all spaces\n    if (this.current_char && isspace(this.current_char)) {\n      this.ignore_whitespace();\n    } // check if no more characters\n\n\n    if (!this.current_char) {\n      return {\n        type: TokenType.eof,\n        value: \"eof\"\n      };\n    }\n\n    if (isdigit(this.current_char)) {\n      // capture numeric token\n      return {\n        type: TokenType.num,\n        value: this.tokenize_number()\n      };\n    } else if (isalnum(this.current_char)) {\n      return this._id();\n    } else if (this.current_char == \"+\") {\n      return newToken(TokenType.plus);\n    } else if (this.current_char == \"-\") {\n      return newToken(TokenType.minus);\n    } else if (this.current_char == \"*\") {\n      return newToken(TokenType.mul);\n    } else if (this.current_char == \"/\") {\n      // check if token is rdiv\n      let next = this.peek();\n\n      if (next && next == \"/\") {\n        this.advance();\n        return newToken(TokenType.div);\n      }\n\n      return newToken(TokenType.rdiv);\n    } else if (this.current_char == \"(\") {\n      return newToken(TokenType.lparen);\n    } else if (this.current_char == \")\") {\n      return newToken(TokenType.rparen);\n    } else if (this.current_char == \"[\") {\n      return newToken(TokenType.lbracket);\n    } else if (this.current_char == \"]\") {\n      return newToken(TokenType.rbracket);\n    } else if (this.current_char == \"<\") {\n      return newToken(TokenType.larrow);\n    } else if (this.current_char == \">\") {\n      return newToken(TokenType.rarrow);\n    } else if (this.current_char == \";\") {\n      return newToken(TokenType.semicolon);\n    } else if (this.current_char == \",\") {\n      return newToken(TokenType.comma);\n    } else if (this.current_char == \"|\") {\n      return newToken(TokenType.bar);\n    } else if (this.current_char == \"=\" && this.peek() != \"=\") {\n      return newToken(TokenType.assign);\n    } else if (this.current_char == \".\" && this.peek() != \".\") {\n      return newToken(TokenType.dot);\n    } else if (this.current_char == \"\\n\") {\n      return newToken(TokenType.endl);\n    } else if (this.current_char == \"^\") {\n      return newToken(TokenType.pow);\n    } // token wasn't recognized\n\n\n    throw new SymbolError(\"unexpected token: `\" + this.current_char + \"`\");\n  }\n\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/lexer.ts"],"names":["SymbolError","TokenType","newToken","isspace","isdigit","isalnum","Lexer","constructor","text","reserved_keywords","position","current_char","_id","result","next","peek","advance","type","id","value","length","charAt","undefined","steps","peekToken","pos","ignore_whitespace","current","tokenize_number","tmpNext","Number","next_token","token","tokenize","eof","num","plus","minus","mul","div","rdiv","lparen","rparen","lbracket","rbracket","larrow","rarrow","semicolon","comma","bar","assign","dot","endl","pow"],"mappings":"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","sourcesContent":["import { SymbolError } from \"./errors\";\nimport { Token, TokenType, SymbolToken, newToken } from \"./token\";\nimport { isspace, isdigit, isalnum } from \"./util\";\n\ninterface Keywords {\n  [key: string]: SymbolToken;\n}\n\n/**\n * Lexer tokenizes raw input into @class{Token} objects\n */\nexport class Lexer {\n  private readonly reserved_keywords: Keywords = {};\n  /**\n   * raw input text\n   */\n  private text: string;\n  /**\n   * current tokenizing position\n   */\n  private position: number;\n  /**\n   * current character at position\n   */\n  private current_char: string | undefined;\n\n  constructor(text: string) {\n    this.text = text;\n    this.position = -1;\n  }\n\n  private _id(): SymbolToken {\n    let result = \"\";\n    while (this.current_char && isalnum(this.current_char)) {\n      result += this.current_char;\n      let next = this.peek();\n      if (next && isalnum(next)) {\n        this.advance();\n      } else {\n        break;\n      }\n    }\n    return (\n      this.reserved_keywords[result] || { type: TokenType.id, value: result }\n    );\n  }\n\n  /**\n   * increments position and updates current_char\n   * sets current_char to undefined if position is out of bounds\n   */\n  private advance() {\n    this.position++;\n\n    if (this.position < this.text.length) {\n      this.current_char = this.text.charAt(this.position);\n    } else {\n      this.current_char = undefined;\n    }\n  }\n\n  /**\n   * retrieves next character without advancing position\n   * @param steps number of steps to take\n   */\n  public peek(steps: number = 1): string | undefined {\n    if (this.position + steps >= this.text.length) {\n      return undefined;\n    } else {\n      return this.text.charAt(this.position + steps);\n    }\n  }\n\n  /**\n   * retrieves the next token by ignoring whitespaces\n   */\n  public peekToken(): string {\n    let pos = this.position + 1;\n    while (pos < this.text.length && isspace(this.text.charAt(pos))) {\n      pos += 1;\n    }\n    return this.text.charAt(pos);\n  }\n\n  /**\n   * skips all whitepsace in sequence\n   */\n  private ignore_whitespace(advance: boolean = true) {\n    if (advance) {\n      // stop at next token\n      while (this.current_char && isspace(this.current_char)) {\n        this.advance();\n      }\n    } else {\n      // stop before next token\n      let current = this.peek();\n      while (current && isspace(current)) {\n        this.advance();\n      }\n    }\n  }\n\n  /**\n   * converts numeric character sequence into a token\n   */\n  private tokenize_number(): number {\n    let result = this.current_char || \"\";\n    let next = this.peek();\n    // capture integer\n    while (next && isdigit(next)) {\n      this.advance();\n      result += this.current_char;\n      next = this.peek();\n    }\n\n    // check if decimal point\n    if (next && next == \".\") {\n      let tmpNext = this.peek(2);\n      // make sure next character is a digit, not an elipses or something like '1.'\n      if (tmpNext && isdigit(tmpNext)) {\n        this.advance();\n        result += this.current_char;\n        next = this.peek();\n\n        // append numbers after decimal point\n        while (next && isdigit(next)) {\n          this.advance();\n          result += this.current_char;\n          next = this.peek();\n        }\n      }\n    }\n\n    // convert to number and return\n    return Number(result);\n  }\n\n  /**\n   * retrieves next token in string\n   */\n  public next_token(): Token {\n    this.advance();\n    let token = this.tokenize();\n    return token;\n  }\n\n  /**\n   * compares characters and matches with associated token\n   */\n  private tokenize(): Token {\n    // ignore all spaces\n    if (this.current_char && isspace(this.current_char)) {\n      this.ignore_whitespace();\n    }\n\n    // check if no more characters\n    if (!this.current_char) {\n      return { type: TokenType.eof, value: \"eof\" };\n    }\n\n    if (isdigit(this.current_char)) {\n      // capture numeric token\n      return { type: TokenType.num, value: this.tokenize_number() };\n    } else if (isalnum(this.current_char)) {\n      return this._id();\n    } else if (this.current_char == \"+\") {\n      return newToken(TokenType.plus);\n    } else if (this.current_char == \"-\") {\n      return newToken(TokenType.minus);\n    } else if (this.current_char == \"*\") {\n      return newToken(TokenType.mul);\n    } else if (this.current_char == \"/\") {\n      // check if token is rdiv\n      let next = this.peek();\n      if (next && next == \"/\") {\n        this.advance();\n        return newToken(TokenType.div);\n      }\n      return newToken(TokenType.rdiv);\n    } else if (this.current_char == \"(\") {\n      return newToken(TokenType.lparen);\n    } else if (this.current_char == \")\") {\n      return newToken(TokenType.rparen);\n    } else if (this.current_char == \"[\") {\n      return newToken(TokenType.lbracket);\n    } else if (this.current_char == \"]\") {\n      return newToken(TokenType.rbracket);\n    } else if (this.current_char == \"<\") {\n      return newToken(TokenType.larrow);\n    } else if (this.current_char == \">\") {\n      return newToken(TokenType.rarrow);\n    } else if (this.current_char == \";\") {\n      return newToken(TokenType.semicolon);\n    } else if (this.current_char == \",\") {\n      return newToken(TokenType.comma);\n    } else if (this.current_char == \"|\") {\n      return newToken(TokenType.bar);\n    } else if (this.current_char == \"=\" && this.peek() != \"=\") {\n      return newToken(TokenType.assign);\n    } else if (this.current_char == \".\" && this.peek() != \".\") {\n      return newToken(TokenType.dot);\n    } else if (this.current_char == \"\\n\") {\n      return newToken(TokenType.endl);\n    } else if (this.current_char == \"^\") {\n      return newToken(TokenType.pow);\n    }\n\n    // token wasn't recognized\n    throw new SymbolError(\"unexpected token: `\" + this.current_char + \"`\");\n  }\n}\n"]},"metadata":{},"sourceType":"module"}