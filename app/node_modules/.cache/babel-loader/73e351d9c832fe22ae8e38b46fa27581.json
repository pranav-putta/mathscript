{"ast":null,"code":"import { AssignNode, BinaryOperatorNode, CompoundNode, isComputableNode, SingleValueNode, UnaryOperatorNode, VariableNode, ProcedureNode } from \"./ast\";\nimport { Numeric, Logical, UnevaluatedMatrix } from \"./computable\";\nimport { MatrixError, ParsingError, SymbolError, SyntaxError } from \"./errors\";\nimport { Lexer } from \"./lexer\";\nimport { TokenType, isNumericToken, isSymbolToken } from \"./token\";\nexport class Parser {\n  constructor(lexer) {\n    this.lexer = void 0;\n    this.current_token = void 0;\n    this.lexer = lexer;\n    this.current_token = this.lexer.next_token();\n  }\n  /**\n   * parse tokens into an abstract syntax tree for traversal\n   */\n\n\n  parse() {\n    let node = this.program();\n\n    if (this.current_token.type != TokenType.eof) {\n      throw new SyntaxError(\"parsing didn't go as expected!\");\n    }\n\n    return node;\n  }\n  /**\n   * identify expression\n   * expr   : term ((PLUS | MINUS) term)* | term ((PLUS | MINUS)term)*\n   * term   : powers ((MUL | DIV ) powers)*\n   * powers : factor ((POW) factor)*\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix | variable | procedure | (TRUE | FALSE)\n   * matrix :  lbracket (row)* rbracket\n   */\n\n\n  expr(ignoreWhiteSpace = true) {\n    let factor = this.factor;\n    let powers = this.binop(factor, [TokenType.pow]);\n    let mul_div_rdiv = this.binop(powers, [TokenType.mul, TokenType.div, TokenType.rdiv]);\n    let add_plus = this.binop(mul_div_rdiv, [TokenType.plus, TokenType.minus], ignoreWhiteSpace);\n    let and = this.binop(add_plus, [TokenType.and_bool]);\n    let or = this.binop(and, [TokenType.or_bool]);\n    return or.apply(this);\n  }\n\n  bool() {\n    let token = this.current_token;\n\n    if (token.type == TokenType.primitive) {\n      if (token.value === Lexer.reserved_keywords[\"true\"].value) {\n        this.eat(TokenType.primitive);\n        return new SingleValueNode(new Logical(true));\n      } else if (token.value === Lexer.reserved_keywords[\"false\"].value) {\n        this.eat(TokenType.primitive);\n        return new SingleValueNode(new Logical(false));\n      }\n    }\n\n    throw new ParsingError(\"unexpected symbol: \" + token.value);\n  }\n  /**\n   * create a binary operation function\n   * @param func function to process\n   * @param operators operators to check for\n   * @param ignoreWhiteSpace check for whitespace pattern \" + 1\" => plus, \" +1\" => unary positive\n   */\n\n\n  binop(func, operators, ignoreWhiteSpace = true) {\n    // create a callable function\n    let call = () => {\n      // left node\n      let node = func.apply(this);\n      let token = this.current_token;\n\n      while (operators.includes(token.type)) {\n        if (ignoreWhiteSpace || this.lexer.peek(1) == \" \" || this.lexer.peek(-1) != \" \") {\n          this.eat(token.type);\n          node = new BinaryOperatorNode(node, token, func.apply(this));\n          token = this.current_token;\n        } else {\n          return node;\n        }\n      }\n\n      return node;\n    };\n\n    return call;\n  }\n  /**\n   * identify factor\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix\n   * matrix :  lbracket (row)* rbracket\n   * @return abstract syntax node\n   */\n\n\n  factor() {\n    let token = this.current_token;\n\n    if (token.type == TokenType.plus) {\n      // positive sign\n      this.eat(TokenType.plus);\n      return new UnaryOperatorNode(token, this.factor());\n    } else if (token.type == TokenType.minus) {\n      // negation sign\n      this.eat(TokenType.minus);\n      return new UnaryOperatorNode(token, this.factor());\n    } else if (isNumericToken(token)) {\n      // token is a number\n      this.eat(TokenType.num);\n      return new SingleValueNode(new Numeric(token.value));\n    } else if (token.type == TokenType.lparen) {\n      // lparen expr rparen\n      this.eat(TokenType.lparen);\n      let node = this.expr();\n      this.eat(TokenType.rparen);\n      return node;\n    } else if (token.type == TokenType.lbracket) {\n      // matrix\n      let matrix = this.matrix();\n      return new SingleValueNode(matrix);\n    } else if (token.type == TokenType.larrow) {\n      // vector (meaning single row matrix)\n      let vector = this.vector();\n      return new SingleValueNode(vector);\n    } else if (token.type == TokenType.id) {\n      // identifier\n      let next = this.lexer.peek();\n\n      if (next && next == \"(\") {\n        // procedure\n        return this.procedure();\n      } else {\n        // variable identifier\n        return this.variable();\n      }\n    } else if (token.type == TokenType.primitive) {\n      return this.bool();\n    }\n\n    throw new SyntaxError(\"unexpected symbol\");\n  }\n  /**\n   * vector : single row matrix\n   */\n\n\n  vector() {\n    // check left arrow\n    this.eat(TokenType.larrow); // get one row\n\n    let row = this.matrix_row(TokenType.rarrow); // check right arrow\n\n    this.eat(TokenType.rarrow);\n    return new UnevaluatedMatrix([row]);\n  }\n  /**\n   * matrix :  lbracket (row ;)* (row ]) rbracket\n   */\n\n\n  matrix() {\n    let arr = new Array(); // check left bracket\n\n    this.eat(TokenType.lbracket, \"parsing matrix: \"); // loop through rows\n\n    while (this.current_token.type != TokenType.rbracket) {\n      let row = this.matrix_row(TokenType.rbracket);\n      arr.push(row);\n\n      if (this.current_token.type == TokenType.semicolon) {\n        this.eat(TokenType.semicolon, \"parsing matrix row: \");\n      }\n    } // check right bracket\n\n\n    this.eat(TokenType.rbracket, \"parsing matrix: \");\n    return new UnevaluatedMatrix(arr);\n  }\n  /**\n   * row : (factor,)*\n   */\n\n\n  matrix_row(endToken) {\n    let arr = new Array();\n\n    while (true) {\n      let val = this.expr(false); // make sure the element is computable\n\n      if (isComputableNode(val)) {\n        // everything else is good, push element into row\n        arr.push(val); // if row hasn't reached end, consume 'comma' separator\n\n        if (this.current_token.type != TokenType.semicolon && this.current_token.type != endToken) {\n          if (this.current_token.type == TokenType.comma) {\n            this.eat(TokenType.comma, \"parsing matrix row: \");\n          }\n        } else {\n          break;\n        }\n      } else {\n        throw new MatrixError(\"matrix parsing error: expected a numeric element\");\n      }\n    }\n\n    return arr;\n  }\n  /**\n   * consume token and advance to next token\n   * @param type token type to verify\n   */\n\n\n  eat(type, message) {\n    if (this.current_token.type == type) {\n      // if expected token type and current token type matches, proceed to next token\n      this.current_token = this.lexer.next_token();\n    } else {\n      // if token type does not match, a syntax error has happened\n      throw new SyntaxError(message || \"\" + \"expected \" + type.toString() + \", but got \" + this.current_token.type.toString());\n    }\n  }\n  /**\n   * variable : id\n   */\n\n\n  variable() {\n    if (isSymbolToken(this.current_token)) {\n      let node = new VariableNode(this.current_token);\n      this.eat(TokenType.id);\n      return node;\n    }\n\n    throw new SymbolError(\"couldn't parse variable name\");\n  }\n  /**\n   * program : compound eof\n   */\n\n\n  program() {\n    let node = this.compound();\n    this.eat(TokenType.eof);\n    return node;\n  }\n  /**\n   * compound: statement_list\n   */\n\n\n  compound() {\n    return new CompoundNode(this.statement_list());\n  }\n  /**\n   * statement_list : statement | statement endl statement_list\n   */\n\n\n  statement_list() {\n    let results = this.statement();\n\n    while (this.current_token.type == TokenType.endl) {\n      // ignore all end lines\n      while (this.current_token.type == TokenType.endl) {\n        this.eat(TokenType.endl);\n      }\n\n      results = results.concat(this.statement());\n    }\n\n    if (this.current_token.type == TokenType.id) {\n      throw new SyntaxError(\"unexpected identifier\");\n    }\n\n    return results;\n  }\n  /**\n   * statement : id_statement | expr\n   */\n\n\n  statement() {\n    if (this.current_token.type == TokenType.id) {\n      return this.id_statement();\n    } else if (this.current_token.type == TokenType.reserved) {\n      return this.reserved_statement();\n    } else if (this.current_token.type != TokenType.eof) {\n      return [this.expr(true)];\n    } else {\n      return [];\n    }\n  }\n\n  reserved_statement() {\n    let token = this.current_token;\n\n    if (token.value === Lexer.reserved_keywords[\"true\"].value) {\n      this.eat(token.type);\n      return [new SingleValueNode(new Logical(true))];\n    } else if (token.value === Lexer.reserved_keywords[\"false\"].value) {\n      this.eat(token.type);\n      return [new SingleValueNode(new Logical(false))];\n    } else {\n      throw new ParsingError(\"unexpected reserve word\");\n    }\n  }\n  /**\n   * id_statement : assignemnt | procedure | expr\n   */\n\n\n  id_statement() {\n    let token = this.current_token;\n\n    if (token.type == TokenType.id) {\n      if (this.lexer.peekToken() == \"=\") {\n        return this.assignment();\n      } else if (this.lexer.peekToken() == \"(\") {\n        return [this.procedure()];\n      } else {\n        return [this.expr()];\n      }\n    }\n\n    throw new ParsingError(\"couldn't find an identifier!\");\n  }\n  /**\n   * assignment : (variable = expr) (,variable = expr)*\n   */\n\n\n  assignment() {\n    let left = this.variable();\n    let token = this.current_token;\n    this.eat(TokenType.assign, \"parsing assignment: \");\n    let right = this.expr();\n    let assignments = [new AssignNode(left, token, right)]; //  check if multiline assignment\n\n    if (this.current_token.type == TokenType.comma) {\n      this.eat(TokenType.comma);\n      let next = this.assignment();\n      assignments = assignments.concat(next);\n    }\n\n    return assignments;\n  }\n  /**\n   * procedure : id lparen (expr,)* rparen\n   */\n\n\n  procedure() {\n    let token = this.current_token;\n\n    if (!isSymbolToken(token)) {\n      throw new SymbolError(\"expected an identifier symbol but didn't get it!\");\n    }\n\n    this.eat(TokenType.id);\n    this.eat(TokenType.lparen);\n    let args = [];\n\n    while (this.current_token.type != TokenType.rparen) {\n      args.push(this.expr());\n\n      if (this.current_token.type == TokenType.comma) {\n        this.eat(TokenType.comma);\n      } else {\n        break;\n      }\n    }\n\n    this.eat(TokenType.rparen);\n    return new ProcedureNode(token, args);\n  }\n\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/parser.ts"],"names":["AssignNode","BinaryOperatorNode","CompoundNode","isComputableNode","SingleValueNode","UnaryOperatorNode","VariableNode","ProcedureNode","Numeric","Logical","UnevaluatedMatrix","MatrixError","ParsingError","SymbolError","SyntaxError","Lexer","TokenType","isNumericToken","isSymbolToken","Parser","constructor","lexer","current_token","next_token","parse","node","program","type","eof","expr","ignoreWhiteSpace","factor","powers","binop","pow","mul_div_rdiv","mul","div","rdiv","add_plus","plus","minus","and","and_bool","or","or_bool","apply","bool","token","primitive","value","reserved_keywords","eat","func","operators","call","includes","peek","num","lparen","rparen","lbracket","matrix","larrow","vector","id","next","procedure","variable","row","matrix_row","rarrow","arr","Array","rbracket","push","semicolon","endToken","val","comma","message","toString","compound","statement_list","results","statement","endl","concat","id_statement","reserved","reserved_statement","peekToken","assignment","left","assign","right","assignments","args"],"mappings":"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","sourcesContent":["import {\n  AssignNode,\n  AST,\n  BinaryOperatorNode,\n  CompoundNode,\n  ComputableNode,\n  isComputableNode,\n  SingleValueNode,\n  UnaryOperatorNode,\n  VariableNode,\n  ProcedureNode,\n} from \"./ast\";\nimport { Numeric, Logical, UnevaluatedMatrix } from \"./computable\";\nimport { MatrixError, ParsingError, SymbolError, SyntaxError } from \"./errors\";\nimport { Lexer } from \"./lexer\";\nimport { TokenType, Token, isNumericToken, isSymbolToken } from \"./token\";\n\nexport class Parser {\n  private lexer: Lexer;\n  private current_token: Token;\n\n  constructor(lexer: Lexer) {\n    this.lexer = lexer;\n    this.current_token = this.lexer.next_token();\n  }\n\n  /**\n   * parse tokens into an abstract syntax tree for traversal\n   */\n  public parse(): AST {\n    let node = this.program();\n    if (this.current_token.type != TokenType.eof) {\n      throw new SyntaxError(\"parsing didn't go as expected!\");\n    }\n    return node;\n  }\n\n  /**\n   * identify expression\n   * expr   : term ((PLUS | MINUS) term)* | term ((PLUS | MINUS)term)*\n   * term   : powers ((MUL | DIV ) powers)*\n   * powers : factor ((POW) factor)*\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix | variable | procedure | (TRUE | FALSE)\n   * matrix :  lbracket (row)* rbracket\n   */\n  private expr(ignoreWhiteSpace: boolean = true): AST {\n    let factor = this.factor;\n    let powers = this.binop(factor, [TokenType.pow]);\n    let mul_div_rdiv = this.binop(powers, [\n      TokenType.mul,\n      TokenType.div,\n      TokenType.rdiv,\n    ]);\n    let add_plus = this.binop(\n      mul_div_rdiv,\n      [TokenType.plus, TokenType.minus],\n      ignoreWhiteSpace\n    );\n    let and = this.binop(add_plus, [TokenType.and_bool]);\n    let or = this.binop(and, [TokenType.or_bool]);\n    return or.apply(this);\n  }\n\n  private bool(): AST {\n    let token = this.current_token;\n    if (token.type == TokenType.primitive) {\n      if (token.value === Lexer.reserved_keywords[\"true\"].value) {\n        this.eat(TokenType.primitive);\n        return new SingleValueNode(new Logical(true));\n      } else if (token.value === Lexer.reserved_keywords[\"false\"].value) {\n        this.eat(TokenType.primitive);\n        return new SingleValueNode(new Logical(false));\n      }\n    }\n    throw new ParsingError(\"unexpected symbol: \" + token.value);\n  }\n\n  /**\n   * create a binary operation function\n   * @param func function to process\n   * @param operators operators to check for\n   * @param ignoreWhiteSpace check for whitespace pattern \" + 1\" => plus, \" +1\" => unary positive\n   */\n  private binop(\n    func: () => AST,\n    operators: TokenType[],\n    ignoreWhiteSpace: boolean = true\n  ): () => AST {\n    // create a callable function\n    let call = (): AST => {\n      // left node\n      let node: AST = func.apply(this);\n      let token: Token = this.current_token;\n      while (operators.includes(token.type)) {\n        if (\n          ignoreWhiteSpace ||\n          this.lexer.peek(1) == \" \" ||\n          this.lexer.peek(-1) != \" \"\n        ) {\n          this.eat(token.type);\n          node = new BinaryOperatorNode(node, token, func.apply(this));\n          token = this.current_token;\n        } else {\n          return node;\n        }\n      }\n      return node;\n    };\n    return call;\n  }\n\n  /**\n   * identify factor\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix\n   * matrix :  lbracket (row)* rbracket\n   * @return abstract syntax node\n   */\n  private factor(): AST {\n    let token = this.current_token;\n    if (token.type == TokenType.plus) {\n      // positive sign\n      this.eat(TokenType.plus);\n      return new UnaryOperatorNode(token, this.factor());\n    } else if (token.type == TokenType.minus) {\n      // negation sign\n      this.eat(TokenType.minus);\n      return new UnaryOperatorNode(token, this.factor());\n    } else if (isNumericToken(token)) {\n      // token is a number\n      this.eat(TokenType.num);\n      return new SingleValueNode(new Numeric(token.value));\n    } else if (token.type == TokenType.lparen) {\n      // lparen expr rparen\n      this.eat(TokenType.lparen);\n      let node: AST = this.expr();\n      this.eat(TokenType.rparen);\n      return node;\n    } else if (token.type == TokenType.lbracket) {\n      // matrix\n      let matrix: UnevaluatedMatrix = this.matrix();\n      return new SingleValueNode(matrix);\n    } else if (token.type == TokenType.larrow) {\n      // vector (meaning single row matrix)\n      let vector: UnevaluatedMatrix = this.vector();\n      return new SingleValueNode(vector);\n    } else if (token.type == TokenType.id) {\n      // identifier\n      let next = this.lexer.peek();\n      if (next && next == \"(\") {\n        // procedure\n        return this.procedure();\n      } else {\n        // variable identifier\n        return this.variable();\n      }\n    } else if (token.type == TokenType.primitive) {\n      return this.bool();\n    }\n\n    throw new SyntaxError(\"unexpected symbol\");\n  }\n\n  /**\n   * vector : single row matrix\n   */\n  private vector(): UnevaluatedMatrix {\n    // check left arrow\n    this.eat(TokenType.larrow);\n    // get one row\n    let row = this.matrix_row(TokenType.rarrow);\n    // check right arrow\n    this.eat(TokenType.rarrow);\n    return new UnevaluatedMatrix([row]);\n  }\n\n  /**\n   * matrix :  lbracket (row ;)* (row ]) rbracket\n   */\n  private matrix(): UnevaluatedMatrix {\n    let arr: ComputableNode[][] = new Array();\n    // check left bracket\n    this.eat(TokenType.lbracket, \"parsing matrix: \");\n    // loop through rows\n    while (this.current_token.type != TokenType.rbracket) {\n      let row = this.matrix_row(TokenType.rbracket);\n      arr.push(row);\n      if (this.current_token.type == TokenType.semicolon) {\n        this.eat(TokenType.semicolon, \"parsing matrix row: \");\n      }\n    }\n    // check right bracket\n    this.eat(TokenType.rbracket, \"parsing matrix: \");\n    return new UnevaluatedMatrix(arr);\n  }\n\n  /**\n   * row : (factor,)*\n   */\n  private matrix_row(endToken: TokenType): ComputableNode[] {\n    let arr: ComputableNode[] = new Array();\n\n    while (true) {\n      let val = this.expr(false);\n      // make sure the element is computable\n      if (isComputableNode(val)) {\n        // everything else is good, push element into row\n        arr.push(val);\n        // if row hasn't reached end, consume 'comma' separator\n        if (\n          this.current_token.type != TokenType.semicolon &&\n          this.current_token.type != endToken\n        ) {\n          if (this.current_token.type == TokenType.comma) {\n            this.eat(TokenType.comma, \"parsing matrix row: \");\n          }\n        } else {\n          break;\n        }\n      } else {\n        throw new MatrixError(\n          \"matrix parsing error: expected a numeric element\"\n        );\n      }\n    }\n\n    return arr;\n  }\n\n  /**\n   * consume token and advance to next token\n   * @param type token type to verify\n   */\n  private eat(type: TokenType, message?: string) {\n    if (this.current_token.type == type) {\n      // if expected token type and current token type matches, proceed to next token\n      this.current_token = this.lexer.next_token();\n    } else {\n      // if token type does not match, a syntax error has happened\n      throw new SyntaxError(\n        message ||\n          \"\" +\n            \"expected \" +\n            type.toString() +\n            \", but got \" +\n            this.current_token.type.toString()\n      );\n    }\n  }\n\n  /**\n   * variable : id\n   */\n  private variable(): VariableNode {\n    if (isSymbolToken(this.current_token)) {\n      let node = new VariableNode(this.current_token);\n      this.eat(TokenType.id);\n      return node;\n    }\n    throw new SymbolError(\"couldn't parse variable name\");\n  }\n\n  /**\n   * program : compound eof\n   */\n  private program(): AST {\n    let node = this.compound();\n    this.eat(TokenType.eof);\n    return node;\n  }\n\n  /**\n   * compound: statement_list\n   */\n  private compound(): AST {\n    return new CompoundNode(this.statement_list());\n  }\n\n  /**\n   * statement_list : statement | statement endl statement_list\n   */\n  private statement_list(): AST[] {\n    let results = this.statement();\n    while (this.current_token.type == TokenType.endl) {\n      // ignore all end lines\n      while (this.current_token.type == TokenType.endl) {\n        this.eat(TokenType.endl);\n      }\n      results = results.concat(this.statement());\n    }\n\n    if (this.current_token.type == TokenType.id) {\n      throw new SyntaxError(\"unexpected identifier\");\n    }\n\n    return results;\n  }\n\n  /**\n   * statement : id_statement | expr\n   */\n  private statement(): AST[] {\n    if (this.current_token.type == TokenType.id) {\n      return this.id_statement();\n    } else if (this.current_token.type == TokenType.reserved) {\n      return this.reserved_statement();\n    } else if (this.current_token.type != TokenType.eof) {\n      return [this.expr(true)];\n    } else {\n      return [];\n    }\n  }\n\n  private reserved_statement(): AST[] {\n    let token = this.current_token;\n    if (token.value === Lexer.reserved_keywords[\"true\"].value) {\n      this.eat(token.type);\n      return [new SingleValueNode(new Logical(true))];\n    } else if (token.value === Lexer.reserved_keywords[\"false\"].value) {\n      this.eat(token.type);\n      return [new SingleValueNode(new Logical(false))];\n    } else {\n      throw new ParsingError(\"unexpected reserve word\");\n    }\n  }\n\n  /**\n   * id_statement : assignemnt | procedure | expr\n   */\n  private id_statement(): AST[] {\n    let token = this.current_token;\n    if (token.type == TokenType.id) {\n      if (this.lexer.peekToken() == \"=\") {\n        return this.assignment();\n      } else if (this.lexer.peekToken() == \"(\") {\n        return [this.procedure()];\n      } else {\n        return [this.expr()];\n      }\n    }\n\n    throw new ParsingError(\"couldn't find an identifier!\");\n  }\n\n  /**\n   * assignment : (variable = expr) (,variable = expr)*\n   */\n  private assignment(): AssignNode[] {\n    let left = this.variable();\n    let token = this.current_token;\n    this.eat(TokenType.assign, \"parsing assignment: \");\n    let right = this.expr();\n    let assignments = [new AssignNode(left, token, right)];\n    //  check if multiline assignment\n    if (this.current_token.type == TokenType.comma) {\n      this.eat(TokenType.comma);\n      let next = this.assignment();\n      assignments = assignments.concat(next);\n    }\n    return assignments;\n  }\n\n  /**\n   * procedure : id lparen (expr,)* rparen\n   */\n  private procedure(): ProcedureNode {\n    let token = this.current_token;\n    if (!isSymbolToken(token)) {\n      throw new SymbolError(\"expected an identifier symbol but didn't get it!\");\n    }\n    this.eat(TokenType.id);\n    this.eat(TokenType.lparen);\n    let args = [];\n    while (this.current_token.type != TokenType.rparen) {\n      args.push(this.expr());\n      if (this.current_token.type == TokenType.comma) {\n        this.eat(TokenType.comma);\n      } else {\n        break;\n      }\n    }\n    this.eat(TokenType.rparen);\n    return new ProcedureNode(token, args);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}