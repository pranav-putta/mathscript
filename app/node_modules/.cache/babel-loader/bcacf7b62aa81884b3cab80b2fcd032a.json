{"ast":null,"code":"import { AssignNode, BinaryOperatorNode, CompoundNode, isComputableNode, SingleValueNode, UnaryOperatorNode, VariableNode, ProcedureCallNode, VariableScope, ProcedureDefinitionNode, EmptyNode, TernaryOperator } from \"./ast\";\nimport { Numeric, Logical, UnevaluatedMatrix } from \"./computable\";\nimport { MatrixError, ParsingError, SymbolError, SyntaxError } from \"./errors\";\nimport { Lexer } from \"./lexer\";\nimport { TokenType, isNumericToken, isSymbolToken } from \"./token\";\nexport class Parser {\n  constructor(lexer) {\n    this.lexer = void 0;\n    this.current_token = void 0;\n    this.lexer = lexer;\n    this.current_token = this.lexer.next_token();\n  }\n  /**\n   * parse tokens into an abstract syntax tree for traversal\n   */\n\n\n  parse() {\n    let node = this.program();\n\n    if (this.current_token.type != TokenType.eof) {\n      throw new SyntaxError(\"parsing didn't go as expected!\");\n    }\n\n    return node;\n  }\n  /**\n   * identify expression\n   * expr   : term ((PLUS | MINUS) term)* | term ((PLUS | MINUS)term)*\n   * term   : powers ((MUL | DIV ) powers)*\n   * powers : factor ((POW) factor)*\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix | variable | procedure | (TRUE | FALSE)\n   * matrix :  lbracket (row)* rbracket\n   */\n\n\n  expr(ignoreWhiteSpace, scope) {\n    let opsOrder = [{\n      tokens: [TokenType.pow],\n      igws: ignoreWhiteSpace,\n      scope: scope\n    }, {\n      tokens: [TokenType.modulo],\n      igws: ignoreWhiteSpace,\n      scope: scope\n    }, {\n      tokens: [TokenType.mul, TokenType.div, TokenType.rdiv],\n      igws: true,\n      scope: scope\n    }, {\n      tokens: [TokenType.plus, TokenType.minus],\n      igws: ignoreWhiteSpace,\n      scope: scope\n    }, {\n      tokens: [TokenType.and, TokenType.or],\n      igws: ignoreWhiteSpace,\n      scope: scope\n    }, {\n      tokens: [TokenType.larrow, TokenType.rarrow, TokenType.eq, TokenType.not_bool, TokenType.less_eq, TokenType.more_eq],\n      igws: ignoreWhiteSpace,\n      scope: scope\n    }, {\n      tokens: [TokenType.and_bool],\n      igws: true,\n      scope: scope\n    }, {\n      tokens: [TokenType.or_bool],\n      igws: true,\n      scope: scope\n    }];\n    let func = this.factor;\n\n    for (let op of opsOrder) {\n      func = this.binops(func, op.tokens, op.igws);\n    }\n\n    let expr = func.call(this, scope); // if ? ternary operation, otherwise return\n\n    if (this.current_token.type == TokenType.ternary) {\n      this.eat(TokenType.ternary);\n      let t = this.expr(ignoreWhiteSpace, scope);\n      this.eat(TokenType.colon);\n      let f = this.expr(ignoreWhiteSpace, scope);\n      return new TernaryOperator(expr, t, f);\n    }\n\n    return expr;\n  }\n  /**\n   *\n   * @param func\n   * @param operators\n   * @param ignoreWhiteSpace\n   */\n\n\n  binops(func, operators, ignoreWhiteSpace = true) {\n    return scope => {\n      // left node\n      let node = func.call(this, scope);\n      let token = this.current_token;\n\n      while (operators.includes(token.type)) {\n        if (ignoreWhiteSpace || this.lexer.peek(1) == \" \" || this.lexer.peek(-1) != \" \") {\n          this.eat(token.type);\n          node = new BinaryOperatorNode(node, token, func.call(this, scope));\n          token = this.current_token;\n        } else {\n          return node;\n        }\n      }\n\n      return node;\n    };\n  }\n  /**\n   * identify factor\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix\n   * matrix :  lbracket (row)* rbracket\n   * @return abstract syntax node\n   */\n\n\n  factor(scope) {\n    let token = this.current_token;\n\n    if (token.type == TokenType.plus) {\n      // positive sign\n      this.eat(TokenType.plus);\n      return new UnaryOperatorNode(token, this.factor(scope));\n    } else if (token.type == TokenType.minus) {\n      // negation sign\n      this.eat(TokenType.minus);\n      return new UnaryOperatorNode(token, this.factor(scope));\n    } else if (token.type == TokenType.not) {\n      this.eat(TokenType.not);\n      return new UnaryOperatorNode(token, this.factor(scope));\n    } else if (isNumericToken(token)) {\n      // token is a number\n      this.eat(TokenType.num);\n      return new SingleValueNode(new Numeric(token.value));\n    } else if (token.type == TokenType.lparen) {\n      // lparen expr rparen\n      this.eat(TokenType.lparen);\n      let node = this.expr(true, scope);\n      this.eat(TokenType.rparen);\n      return node;\n    } else if (token.type == TokenType.lbracket) {\n      // matrix\n      return new SingleValueNode(this.matrix());\n    } else if (token.type == TokenType.larrow) {\n      // vector (meaning single row matrix)\n      return new SingleValueNode(this.vector());\n    } else if (token.type == TokenType.primitive) {\n      return this.primitive();\n    } else if (token.type == TokenType.id) {\n      // identifier\n      let next = this.lexer.peekToken();\n\n      if (next.type == TokenType.lparen) {\n        // look for procedure\n        let proc = this.procedure(scope); // check if defining a procedure or calling it\n\n        let next = this.current_token;\n\n        if (next.type == TokenType.assign || next.type == TokenType.define) {\n          return this.procedure_definition(proc, scope);\n        } else {\n          return proc;\n        }\n      } else {\n        // variable identifier\n        return this.variable(scope);\n      }\n    }\n\n    return new EmptyNode();\n  }\n  /**\n   * a primitive alphanumeric type like boolean\n   */\n\n\n  primitive() {\n    let token = this.current_token;\n\n    if (token.type == TokenType.primitive) {\n      if (token.value === Lexer.reserved_keywords[\"true\"].value) {\n        this.eat(TokenType.primitive);\n        return new SingleValueNode(new Logical(true));\n      } else if (token.value === Lexer.reserved_keywords[\"false\"].value) {\n        this.eat(TokenType.primitive);\n        return new SingleValueNode(new Logical(false));\n      }\n    }\n\n    throw new ParsingError(\"unexpected symbol: \" + token.value);\n  }\n  /**\n   * vector : single row matrix\n   */\n\n\n  vector() {\n    // check left arrow\n    this.eat(TokenType.larrow); // get one row\n\n    let row = this.matrix_row(TokenType.rarrow); // check right arrow\n\n    this.eat(TokenType.rarrow);\n    return new UnevaluatedMatrix([row]);\n  }\n  /**\n   * matrix :  lbracket (row ;)* (row ]) rbracket\n   */\n\n\n  matrix() {\n    let arr = new Array(); // check left bracket\n\n    this.eat(TokenType.lbracket, \"parsing matrix: \"); // loop through rows\n\n    while (this.current_token.type != TokenType.rbracket) {\n      let row = this.matrix_row(TokenType.rbracket);\n      arr.push(row);\n\n      if (this.current_token.type == TokenType.semicolon) {\n        this.eat(TokenType.semicolon, \"parsing matrix row: \");\n      }\n    } // check right bracket\n\n\n    this.eat(TokenType.rbracket, \"parsing matrix: \");\n    return new UnevaluatedMatrix(arr);\n  }\n  /**\n   * row : (factor,)*\n   */\n\n\n  matrix_row(endToken) {\n    let arr = new Array();\n\n    while (true) {\n      let val = this.expr(false, VariableScope.global); // make sure the element is computable\n\n      if (isComputableNode(val)) {\n        // everything else is good, push element into row\n        arr.push(val); // if row hasn't reached end, consume 'comma' separator\n\n        if (this.current_token.type != TokenType.semicolon && this.current_token.type != endToken) {\n          if (this.current_token.type == TokenType.comma) {\n            this.eat(TokenType.comma, \"parsing matrix row: \");\n          }\n        } else {\n          break;\n        }\n      } else {\n        throw new MatrixError(\"matrix parsing error: expected a numeric element\");\n      }\n    }\n\n    return arr;\n  }\n  /**\n   * consume token and advance to next token\n   * @param type token type to verify\n   */\n\n\n  eat(type, message) {\n    if (this.current_token.type == type) {\n      // if expected token type and current token type matches, proceed to next token\n      this.current_token = this.lexer.next_token();\n    } else {\n      // if token type does not match, a syntax error has happened\n      throw new SyntaxError(message || \"\" + \"expected \" + type.toString() + \", but got \" + this.current_token.type.toString());\n    }\n  }\n  /**\n   * variable : id\n   */\n\n\n  variable(scope = VariableScope.global) {\n    if (isSymbolToken(this.current_token)) {\n      let node = new VariableNode(this.current_token, scope);\n      this.eat(TokenType.id);\n      return node;\n    }\n\n    throw new SymbolError(\"couldn't parse variable name\");\n  }\n  /**\n   * program : compound eof\n   */\n\n\n  program() {\n    let node = this.compound(VariableScope.global);\n    this.eat(TokenType.eof);\n    return node;\n  }\n  /**\n   * compound: statement_list\n   */\n\n\n  compound(scope) {\n    return new CompoundNode(this.statement_list(scope));\n  }\n\n  ignoreNewLines() {\n    // ignore all end lines\n    while (this.current_token.type === TokenType.endl) {\n      this.eat(TokenType.endl);\n    }\n  }\n  /**\n   * statement_list : statement | statement endl statement_list\n   */\n\n\n  statement_list(scope) {\n    this.ignoreNewLines();\n    let results = this.statement(scope);\n\n    while (this.current_token.type == TokenType.endl) {\n      this.ignoreNewLines();\n      results = results.concat(this.statement(scope));\n    }\n\n    if (this.current_token.type == TokenType.id) {\n      throw new SyntaxError(\"unexpected identifier\");\n    }\n\n    return results;\n  }\n  /**\n   * statement : id_statement | expr\n   */\n\n\n  statement(scope = VariableScope.global) {\n    if (this.current_token.type == TokenType.id) {\n      return this.id_statement(scope);\n    } else if (this.current_token.type == TokenType.reserved) {\n      return this.reserved_statement();\n    } else if (this.current_token.type != TokenType.eof) {\n      return [this.expr(true, scope)];\n    } else {\n      return [];\n    }\n  }\n\n  reserved_statement() {\n    let token = this.current_token;\n    throw new ParsingError(\"unexpected reserve word\");\n  }\n  /**\n   * create a user defined procedure\n   * @param proc\n   */\n\n\n  procedure_definition(proc, currentScope) {\n    if (currentScope == VariableScope.procedure) {\n      throw new ParsingError(\"nested functions aren't supported!\");\n    }\n\n    this.eat(this.current_token.type); // make sure all of the parameters are variables\n\n    let args = proc.args;\n\n    if (VariableNode.isVariableArray(args)) {\n      // change scope of variables\n      for (let arg of args) {\n        arg.scope = VariableScope.procedure;\n      } // load expressions\n\n\n      if (this.current_token.type == TokenType.lbrace) {\n        // multi line statements\n        this.eat(TokenType.lbrace); // @ts-ignore ignore the stupid if check since current_token changes in this.eat()\n\n        let exprs = this.compound(VariableScope.procedure);\n        this.eat(TokenType.rbrace);\n        return new ProcedureDefinitionNode(proc.name, args, exprs);\n      } else {\n        // single line expression\n        let expr = this.expr(true, VariableScope.procedure);\n        return new ProcedureDefinitionNode(proc.name, args, new CompoundNode([expr]));\n      }\n    } else {\n      throw new ParsingError(\"cannot define a function with non-variable parameters\");\n    }\n  }\n  /**\n   * id_statement : assignemnt | procedure | expr\n   */\n\n\n  id_statement(scope) {\n    let token = this.current_token;\n\n    if (token.type == TokenType.id) {\n      if (this.lexer.peekToken().type == TokenType.assign) {\n        return this.assignment(scope);\n      } else {\n        return [this.expr(true, scope)];\n      }\n    }\n\n    throw new ParsingError(\"couldn't find an identifier!\");\n  }\n  /**\n   * assignment : (variable = expr) (,variable = expr)*\n   */\n\n\n  assignment(scope) {\n    let left = this.variable(scope);\n    let token = this.current_token;\n    this.eat(TokenType.assign, \"parsing assignment: \");\n    let right = this.expr(true, scope);\n    let assignments = [new AssignNode(left, token, right)]; //  check if multiline assignment\n\n    if (this.current_token.type == TokenType.comma) {\n      this.eat(TokenType.comma);\n      let next = this.assignment(scope);\n      assignments = assignments.concat(next);\n    }\n\n    return assignments;\n  }\n  /**\n   * procedure : id lparen (expr,)* rparen\n   */\n\n\n  procedure(scope) {\n    let token = this.current_token;\n\n    if (!isSymbolToken(token)) {\n      throw new SymbolError(\"expected an identifier symbol but didn't get it!\");\n    }\n\n    this.eat(TokenType.id);\n    this.eat(TokenType.lparen);\n    let args = [];\n\n    while (this.current_token.type != TokenType.rparen) {\n      args.push(this.expr(true, scope));\n\n      if (this.current_token.type == TokenType.comma) {\n        this.eat(TokenType.comma);\n      } else {\n        break;\n      }\n    }\n\n    this.eat(TokenType.rparen);\n    return new ProcedureCallNode(token, args);\n  }\n\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/mathscript/app/src/interpreter/parser.ts"],"names":["AssignNode","BinaryOperatorNode","CompoundNode","isComputableNode","SingleValueNode","UnaryOperatorNode","VariableNode","ProcedureCallNode","VariableScope","ProcedureDefinitionNode","EmptyNode","TernaryOperator","Numeric","Logical","UnevaluatedMatrix","MatrixError","ParsingError","SymbolError","SyntaxError","Lexer","TokenType","isNumericToken","isSymbolToken","Parser","constructor","lexer","current_token","next_token","parse","node","program","type","eof","expr","ignoreWhiteSpace","scope","opsOrder","tokens","pow","igws","modulo","mul","div","rdiv","plus","minus","and","or","larrow","rarrow","eq","not_bool","less_eq","more_eq","and_bool","or_bool","func","factor","op","binops","call","ternary","eat","t","colon","f","operators","token","includes","peek","not","num","value","lparen","rparen","lbracket","matrix","vector","primitive","id","next","peekToken","proc","procedure","assign","define","procedure_definition","variable","reserved_keywords","row","matrix_row","arr","Array","rbracket","push","semicolon","endToken","val","global","comma","message","toString","compound","statement_list","ignoreNewLines","endl","results","statement","concat","id_statement","reserved","reserved_statement","currentScope","args","isVariableArray","arg","lbrace","exprs","rbrace","name","assignment","left","right","assignments"],"mappings":"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","sourcesContent":["import {\n  AssignNode,\n  AST,\n  BinaryOperatorNode,\n  CompoundNode,\n  ComputableNode,\n  isComputableNode,\n  SingleValueNode,\n  UnaryOperatorNode,\n  VariableNode,\n  ProcedureCallNode,\n  VariableScope,\n  ProcedureDefinitionNode,\n  EmptyNode,\n  TernaryOperator,\n} from \"./ast\";\nimport { Numeric, Logical, UnevaluatedMatrix } from \"./computable\";\nimport { MatrixError, ParsingError, SymbolError, SyntaxError } from \"./errors\";\nimport { Lexer } from \"./lexer\";\nimport { TokenType, Token, isNumericToken, isSymbolToken } from \"./token\";\n\ninterface Operation {\n  tokens: TokenType[];\n  igws: boolean;\n  scope: VariableScope;\n}\nexport class Parser {\n  private lexer: Lexer;\n  private current_token: Token;\n\n  constructor(lexer: Lexer) {\n    this.lexer = lexer;\n    this.current_token = this.lexer.next_token();\n  }\n\n  /**\n   * parse tokens into an abstract syntax tree for traversal\n   */\n  public parse(): AST {\n    let node = this.program();\n    if (this.current_token.type != TokenType.eof) {\n      throw new SyntaxError(\"parsing didn't go as expected!\");\n    }\n    return node;\n  }\n\n  /**\n   * identify expression\n   * expr   : term ((PLUS | MINUS) term)* | term ((PLUS | MINUS)term)*\n   * term   : powers ((MUL | DIV ) powers)*\n   * powers : factor ((POW) factor)*\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix | variable | procedure | (TRUE | FALSE)\n   * matrix :  lbracket (row)* rbracket\n   */\n  private expr(ignoreWhiteSpace: boolean, scope: VariableScope): AST {\n    let opsOrder: Operation[] = [\n      {\n        tokens: [TokenType.pow],\n        igws: ignoreWhiteSpace,\n        scope: scope,\n      },\n      {\n        tokens: [TokenType.modulo],\n        igws: ignoreWhiteSpace,\n        scope: scope,\n      },\n      {\n        tokens: [TokenType.mul, TokenType.div, TokenType.rdiv],\n        igws: true,\n        scope: scope,\n      },\n      {\n        tokens: [TokenType.plus, TokenType.minus],\n        igws: ignoreWhiteSpace,\n        scope: scope,\n      },\n      {\n        tokens: [TokenType.and, TokenType.or],\n        igws: ignoreWhiteSpace,\n        scope: scope,\n      },\n      {\n        tokens: [\n          TokenType.larrow,\n          TokenType.rarrow,\n          TokenType.eq,\n          TokenType.not_bool,\n          TokenType.less_eq,\n          TokenType.more_eq,\n        ],\n        igws: ignoreWhiteSpace,\n        scope: scope,\n      },\n      { tokens: [TokenType.and_bool], igws: true, scope: scope },\n      { tokens: [TokenType.or_bool], igws: true, scope: scope },\n    ];\n    let func = this.factor;\n    for (let op of opsOrder) {\n      func = this.binops(func, op.tokens, op.igws);\n    }\n    let expr = func.call(this, scope);\n\n    // if ? ternary operation, otherwise return\n    if (this.current_token.type == TokenType.ternary) {\n      this.eat(TokenType.ternary);\n      let t = this.expr(ignoreWhiteSpace, scope);\n      this.eat(TokenType.colon);\n      let f = this.expr(ignoreWhiteSpace, scope);\n      return new TernaryOperator(expr, t, f);\n    }\n    return expr;\n  }\n\n  /**\n   *\n   * @param func\n   * @param operators\n   * @param ignoreWhiteSpace\n   */\n  private binops(\n    func: (scope: VariableScope) => AST,\n    operators: TokenType[],\n    ignoreWhiteSpace: boolean = true\n  ) {\n    return (scope: VariableScope): AST => {\n      // left node\n      let node: AST = func.call(this, scope);\n      let token: Token = this.current_token;\n      while (operators.includes(token.type)) {\n        if (\n          ignoreWhiteSpace ||\n          this.lexer.peek(1) == \" \" ||\n          this.lexer.peek(-1) != \" \"\n        ) {\n          this.eat(token.type);\n          node = new BinaryOperatorNode(node, token, func.call(this, scope));\n          token = this.current_token;\n        } else {\n          return node;\n        }\n      }\n      return node;\n    };\n  }\n\n  /**\n   * identify factor\n   * factor : (PLUS | MINUS) factor | NUMBER | lparen expr rparen | matrix\n   * matrix :  lbracket (row)* rbracket\n   * @return abstract syntax node\n   */\n  private factor(scope: VariableScope): AST {\n    let token = this.current_token;\n    if (token.type == TokenType.plus) {\n      // positive sign\n      this.eat(TokenType.plus);\n      return new UnaryOperatorNode(token, this.factor(scope));\n    } else if (token.type == TokenType.minus) {\n      // negation sign\n      this.eat(TokenType.minus);\n      return new UnaryOperatorNode(token, this.factor(scope));\n    } else if (token.type == TokenType.not) {\n      this.eat(TokenType.not);\n      return new UnaryOperatorNode(token, this.factor(scope));\n    } else if (isNumericToken(token)) {\n      // token is a number\n      this.eat(TokenType.num);\n      return new SingleValueNode(new Numeric(token.value));\n    } else if (token.type == TokenType.lparen) {\n      // lparen expr rparen\n      this.eat(TokenType.lparen);\n      let node: AST = this.expr(true, scope);\n      this.eat(TokenType.rparen);\n      return node;\n    } else if (token.type == TokenType.lbracket) {\n      // matrix\n      return new SingleValueNode(this.matrix());\n    } else if (token.type == TokenType.larrow) {\n      // vector (meaning single row matrix)\n      return new SingleValueNode(this.vector());\n    } else if (token.type == TokenType.primitive) {\n      return this.primitive();\n    } else if (token.type == TokenType.id) {\n      // identifier\n      let next = this.lexer.peekToken();\n      if (next.type == TokenType.lparen) {\n        // look for procedure\n        let proc = this.procedure(scope);\n        // check if defining a procedure or calling it\n        let next: Token = this.current_token;\n        if (next.type == TokenType.assign || next.type == TokenType.define) {\n          return this.procedure_definition(proc, scope);\n        } else {\n          return proc;\n        }\n      } else {\n        // variable identifier\n        return this.variable(scope);\n      }\n    }\n\n    return new EmptyNode();\n  }\n\n  /**\n   * a primitive alphanumeric type like boolean\n   */\n  private primitive(): AST {\n    let token = this.current_token;\n    if (token.type == TokenType.primitive) {\n      if (token.value === Lexer.reserved_keywords[\"true\"].value) {\n        this.eat(TokenType.primitive);\n        return new SingleValueNode(new Logical(true));\n      } else if (token.value === Lexer.reserved_keywords[\"false\"].value) {\n        this.eat(TokenType.primitive);\n        return new SingleValueNode(new Logical(false));\n      }\n    }\n    throw new ParsingError(\"unexpected symbol: \" + token.value);\n  }\n  /**\n   * vector : single row matrix\n   */\n  private vector(): UnevaluatedMatrix {\n    // check left arrow\n    this.eat(TokenType.larrow);\n    // get one row\n    let row = this.matrix_row(TokenType.rarrow);\n    // check right arrow\n    this.eat(TokenType.rarrow);\n    return new UnevaluatedMatrix([row]);\n  }\n\n  /**\n   * matrix :  lbracket (row ;)* (row ]) rbracket\n   */\n  private matrix(): UnevaluatedMatrix {\n    let arr: ComputableNode[][] = new Array();\n    // check left bracket\n    this.eat(TokenType.lbracket, \"parsing matrix: \");\n    // loop through rows\n    while (this.current_token.type != TokenType.rbracket) {\n      let row = this.matrix_row(TokenType.rbracket);\n      arr.push(row);\n      if (this.current_token.type == TokenType.semicolon) {\n        this.eat(TokenType.semicolon, \"parsing matrix row: \");\n      }\n    }\n    // check right bracket\n    this.eat(TokenType.rbracket, \"parsing matrix: \");\n    return new UnevaluatedMatrix(arr);\n  }\n\n  /**\n   * row : (factor,)*\n   */\n  private matrix_row(endToken: TokenType): ComputableNode[] {\n    let arr: ComputableNode[] = new Array();\n\n    while (true) {\n      let val = this.expr(false, VariableScope.global);\n      // make sure the element is computable\n      if (isComputableNode(val)) {\n        // everything else is good, push element into row\n        arr.push(val);\n        // if row hasn't reached end, consume 'comma' separator\n        if (\n          this.current_token.type != TokenType.semicolon &&\n          this.current_token.type != endToken\n        ) {\n          if (this.current_token.type == TokenType.comma) {\n            this.eat(TokenType.comma, \"parsing matrix row: \");\n          }\n        } else {\n          break;\n        }\n      } else {\n        throw new MatrixError(\n          \"matrix parsing error: expected a numeric element\"\n        );\n      }\n    }\n\n    return arr;\n  }\n\n  /**\n   * consume token and advance to next token\n   * @param type token type to verify\n   */\n  private eat(type: TokenType, message?: string) {\n    if (this.current_token.type == type) {\n      // if expected token type and current token type matches, proceed to next token\n      this.current_token = this.lexer.next_token();\n    } else {\n      // if token type does not match, a syntax error has happened\n      throw new SyntaxError(\n        message ||\n          \"\" +\n            \"expected \" +\n            type.toString() +\n            \", but got \" +\n            this.current_token.type.toString()\n      );\n    }\n  }\n\n  /**\n   * variable : id\n   */\n  private variable(scope: VariableScope = VariableScope.global): VariableNode {\n    if (isSymbolToken(this.current_token)) {\n      let node = new VariableNode(this.current_token, scope);\n      this.eat(TokenType.id);\n      return node;\n    }\n    throw new SymbolError(\"couldn't parse variable name\");\n  }\n\n  /**\n   * program : compound eof\n   */\n  private program(): AST {\n    let node = this.compound(VariableScope.global);\n    this.eat(TokenType.eof);\n    return node;\n  }\n\n  /**\n   * compound: statement_list\n   */\n  private compound(scope: VariableScope): CompoundNode {\n    return new CompoundNode(this.statement_list(scope));\n  }\n\n  private ignoreNewLines() {\n    // ignore all end lines\n    while (this.current_token.type === TokenType.endl) {\n      this.eat(TokenType.endl);\n    }\n  }\n\n  /**\n   * statement_list : statement | statement endl statement_list\n   */\n  private statement_list(scope: VariableScope): AST[] {\n    this.ignoreNewLines();\n    let results = this.statement(scope);\n    while (this.current_token.type == TokenType.endl) {\n      this.ignoreNewLines();\n      results = results.concat(this.statement(scope));\n    }\n\n    if (this.current_token.type == TokenType.id) {\n      throw new SyntaxError(\"unexpected identifier\");\n    }\n\n    return results;\n  }\n\n  /**\n   * statement : id_statement | expr\n   */\n  private statement(scope: VariableScope = VariableScope.global): AST[] {\n    if (this.current_token.type == TokenType.id) {\n      return this.id_statement(scope);\n    } else if (this.current_token.type == TokenType.reserved) {\n      return this.reserved_statement();\n    } else if (this.current_token.type != TokenType.eof) {\n      return [this.expr(true, scope)];\n    } else {\n      return [];\n    }\n  }\n\n  private reserved_statement(): AST[] {\n    let token = this.current_token;\n    throw new ParsingError(\"unexpected reserve word\");\n  }\n\n  /**\n   * create a user defined procedure\n   * @param proc\n   */\n  private procedure_definition(\n    proc: ProcedureCallNode,\n    currentScope: VariableScope\n  ): ProcedureDefinitionNode {\n    if (currentScope == VariableScope.procedure) {\n      throw new ParsingError(\"nested functions aren't supported!\");\n    }\n    this.eat(this.current_token.type);\n    // make sure all of the parameters are variables\n    let args = proc.args;\n    if (VariableNode.isVariableArray(args)) {\n      // change scope of variables\n      for (let arg of args) {\n        arg.scope = VariableScope.procedure;\n      }\n      // load expressions\n      if (this.current_token.type == TokenType.lbrace) {\n        // multi line statements\n        this.eat(TokenType.lbrace);\n        // @ts-ignore ignore the stupid if check since current_token changes in this.eat()\n\n        let exprs = this.compound(VariableScope.procedure);\n        this.eat(TokenType.rbrace);\n        return new ProcedureDefinitionNode(proc.name, args, exprs);\n      } else {\n        // single line expression\n        let expr = this.expr(true, VariableScope.procedure);\n        return new ProcedureDefinitionNode(\n          proc.name,\n          args,\n          new CompoundNode([expr])\n        );\n      }\n    } else {\n      throw new ParsingError(\n        \"cannot define a function with non-variable parameters\"\n      );\n    }\n  }\n\n  /**\n   * id_statement : assignemnt | procedure | expr\n   */\n  private id_statement(scope: VariableScope): AST[] {\n    let token = this.current_token;\n    if (token.type == TokenType.id) {\n      if (this.lexer.peekToken().type == TokenType.assign) {\n        return this.assignment(scope);\n      } else {\n        return [this.expr(true, scope)];\n      }\n    }\n\n    throw new ParsingError(\"couldn't find an identifier!\");\n  }\n\n  /**\n   * assignment : (variable = expr) (,variable = expr)*\n   */\n  private assignment(scope: VariableScope): AssignNode[] {\n    let left = this.variable(scope);\n    let token = this.current_token;\n    this.eat(TokenType.assign, \"parsing assignment: \");\n    let right = this.expr(true, scope);\n    let assignments = [new AssignNode(left, token, right)];\n    //  check if multiline assignment\n    if (this.current_token.type == TokenType.comma) {\n      this.eat(TokenType.comma);\n      let next = this.assignment(scope);\n      assignments = assignments.concat(next);\n    }\n    return assignments;\n  }\n\n  /**\n   * procedure : id lparen (expr,)* rparen\n   */\n  private procedure(scope: VariableScope): ProcedureCallNode {\n    let token = this.current_token;\n    if (!isSymbolToken(token)) {\n      throw new SymbolError(\"expected an identifier symbol but didn't get it!\");\n    }\n    this.eat(TokenType.id);\n    this.eat(TokenType.lparen);\n    let args = [];\n    while (this.current_token.type != TokenType.rparen) {\n      args.push(this.expr(true, scope));\n      if (this.current_token.type == TokenType.comma) {\n        this.eat(TokenType.comma);\n      } else {\n        break;\n      }\n    }\n    this.eat(TokenType.rparen);\n    return new ProcedureCallNode(token, args);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}