{"ast":null,"code":"import { clearScopes } from \"./global\";\nimport { Lexer } from \"./lexer\";\nimport { Parser } from \"./parser\";\nexport class Interpreter {\n  constructor(parser) {\n    this.parser = void 0;\n    this.parser = parser;\n  }\n\n  interpret() {\n    let tree = this.parser.parse();\n    return tree.eval();\n  }\n\n}\n/**\n * interpret source code and output result\n * @param text raw input text\n */\n\nexport function interpretSource(text) {\n  clearScopes();\n  let lexer = new Lexer(text);\n  let parser = new Parser(lexer);\n  let interpreter = new Interpreter(parser);\n\n  try {\n    return interpreter.interpret();\n  } catch (exception) {\n    return exception.message;\n  }\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/mathscript/app/src/interpreter/interpreter.ts"],"names":["clearScopes","Lexer","Parser","Interpreter","constructor","parser","interpret","tree","parse","eval","interpretSource","text","lexer","interpreter","exception","message"],"mappings":"AACA,SAASA,WAAT,QAA4B,UAA5B;AACA,SAASC,KAAT,QAAsB,SAAtB;AACA,SAASC,MAAT,QAAuB,UAAvB;AAEA,OAAO,MAAMC,WAAN,CAAkB;AAGvBC,EAAAA,WAAW,CAACC,MAAD,EAAiB;AAAA,SAFpBA,MAEoB;AAC1B,SAAKA,MAAL,GAAcA,MAAd;AACD;;AAEMC,EAAAA,SAAP,GAA0B;AACxB,QAAIC,IAAS,GAAG,KAAKF,MAAL,CAAYG,KAAZ,EAAhB;AACA,WAAOD,IAAI,CAACE,IAAL,EAAP;AACD;;AAVsB;AAazB;;;;;AAIA,OAAO,SAASC,eAAT,CAAyBC,IAAzB,EAAuD;AAC5DX,EAAAA,WAAW;AACX,MAAIY,KAAK,GAAG,IAAIX,KAAJ,CAAUU,IAAV,CAAZ;AACA,MAAIN,MAAM,GAAG,IAAIH,MAAJ,CAAWU,KAAX,CAAb;AACA,MAAIC,WAAW,GAAG,IAAIV,WAAJ,CAAgBE,MAAhB,CAAlB;;AACA,MAAI;AACF,WAAOQ,WAAW,CAACP,SAAZ,EAAP;AACD,GAFD,CAEE,OAAOQ,SAAP,EAAkB;AAClB,WAAOA,SAAS,CAACC,OAAjB;AACD;AACF","sourcesContent":["import { AST } from \"./ast\";\nimport { clearScopes } from \"./global\";\nimport { Lexer } from \"./lexer\";\nimport { Parser } from \"./parser\";\n\nexport class Interpreter {\n  private parser: Parser;\n\n  constructor(parser: Parser) {\n    this.parser = parser;\n  }\n\n  public interpret(): any[] {\n    let tree: AST = this.parser.parse();\n    return tree.eval();\n  }\n}\n\n/**\n * interpret source code and output result\n * @param text raw input text\n */\nexport function interpretSource(text: string): any[] | string {\n  clearScopes();\n  let lexer = new Lexer(text);\n  let parser = new Parser(lexer);\n  let interpreter = new Interpreter(parser);\n  try {\n    return interpreter.interpret();\n  } catch (exception) {\n    return exception.message;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}