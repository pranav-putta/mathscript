{"ast":null,"code":"import { VariableScope } from \"./ast\";\nimport { ParsingError, RuntimeError } from \"./errors\";\nimport { rref, transpose, det, sqrt, identity } from \"./lib\";\nexport let global_scope = {};\nexport let global_functions = {\n  rref: rref,\n  trans: transpose,\n  transpose: transpose,\n  det: det,\n  determinant: det,\n  q: sqrt,\n  sqrt: sqrt,\n  identity: identity\n};\nexport let local_functions = {};\nexport let function_stack;\nexport function findVariable(name, scope) {\n  let val = undefined;\n\n  if (scope == VariableScope.global) {\n    val = global_scope[name];\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n\n    if (currentBlock) {\n      val = currentBlock.variables[name];\n    } else {\n      throw new RuntimeError(\"function call stack was empty, something weird happened.\");\n    }\n  }\n\n  if (val) {\n    return val;\n  } else {\n    throw new RuntimeError(`variable ${name} wasn't declared!`);\n  }\n}\nexport function setVariable(name, value, scope) {\n  if (scope == VariableScope.global) {\n    global_scope[name] = value;\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n\n    if (currentBlock) {\n      currentBlock.variables[name] = value;\n    } else {\n      throw new RuntimeError(\"function call stack was empty, something weird happened\");\n    }\n  }\n}\n\nfunction executeLocalFunction(func) {\n  function_stack.push({\n    functionName: func.name,\n    variables: []\n  });\n  let out;\n\n  for (let statement of func.exprs) {\n    out = statement.eval();\n  }\n\n  function_stack.pop();\n  return out;\n}\n\nexport function executeFunction(f, args) {\n  if (f in global_functions) {\n    let func = global_functions[f];\n    let params = [];\n\n    for (let arg of args) {\n      params.push(arg.eval());\n    }\n\n    return func.apply(null, params);\n  } else if (f in local_functions) {\n    executeLocalFunction(local_functions[f]);\n  } else {\n    throw new ParsingError(`function ${f} couldn't be found`);\n  }\n}\nexport function createUserDefinedFunction(func) {\n  if (func.name in global_functions) {\n    throw new ParsingError(\"conflicting function definition name: \" + func.name);\n  }\n\n  local_functions[func.name] = func;\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/app/src/interpreter/global.ts"],"names":["VariableScope","ParsingError","RuntimeError","rref","transpose","det","sqrt","identity","global_scope","global_functions","trans","determinant","q","local_functions","function_stack","findVariable","name","scope","val","undefined","global","procedure","currentBlock","peek","variables","setVariable","value","executeLocalFunction","func","push","functionName","out","statement","exprs","eval","pop","executeFunction","f","args","params","arg","apply","createUserDefinedFunction"],"mappings":"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","sourcesContent":["import { AST, ProcedureDefinitionNode, VariableScope } from \"./ast\";\nimport { Computable } from \"./computable\";\nimport { ParsingError, RuntimeError } from \"./errors\";\nimport { rref, transpose, det, sqrt, identity } from \"./lib\";\nimport { Stack } from \"./util\";\n\ntype Function = (...args: any[]) => any;\n\ninterface Variables {\n  [key: string]: any;\n}\ninterface GlobalProcedures {\n  [key: string]: Function;\n}\ninterface LocalProcedures {\n  [key: string]: ProcedureDefinitionNode;\n}\ninterface FunctionBlock {\n  functionName: string;\n  variables: Variables;\n}\n\nexport let global_scope: Variables = {};\nexport let global_functions: GlobalProcedures = {\n  rref: rref,\n  trans: transpose,\n  transpose: transpose,\n  det: det,\n  determinant: det,\n  q: sqrt,\n  sqrt: sqrt,\n  identity: identity,\n};\nexport let local_functions: LocalProcedures = {};\nexport let function_stack: Stack<FunctionBlock>;\n\nexport function findVariable(\n  name: string,\n  scope: VariableScope\n): any | undefined {\n  let val = undefined;\n  if (scope == VariableScope.global) {\n    val = global_scope[name];\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n    if (currentBlock) {\n      val = currentBlock.variables[name];\n    } else {\n      throw new RuntimeError(\n        \"function call stack was empty, something weird happened.\"\n      );\n    }\n  }\n  if (val) {\n    return val;\n  } else {\n    throw new RuntimeError(`variable ${name} wasn't declared!`);\n  }\n}\n\nexport function setVariable(name: string, value: any, scope: VariableScope) {\n  if (scope == VariableScope.global) {\n    global_scope[name] = value;\n  } else if (scope == VariableScope.procedure) {\n    let currentBlock = function_stack.peek();\n    if (currentBlock) {\n      currentBlock.variables[name] = value;\n    } else {\n      throw new RuntimeError(\n        \"function call stack was empty, something weird happened\"\n      );\n    }\n  }\n}\n\nfunction executeLocalFunction(func: ProcedureDefinitionNode) {\n  function_stack.push({ functionName: func.name, variables: [] });\n  let out: any;\n  for (let statement of func.exprs) {\n    out = statement.eval();\n  }\n  function_stack.pop();\n  return out;\n}\n\nexport function executeFunction(f: string, args: AST[]) {\n  if (f in global_functions) {\n    let func = global_functions[f];\n    let params: Computable[] = [];\n    for (let arg of args) {\n      params.push(arg.eval());\n    }\n    return func.apply(null, params);\n  } else if (f in local_functions) {\n    executeLocalFunction(local_functions[f]);\n  } else {\n    throw new ParsingError(`function ${f} couldn't be found`);\n  }\n}\n\nexport function createUserDefinedFunction(func: ProcedureDefinitionNode) {\n  if (func.name in global_functions) {\n    throw new ParsingError(\n      \"conflicting function definition name: \" + func.name\n    );\n  }\n  local_functions[func.name] = func;\n}\n"]},"metadata":{},"sourceType":"module"}