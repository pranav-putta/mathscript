{"ast":null,"code":"import { isMatrix, isNumeric, Matrix, Numeric } from \"../computable\";\nimport { ArgumentError } from \"../errors\";\n/**\n * takes rref and stores into matrix\n * @param node\n */\n\nexport function rref(matrix) {\n  if (isMatrix(matrix)) {\n    var lead = 0;\n\n    for (var k = 0; k < matrix.dimR; k++) {\n      if (matrix.dimC <= lead) return matrix;\n      var i = k;\n\n      while (matrix.matrix[i][lead] === 0) {\n        i++;\n\n        if (matrix.dimR === i) {\n          i = k;\n          lead++;\n          if (matrix.dimC === lead) return matrix;\n        }\n      }\n\n      var irow = matrix.matrix[i],\n          krow = matrix.matrix[k];\n      matrix.matrix[i] = krow;\n      matrix.matrix[k] = irow;\n      var val = matrix.matrix[k][lead];\n\n      for (var j = 0; j < matrix.dimC; j++) {\n        matrix.matrix[k][j] /= val;\n      }\n\n      for (var i = 0; i < matrix.dimR; i++) {\n        if (i === k) continue;\n        val = matrix.matrix[i][lead];\n\n        for (var j = 0; j < matrix.dimC; j++) {\n          matrix.matrix[i][j] -= val * matrix.matrix[k][j];\n        }\n      }\n\n      lead++;\n    }\n\n    return matrix;\n  } else {\n    throw new ArgumentError(\"expected a matrix. \" + matrix);\n  }\n}\n/**\n * takes transpose and stores into matrix\n * @param node\n */\n\nexport function transpose(matrix) {\n  if (isMatrix(matrix)) {\n    return matrix.transpose(true).result;\n  } else {\n    throw new ArgumentError(\"expected a matrix\");\n  }\n}\n/**\n * takes determinant\n * @param node\n */\n\nexport function det(matrix) {\n  if (isMatrix(matrix)) {\n    return matrix.determinant();\n  } else {\n    throw new ArgumentError(\"expected a matrix\");\n  }\n}\nexport function sqrt(num) {\n  if (isNumeric(num)) {\n    return num.pow(new Numeric(0.5)).result;\n  } else {\n    throw new ArgumentError(\"expected a number\");\n  }\n}\nexport function identity(num) {\n  if (isNumeric(num)) {\n    let arr = [];\n\n    for (let i = 0; i < num.value; i++) {\n      arr.push([]);\n\n      for (let j = 0; j < num.value; j++) {\n        arr[i].push(i == j ? 1 : 0);\n      }\n    }\n\n    return new Matrix(arr);\n  } else {\n    throw new ArgumentError(\"expected a number\");\n  }\n}\n\nfunction rationalApprox(t) {\n  let c = [2.515517, 0.802853, 0.010328];\n  let d = [1.432788, 0.189269, 0.001308];\n  return t - ((c[2] * t + c[1]) * t + c[0]) / (((d[2] * t + d[1]) * t + d[0]) * t + 1.0);\n}\n\nfunction invNormCDF(p) {\n  if (p < 0.5) {\n    return -rationalApprox(Math.sqrt(-2 * Math.log(p)));\n  } else {\n    return -rationalApprox(Math.sqrt(-2 * Math.log(1 - p)));\n  }\n}\n\nexport function confidenceIntervalProportions(p, n, ci) {\n  let prob = p => {\n    return (1 - p) / 2 + p;\n  };\n\n  let z = invNormCDF(prob(ci.value));\n  let r = z * Math.sqrt(p.value * (1 - p.value) / n.value);\n  return [Math.round((p.value + r) * 1000) / 1000, Math.round((p.value - r) * 1000) / 1000];\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/mathscript/app/src/interpreter/lib/functions.ts"],"names":["isMatrix","isNumeric","Matrix","Numeric","ArgumentError","rref","matrix","lead","k","dimR","dimC","i","irow","krow","val","j","transpose","result","det","determinant","sqrt","num","pow","identity","arr","value","push","rationalApprox","t","c","d","invNormCDF","p","Math","log","confidenceIntervalProportions","n","ci","prob","z","r","round"],"mappings":"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","sourcesContent":["import { AST } from \"../ast\";\nimport { isMatrix, isNumeric, Matrix, Numeric } from \"../computable\";\nimport { ArgumentError, ParsingError } from \"../errors\";\n\n/**\n * takes rref and stores into matrix\n * @param node\n */\nexport function rref(matrix: Matrix) {\n  if (isMatrix(matrix)) {\n    var lead = 0;\n    for (var k = 0; k < matrix.dimR; k++) {\n      if (matrix.dimC <= lead) return matrix;\n\n      var i = k;\n      while (matrix.matrix[i][lead] === 0) {\n        i++;\n        if (matrix.dimR === i) {\n          i = k;\n          lead++;\n          if (matrix.dimC === lead) return matrix;\n        }\n      }\n      var irow = matrix.matrix[i],\n        krow = matrix.matrix[k];\n      matrix.matrix[i] = krow;\n      matrix.matrix[k] = irow;\n\n      var val = matrix.matrix[k][lead];\n      for (var j = 0; j < matrix.dimC; j++) {\n        matrix.matrix[k][j] /= val;\n      }\n\n      for (var i = 0; i < matrix.dimR; i++) {\n        if (i === k) continue;\n        val = matrix.matrix[i][lead];\n        for (var j = 0; j < matrix.dimC; j++) {\n          matrix.matrix[i][j] -= val * matrix.matrix[k][j];\n        }\n      }\n      lead++;\n    }\n    return matrix;\n  } else {\n    throw new ArgumentError(\"expected a matrix. \" + matrix);\n  }\n}\n\n/**\n * takes transpose and stores into matrix\n * @param node\n */\nexport function transpose(matrix: Matrix) {\n  if (isMatrix(matrix)) {\n    return matrix.transpose(true).result;\n  } else {\n    throw new ArgumentError(\"expected a matrix\");\n  }\n}\n\n/**\n * takes determinant\n * @param node\n */\nexport function det(matrix: Matrix) {\n  if (isMatrix(matrix)) {\n    return matrix.determinant();\n  } else {\n    throw new ArgumentError(\"expected a matrix\");\n  }\n}\n\nexport function sqrt(num: Numeric) {\n  if (isNumeric(num)) {\n    return num.pow(new Numeric(0.5)).result;\n  } else {\n    throw new ArgumentError(\"expected a number\");\n  }\n}\n\nexport function identity(num: Numeric): Matrix {\n  if (isNumeric(num)) {\n    let arr: number[][] = [];\n    for (let i = 0; i < num.value; i++) {\n      arr.push([]);\n      for (let j = 0; j < num.value; j++) {\n        arr[i].push(i == j ? 1 : 0);\n      }\n    }\n    return new Matrix(arr);\n  } else {\n    throw new ArgumentError(\"expected a number\");\n  }\n}\n\nfunction rationalApprox(t: number) {\n  let c = [2.515517, 0.802853, 0.010328];\n  let d = [1.432788, 0.189269, 0.001308];\n  return (\n    t -\n    ((c[2] * t + c[1]) * t + c[0]) / (((d[2] * t + d[1]) * t + d[0]) * t + 1.0)\n  );\n}\n\nfunction invNormCDF(p: number) {\n  if (p < 0.5) {\n    return -rationalApprox(Math.sqrt(-2 * Math.log(p)));\n  } else {\n    return -rationalApprox(Math.sqrt(-2 * Math.log(1 - p)));\n  }\n}\n\nexport function confidenceIntervalProportions(\n  p: Numeric,\n  n: Numeric,\n  ci: Numeric\n) {\n  let prob = (p: number) => {\n    return (1 - p) / 2 + p;\n  };\n  let z = invNormCDF(prob(ci.value));\n  let r = z * Math.sqrt((p.value * (1 - p.value)) / n.value);\n  return [\n    Math.round((p.value + r) * 1000) / 1000,\n    Math.round((p.value - r) * 1000) / 1000,\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}