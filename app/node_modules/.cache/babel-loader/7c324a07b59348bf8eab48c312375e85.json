{"ast":null,"code":"import { MatrixError, ParsingError } from \"./errors\";\nexport class AComputable {\n  /**\n   * checks if given element is of type matrix\n   * @param el any element\n   */\n  static isMatrix(el) {\n    return el instanceof Matrix;\n  }\n  /**\n   * checks if given element is of type number\n   * @param el any element\n   */\n\n\n  static isNumeric(el) {\n    return typeof el === \"number\";\n  }\n  /**\n   * checks if given element is of type computable\n   * @param el any element\n   */\n\n\n  static isComputable(el) {\n    return el instanceof AComputable || typeof el === \"number\";\n  }\n\n}\nexport class Matrix extends AComputable {\n  constructor(nodes = new Array(), rows = undefined) {\n    super();\n    this.matrix = void 0;\n    this.nodes = void 0;\n    this.dimR = void 0;\n    this.dimC = void 0;\n\n    if (!rows) {\n      // raw node matrix\n      this.nodes = nodes;\n      this.matrix = undefined;\n      this.dimR = nodes.length;\n      this.dimC = this.dimR > 0 ? nodes[0].length : 0; // verify each row is the same length\n\n      for (let row of nodes) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    } else {\n      // populate matrix with numbers\n      this.nodes = new Array();\n      this.matrix = rows;\n      this.dimR = rows.length;\n      this.dimC = this.dimR > 0 ? rows[0].length : 0; // verify each row is the same length\n\n      for (let row of rows) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    }\n  }\n\n  checkDimensions(other) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(`can't add matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n    }\n  }\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n\n\n  add(other) {\n    if (this.matrix) {\n      let arr = new Array();\n\n      if (AComputable.isMatrix(other) && other.matrix) {\n        // add two matricies together\n        this.checkDimensions(other);\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] + other.matrix[i][j]);\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        // add constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] + other);\n          }\n        }\n      }\n\n      return {\n        result: new Matrix(undefined, arr)\n      };\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n\n\n  sub(other) {\n    if (this.matrix) {\n      let arr = new Array();\n\n      if (AComputable.isMatrix(other) && other.matrix) {\n        // subtract two matricies together\n        this.checkDimensions(other);\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] - other.matrix[i][j]);\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        // subtract constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] - other);\n          }\n        }\n      }\n\n      return {\n        result: new Matrix(undefined, arr)\n      };\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n\n\n  el_mul(other) {\n    if (this.matrix && other.matrix) {\n      if (this.dimC == other.dimC && this.dimR == other.dimR) {\n        let arr = new Array();\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] * other.matrix[i][j]);\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      } else {\n        throw new MatrixError(\"cannot do element-wise multiplication on different sized matricies\");\n      }\n    }\n\n    throw new ParsingError(\"matrix hasn't been evaulated yet!\");\n  }\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n\n\n  mul(other) {\n    if (this.matrix) {\n      if (AComputable.isMatrix(other)) {\n        if (other.matrix) {\n          // multiply two matricies\n          // check dimensions are proper\n          if (this.dimC != other.dimR) {\n            if (this.dimC == other.dimC && this.dimR == other.dimR) {\n              return {\n                result: this.mul(other.transpose().result).result,\n                message: \"inferred to take dot product.\"\n              };\n            }\n\n            throw new MatrixError(`can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n          }\n\n          let newMatrix = new Array();\n\n          for (let i = 0; i < this.dimR; i++) {\n            newMatrix.push([]);\n\n            for (let j = 0; j < other.dimC; j++) {\n              let temp = 0;\n\n              for (let k = 0; k < this.dimC; k++) {\n                temp += this.matrix[i][k] * other.matrix[k][j];\n              }\n\n              newMatrix[i].push(temp);\n            }\n          }\n\n          if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n            return {\n              result: newMatrix[0][0]\n            };\n          } else {\n            return {\n              result: new Matrix(undefined, newMatrix)\n            };\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        let arr = new Array(); // multiply constant to each element\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] * other);\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      } else {\n        throw new MatrixError(\"couldn't multiply with a \" + other);\n      }\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  div(other) {\n    if (this.matrix) {\n      if (AComputable.isNumeric(other)) {\n        let arr = new Array(); // multiply constant to each element\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] / other);\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      }\n\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  rdiv(other) {\n    if (this.matrix) {\n      if (AComputable.isNumeric(other)) {\n        let arr = new Array(); // multiply constant to each element\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(Math.floor(this.matrix[i][j] / other));\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      }\n\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * take power\n   * @param other\n   */\n\n\n  pow(other) {\n    if (this.matrix) {\n      if (AComputable.isNumeric(other)) {\n        let newMatrix = this;\n\n        for (let i = 0; i < other; i++) {\n          let tmp = newMatrix.mul(this).result;\n\n          if (AComputable.isMatrix(tmp)) {\n            newMatrix = tmp;\n          } else {\n            throw new MatrixError(\"somethin happened bruh.\");\n          }\n        }\n\n        return {\n          result: newMatrix\n        };\n      } else {\n        throw new MatrixError(\"matrix power is not supported\");\n      }\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * evaluates matrix from raw nodes\n   */\n\n\n  evaluate() {\n    if (!this.matrix) {\n      let arr = new Array();\n\n      for (let row = 0; row < this.dimR; row++) {\n        arr.push([]);\n\n        for (let col = 0; col < this.dimC; col++) {\n          let val = this.nodes[row][col].eval();\n\n          if (AComputable.isNumeric(val)) {\n            arr[row].push(val);\n          } else {\n            throw new SyntaxError(\"couldn't evaluate matrix! expected numbers.\");\n          }\n        }\n      }\n\n      this.matrix = arr;\n    }\n  }\n\n  transpose(save = false) {\n    if (this.matrix) {\n      let arr = new Array();\n\n      for (let i = 0; i < this.dimC; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimR; j++) {\n          arr[i].push(this.matrix[j][i]);\n        }\n      }\n\n      if (save) {\n        this.matrix = arr;\n        let tmp = this.dimR;\n        this.dimR = this.dimC;\n        this.dimC = tmp;\n        return {\n          result: this\n        };\n      }\n\n      return {\n        result: new Matrix(undefined, arr)\n      };\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet!\");\n  }\n\n  toString() {\n    let m = this.matrix;\n\n    if (m) {\n      let str = \"\";\n\n      if (m.length == 1) {\n        str += \"< \";\n\n        for (let i = 0; i < m[0].length; i++) {\n          str += m[0][i];\n\n          if (i != m[0].length - 1) {\n            str += \", \";\n          }\n        }\n\n        str += \" >\";\n      } else {\n        str += `  { ${this.dimR} x ${this.dimC} }`;\n      }\n\n      return str;\n    } else {\n      throw new ParsingError(\"matrix has not been evaluated yet!\");\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/computable.ts"],"names":["MatrixError","ParsingError","AComputable","isMatrix","el","Matrix","isNumeric","isComputable","constructor","nodes","Array","rows","undefined","matrix","dimR","dimC","length","row","checkDimensions","other","add","arr","i","push","j","result","sub","el_mul","mul","transpose","message","newMatrix","temp","k","div","rdiv","Math","floor","pow","tmp","evaluate","col","val","eval","SyntaxError","save","toString","m","str"],"mappings":"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","sourcesContent":["import { AST, ComputableNode } from \"./ast\";\nimport { ArithmeticError, MatrixError, ParsingError } from \"./errors\";\n\nexport type Computable = number | AComputable;\n\nexport interface Result {\n  result: Computable;\n  message?: string;\n}\n\ninterface MatrixResult extends Result {\n  result: Matrix;\n}\n\nexport abstract class AComputable {\n  public abstract add(other: number): Result;\n  public abstract add(other: AComputable): Result;\n  public abstract sub(other: number): Result;\n  public abstract sub(other: AComputable): Result;\n  public abstract mul(other: number): Result;\n  public abstract mul(other: AComputable): Result;\n  public abstract div(other: number): Result;\n  public abstract div(other: AComputable): Result;\n  public abstract pow(other: number): Result;\n  public abstract pow(other: AComputable): Result;\n\n  /**\n   * checks if given element is of type matrix\n   * @param el any element\n   */\n  public static isMatrix(el: Computable): el is Matrix {\n    return el instanceof Matrix;\n  }\n\n  /**\n   * checks if given element is of type number\n   * @param el any element\n   */\n  public static isNumeric(el: Computable): el is number {\n    return typeof el === \"number\";\n  }\n\n  /**\n   * checks if given element is of type computable\n   * @param el any element\n   */\n  public static isComputable(el: any): el is Computable {\n    return el instanceof AComputable || typeof el === \"number\";\n  }\n}\n\nexport class Matrix extends AComputable {\n  matrix: number[][] | undefined;\n  private nodes: ComputableNode[][];\n  dimR: number;\n  dimC: number;\n\n  constructor(\n    nodes: ComputableNode[][] | undefined = new Array(),\n    rows: number[][] | undefined = undefined\n  ) {\n    super();\n    if (!rows) {\n      // raw node matrix\n      this.nodes = nodes;\n      this.matrix = undefined;\n      this.dimR = nodes.length;\n      this.dimC = this.dimR > 0 ? nodes[0].length : 0;\n\n      // verify each row is the same length\n      for (let row of nodes) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    } else {\n      // populate matrix with numbers\n      this.nodes = new Array();\n      this.matrix = rows;\n      this.dimR = rows.length;\n      this.dimC = this.dimR > 0 ? rows[0].length : 0;\n\n      // verify each row is the same length\n      for (let row of rows) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    }\n  }\n\n  private checkDimensions(other: Matrix) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(\n        `can't add matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n      );\n    }\n  }\n\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n  public add(other: Computable): MatrixResult {\n    if (this.matrix) {\n      let arr: number[][] = new Array();\n      if (AComputable.isMatrix(other) && other.matrix) {\n        // add two matricies together\n        this.checkDimensions(other);\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] + other.matrix[i][j]);\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        // add constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] + other);\n          }\n        }\n      }\n\n      return { result: new Matrix(undefined, arr) };\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n  public sub(other: Computable): MatrixResult {\n    if (this.matrix) {\n      let arr: number[][] = new Array();\n\n      if (AComputable.isMatrix(other) && other.matrix) {\n        // subtract two matricies together\n        this.checkDimensions(other);\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] - other.matrix[i][j]);\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        // subtract constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] - other);\n          }\n        }\n      }\n\n      return { result: new Matrix(undefined, arr) };\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n  public el_mul(other: Matrix): MatrixResult {\n    if (this.matrix && other.matrix) {\n      if (this.dimC == other.dimC && this.dimR == other.dimR) {\n        let arr: number[][] = new Array();\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] * other.matrix[i][j]);\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      } else {\n        throw new MatrixError(\n          \"cannot do element-wise multiplication on different sized matricies\"\n        );\n      }\n    }\n\n    throw new ParsingError(\"matrix hasn't been evaulated yet!\");\n  }\n\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n  public mul(other: Computable): Result {\n    if (this.matrix) {\n      if (AComputable.isMatrix(other)) {\n        if (other.matrix) {\n          // multiply two matricies\n          // check dimensions are proper\n          if (this.dimC != other.dimR) {\n            if (this.dimC == other.dimC && this.dimR == other.dimR) {\n              return {\n                result: this.mul(other.transpose().result).result,\n                message: \"inferred to take dot product.\",\n              };\n            }\n            throw new MatrixError(\n              `can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n            );\n          }\n          let newMatrix: number[][] = new Array();\n          for (let i = 0; i < this.dimR; i++) {\n            newMatrix.push([]);\n            for (let j = 0; j < other.dimC; j++) {\n              let temp = 0;\n              for (let k = 0; k < this.dimC; k++) {\n                temp += this.matrix[i][k] * other.matrix[k][j];\n              }\n              newMatrix[i].push(temp);\n            }\n          }\n          if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n            return { result: newMatrix[0][0] };\n          } else {\n            return { result: new Matrix(undefined, newMatrix) };\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        let arr: number[][] = new Array();\n        // multiply constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] * other);\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      } else {\n        throw new MatrixError(\"couldn't multiply with a \" + other);\n      }\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public div(other: Computable): MatrixResult {\n    if (this.matrix) {\n      if (AComputable.isNumeric(other)) {\n        let arr: number[][] = new Array();\n        // multiply constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.matrix[i][j] / other);\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      }\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public rdiv(other: Computable): MatrixResult {\n    if (this.matrix) {\n      if (AComputable.isNumeric(other)) {\n        let arr: number[][] = new Array();\n        // multiply constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(Math.floor(this.matrix[i][j] / other));\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      }\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * take power\n   * @param other\n   */\n  public pow(other: Computable): MatrixResult {\n    if (this.matrix) {\n      if (AComputable.isNumeric(other)) {\n        let newMatrix: Matrix = this;\n        for (let i = 0; i < other; i++) {\n          let tmp = newMatrix.mul(this).result;\n          if (AComputable.isMatrix(tmp)) {\n            newMatrix = tmp;\n          } else {\n            throw new MatrixError(\"somethin happened bruh.\");\n          }\n        }\n        return { result: newMatrix };\n      } else {\n        throw new MatrixError(\"matrix power is not supported\");\n      }\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * evaluates matrix from raw nodes\n   */\n  public evaluate() {\n    if (!this.matrix) {\n      let arr: number[][] = new Array();\n      for (let row = 0; row < this.dimR; row++) {\n        arr.push([]);\n        for (let col = 0; col < this.dimC; col++) {\n          let val = this.nodes[row][col].eval();\n          if (AComputable.isNumeric(val)) {\n            arr[row].push(val);\n          } else {\n            throw new SyntaxError(\n              \"couldn't evaluate matrix! expected numbers.\"\n            );\n          }\n        }\n      }\n      this.matrix = arr;\n    }\n  }\n\n  public transpose(save: boolean = false): MatrixResult {\n    if (this.matrix) {\n      let arr: number[][] = new Array();\n      for (let i = 0; i < this.dimC; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimR; j++) {\n          arr[i].push(this.matrix[j][i]);\n        }\n      }\n\n      if (save) {\n        this.matrix = arr;\n        let tmp = this.dimR;\n        this.dimR = this.dimC;\n        this.dimC = tmp;\n        return { result: this };\n      }\n      return { result: new Matrix(undefined, arr) };\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet!\");\n  }\n\n  public toString(): string {\n    let m = this.matrix;\n    if (m) {\n      let str = \"\";\n      if (m.length == 1) {\n        str += \"< \";\n        for (let i = 0; i < m[0].length; i++) {\n          str += m[0][i];\n          if (i != m[0].length - 1) {\n            str += \", \";\n          }\n        }\n        str += \" >\";\n      } else {\n        str += `  { ${this.dimR} x ${this.dimC} }`;\n      }\n\n      return str;\n    } else {\n      throw new ParsingError(\"matrix has not been evaluated yet!\");\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}