{"ast":null,"code":"import { MatrixError, ParsingError } from \"./errors\";\nexport class AComputable {\n  /**\n   * checks if given element is of type matrix\n   * @param el any element\n   */\n  static isMatrix(el) {\n    return el instanceof Matrix;\n  }\n  /**\n   * checks if given element is of type number\n   * @param el any element\n   */\n\n\n  static isNumeric(el) {\n    return typeof el === \"number\";\n  }\n  /**\n   * checks if given element is of type computable\n   * @param el any element\n   */\n\n\n  static isComputable(el) {\n    return el instanceof AComputable || typeof el === \"number\";\n  }\n\n}\nexport class Matrix extends AComputable {\n  constructor(nodes = new Array(), rows = undefined) {\n    super();\n    this.rows = void 0;\n    this.nodes = void 0;\n    this.dimR = void 0;\n    this.dimC = void 0;\n\n    if (!rows) {\n      // raw node matrix\n      this.nodes = nodes;\n      this.rows = undefined;\n      this.dimR = nodes.length;\n      this.dimC = this.dimR > 0 ? nodes[0].length : 0; // verify each row is the same length\n\n      for (let row of nodes) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    } else {\n      // populate matrix with numbers\n      this.nodes = new Array();\n      this.rows = rows;\n      this.dimR = rows.length;\n      this.dimC = this.dimR > 0 ? rows[0].length : 0; // verify each row is the same length\n\n      for (let row of rows) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    }\n  }\n\n  checkDimensions(other) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(`can't add matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n    }\n  }\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n\n\n  add(other) {\n    if (this.rows) {\n      let arr = new Array();\n\n      if (AComputable.isMatrix(other) && other.rows) {\n        // add two matricies together\n        this.checkDimensions(other);\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] + other.rows[i][j]);\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        // add constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] + other);\n          }\n        }\n      }\n\n      return {\n        result: new Matrix(undefined, arr)\n      };\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n\n\n  sub(other) {\n    if (this.rows) {\n      let arr = new Array();\n\n      if (AComputable.isMatrix(other) && other.rows) {\n        // subtract two matricies together\n        this.checkDimensions(other);\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] - other.rows[i][j]);\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        // subtract constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] - other);\n          }\n        }\n      }\n\n      return {\n        result: new Matrix(undefined, arr)\n      };\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n\n\n  el_mul(other) {\n    if (this.rows && other.rows) {\n      if (this.dimC == other.dimC && this.dimR == other.dimR) {\n        let arr = new Array();\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] * other.rows[i][j]);\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      } else {\n        throw new MatrixError(\"cannot do element-wise multiplication on different sized matricies\");\n      }\n    }\n\n    throw new ParsingError(\"matrix hasn't been evaulated yet!\");\n  }\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n\n\n  mul(other) {\n    if (this.rows) {\n      if (AComputable.isMatrix(other)) {\n        if (other.rows) {\n          // multiply two matricies\n          // check dimensions are proper\n          if (this.dimC != other.dimR) {\n            if (this.dimC == other.dimC && this.dimR == other.dimR) {\n              return {\n                result: this.mul(other.transpose().result).result,\n                message: \"inferred to take dot product.\"\n              };\n            }\n\n            throw new MatrixError(`can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`);\n          }\n\n          let newMatrix = new Array();\n\n          for (let i = 0; i < this.dimR; i++) {\n            newMatrix.push([]);\n\n            for (let j = 0; j < other.dimC; j++) {\n              let temp = 0;\n\n              for (let k = 0; k < this.dimC; k++) {\n                temp += this.rows[i][k] * other.rows[k][j];\n              }\n\n              newMatrix[i].push(temp);\n            }\n          }\n\n          if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n            return {\n              result: newMatrix[0][0]\n            };\n          } else {\n            return {\n              result: new Matrix(undefined, newMatrix)\n            };\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        let arr = new Array(); // multiply constant to each element\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] * other);\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      } else {\n        throw new MatrixError(\"couldn't multiply with a \" + other);\n      }\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  div(other) {\n    if (this.rows) {\n      if (AComputable.isNumeric(other)) {\n        let arr = new Array(); // multiply constant to each element\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] / other);\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      }\n\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n\n\n  rdiv(other) {\n    if (this.rows) {\n      if (AComputable.isNumeric(other)) {\n        let arr = new Array(); // multiply constant to each element\n\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(Math.floor(this.rows[i][j] / other));\n          }\n        }\n\n        return {\n          result: new Matrix(undefined, arr)\n        };\n      }\n\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * take power\n   * @param other\n   */\n\n\n  pow(other) {\n    if (this.rows) {\n      if (AComputable.isNumeric(other)) {\n        let newMatrix = this;\n\n        for (let i = 0; i < other; i++) {\n          let tmp = newMatrix.mul(this).result;\n\n          if (AComputable.isMatrix(tmp)) {\n            newMatrix = tmp;\n          } else {\n            throw new MatrixError(\"somethin happened bruh.\");\n          }\n        }\n\n        return {\n          result: newMatrix\n        };\n      } else {\n        throw new MatrixError(\"matrix power is not supported\");\n      }\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n  /**\n   * evaluates matrix from raw nodes\n   */\n\n\n  evaluate() {\n    if (!this.rows) {\n      let arr = new Array();\n\n      for (let row = 0; row < this.dimR; row++) {\n        arr.push([]);\n\n        for (let col = 0; col < this.dimC; col++) {\n          let val = this.nodes[row][col].eval();\n\n          if (AComputable.isNumeric(val)) {\n            arr[row].push(val);\n          } else {\n            throw new SyntaxError(\"couldn't evaluate matrix! expected numbers.\");\n          }\n        }\n      }\n\n      this.rows = arr;\n    }\n  }\n\n  transpose(save = false) {\n    if (this.rows) {\n      let arr = new Array();\n\n      for (let i = 0; i < this.dimC; i++) {\n        arr.push([]);\n\n        for (let j = 0; j < this.dimR; j++) {\n          arr[i].push(this.rows[j][i]);\n        }\n      }\n\n      if (save) {\n        this.rows = arr;\n        let tmp = this.dimR;\n        this.dimR = this.dimC;\n        this.dimC = tmp;\n        return {\n          result: this\n        };\n      }\n\n      return {\n        result: new Matrix(undefined, arr)\n      };\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet!\");\n  }\n\n  toString() {\n    let str = JSON.stringify(this.rows);\n    str += `\\t{ ${this.dimR} x ${this.dimC} }`;\n    return str;\n  }\n\n}","map":{"version":3,"sources":["/Users/pranavputta/GitHub/linalg_lang/frontend/src/interpreter/computable.ts"],"names":["MatrixError","ParsingError","AComputable","isMatrix","el","Matrix","isNumeric","isComputable","constructor","nodes","Array","rows","undefined","dimR","dimC","length","row","checkDimensions","other","add","arr","i","push","j","result","sub","el_mul","mul","transpose","message","newMatrix","temp","k","div","rdiv","Math","floor","pow","tmp","evaluate","col","val","eval","SyntaxError","save","toString","str","JSON","stringify"],"mappings":"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","sourcesContent":["import { AST, ComputableNode } from \"./ast\";\nimport { ArithmeticError, MatrixError, ParsingError } from \"./errors\";\n\nexport type Computable = number | AComputable;\n\nexport interface Result {\n  result: Computable;\n  message?: string;\n}\n\ninterface MatrixResult extends Result {\n  result: Matrix;\n}\n\nexport abstract class AComputable {\n  public abstract add(other: number): Result;\n  public abstract add(other: AComputable): Result;\n  public abstract sub(other: number): Result;\n  public abstract sub(other: AComputable): Result;\n  public abstract mul(other: number): Result;\n  public abstract mul(other: AComputable): Result;\n  public abstract div(other: number): Result;\n  public abstract div(other: AComputable): Result;\n  public abstract pow(other: number): Result;\n  public abstract pow(other: AComputable): Result;\n\n  /**\n   * checks if given element is of type matrix\n   * @param el any element\n   */\n  public static isMatrix(el: Computable): el is Matrix {\n    return el instanceof Matrix;\n  }\n\n  /**\n   * checks if given element is of type number\n   * @param el any element\n   */\n  public static isNumeric(el: Computable): el is number {\n    return typeof el === \"number\";\n  }\n\n  /**\n   * checks if given element is of type computable\n   * @param el any element\n   */\n  public static isComputable(el: any): el is Computable {\n    return el instanceof AComputable || typeof el === \"number\";\n  }\n}\n\nexport class Matrix extends AComputable {\n  rows: number[][] | undefined;\n  private nodes: ComputableNode[][];\n  dimR: number;\n  dimC: number;\n\n  constructor(\n    nodes: ComputableNode[][] | undefined = new Array(),\n    rows: number[][] | undefined = undefined\n  ) {\n    super();\n    if (!rows) {\n      // raw node matrix\n      this.nodes = nodes;\n      this.rows = undefined;\n      this.dimR = nodes.length;\n      this.dimC = this.dimR > 0 ? nodes[0].length : 0;\n\n      // verify each row is the same length\n      for (let row of nodes) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    } else {\n      // populate matrix with numbers\n      this.nodes = new Array();\n      this.rows = rows;\n      this.dimR = rows.length;\n      this.dimC = this.dimR > 0 ? rows[0].length : 0;\n\n      // verify each row is the same length\n      for (let row of rows) {\n        if (row.length != this.dimC) {\n          throw new MatrixError(\"row dimensions did not match\");\n        }\n      }\n    }\n  }\n\n  private checkDimensions(other: Matrix) {\n    if (this.dimR != other.dimR || this.dimC != other.dimC) {\n      throw new MatrixError(\n        `can't add matricies of different dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n      );\n    }\n  }\n\n  /**\n   * add two matricies together by elementwise addition or add a constant to the matrix\n   * @param other a computable object\n   */\n  public add(other: Computable): MatrixResult {\n    if (this.rows) {\n      let arr: number[][] = new Array();\n      if (AComputable.isMatrix(other) && other.rows) {\n        // add two matricies together\n        this.checkDimensions(other);\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] + other.rows[i][j]);\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        // add constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] + other);\n          }\n        }\n      }\n\n      return { result: new Matrix(undefined, arr) };\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * subtracts matrix from this, or subtracts constant from each element\n   * @param other any computable item\n   */\n  public sub(other: Computable): MatrixResult {\n    if (this.rows) {\n      let arr: number[][] = new Array();\n\n      if (AComputable.isMatrix(other) && other.rows) {\n        // subtract two matricies together\n        this.checkDimensions(other);\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] - other.rows[i][j]);\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        // subtract constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] - other);\n          }\n        }\n      }\n\n      return { result: new Matrix(undefined, arr) };\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * element-wise multiplication\n   * @param other\n   */\n  public el_mul(other: Matrix): MatrixResult {\n    if (this.rows && other.rows) {\n      if (this.dimC == other.dimC && this.dimR == other.dimR) {\n        let arr: number[][] = new Array();\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] * other.rows[i][j]);\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      } else {\n        throw new MatrixError(\n          \"cannot do element-wise multiplication on different sized matricies\"\n        );\n      }\n    }\n\n    throw new ParsingError(\"matrix hasn't been evaulated yet!\");\n  }\n\n  /**\n   * computes the matrix product or multiplies a matrix by a scalar\n   * @param other any computable item\n   */\n  public mul(other: Computable): Result {\n    if (this.rows) {\n      if (AComputable.isMatrix(other)) {\n        if (other.rows) {\n          // multiply two matricies\n          // check dimensions are proper\n          if (this.dimC != other.dimR) {\n            if (this.dimC == other.dimC && this.dimR == other.dimR) {\n              return {\n                result: this.mul(other.transpose().result).result,\n                message: \"inferred to take dot product.\",\n              };\n            }\n            throw new MatrixError(\n              `can't multiply matricies of non-matching dimensions! (${this.dimR} x ${this.dimC}) and (${other.dimR} x ${other.dimC})`\n            );\n          }\n          let newMatrix: number[][] = new Array();\n          for (let i = 0; i < this.dimR; i++) {\n            newMatrix.push([]);\n            for (let j = 0; j < other.dimC; j++) {\n              let temp = 0;\n              for (let k = 0; k < this.dimC; k++) {\n                temp += this.rows[i][k] * other.rows[k][j];\n              }\n              newMatrix[i].push(temp);\n            }\n          }\n          if (newMatrix.length == 1 && newMatrix[0].length == 1) {\n            return { result: newMatrix[0][0] };\n          } else {\n            return { result: new Matrix(undefined, newMatrix) };\n          }\n        }\n      } else if (AComputable.isNumeric(other)) {\n        let arr: number[][] = new Array();\n        // multiply constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] * other);\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      } else {\n        throw new MatrixError(\"couldn't multiply with a \" + other);\n      }\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public div(other: Computable): MatrixResult {\n    if (this.rows) {\n      if (AComputable.isNumeric(other)) {\n        let arr: number[][] = new Array();\n        // multiply constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(this.rows[i][j] / other);\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      }\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * divide by a scalar, matrix division is not supported\n   * @param other\n   */\n  public rdiv(other: Computable): MatrixResult {\n    if (this.rows) {\n      if (AComputable.isNumeric(other)) {\n        let arr: number[][] = new Array();\n        // multiply constant to each element\n        for (let i = 0; i < this.dimR; i++) {\n          arr.push([]);\n          for (let j = 0; j < this.dimC; j++) {\n            arr[i].push(Math.floor(this.rows[i][j] / other));\n          }\n        }\n        return { result: new Matrix(undefined, arr) };\n      }\n      throw new MatrixError(\"matrix division is not supported.\");\n    }\n\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * take power\n   * @param other\n   */\n  public pow(other: Computable): MatrixResult {\n    if (this.rows) {\n      if (AComputable.isNumeric(other)) {\n        let newMatrix: Matrix = this;\n        for (let i = 0; i < other; i++) {\n          let tmp = newMatrix.mul(this).result;\n          if (AComputable.isMatrix(tmp)) {\n            newMatrix = tmp;\n          } else {\n            throw new MatrixError(\"somethin happened bruh.\");\n          }\n        }\n        return { result: newMatrix };\n      } else {\n        throw new MatrixError(\"matrix power is not supported\");\n      }\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet.\");\n  }\n\n  /**\n   * evaluates matrix from raw nodes\n   */\n  public evaluate() {\n    if (!this.rows) {\n      let arr: number[][] = new Array();\n      for (let row = 0; row < this.dimR; row++) {\n        arr.push([]);\n        for (let col = 0; col < this.dimC; col++) {\n          let val = this.nodes[row][col].eval();\n          if (AComputable.isNumeric(val)) {\n            arr[row].push(val);\n          } else {\n            throw new SyntaxError(\n              \"couldn't evaluate matrix! expected numbers.\"\n            );\n          }\n        }\n      }\n      this.rows = arr;\n    }\n  }\n\n  public transpose(save: boolean = false): MatrixResult {\n    if (this.rows) {\n      let arr: number[][] = new Array();\n      for (let i = 0; i < this.dimC; i++) {\n        arr.push([]);\n        for (let j = 0; j < this.dimR; j++) {\n          arr[i].push(this.rows[j][i]);\n        }\n      }\n\n      if (save) {\n        this.rows = arr;\n        let tmp = this.dimR;\n        this.dimR = this.dimC;\n        this.dimC = tmp;\n        return { result: this };\n      }\n      return { result: new Matrix(undefined, arr) };\n    }\n    throw new ParsingError(\"matrix has not been evaluated yet!\");\n  }\n\n  public toString(): string {\n    let str = JSON.stringify(this.rows);\n    str += `\\t{ ${this.dimR} x ${this.dimC} }`;\n    return str;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}